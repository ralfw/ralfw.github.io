<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Event Sourcing Challenge: Bowling Game Kata - One Man Think Tank</title><meta name="description" content=" Event Sourcing ist für mich die Zukunft der grundsätzlichen Zustandshaltung in Software. Alles andere ist eine Optimierung, die man nicht leichtfertig und schon gar nicht vorzeitig vornehmen sollte. Mit Event Sourcing verdrängt endlich Konstruktivismus den bisherigen Materialismus des immer noch dominierenden RDBMS/OO-Denkens.1 Und ich&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/homepage-ralfw-de/event-sourcing-challenge-bowling-game-kata/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/homepage-ralfw-de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/homepage-ralfw-de/feed.json"><meta property="og:title" content="Event Sourcing Challenge: Bowling Game Kata"><meta property="og:image" content="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-3.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content=" Event Sourcing ist für mich die Zukunft der grundsätzlichen Zustandshaltung in Software. Alles andere ist eine Optimierung, die man nicht leichtfertig und schon gar nicht vorzeitig vornehmen sollte. Mit Event Sourcing verdrängt endlich Konstruktivismus den bisherigen Materialismus des immer noch dominierenden RDBMS/OO-Denkens.1 Und ich&hellip;"><meta property="og:url" content="https://ralfw.github.io/homepage-ralfw-de/event-sourcing-challenge-bowling-game-kata/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/homepage-ralfw-de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/homepage-ralfw-de/assets/css/style.css?v=990f047e8c3c2bb3deca98e2b36861df"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/homepage-ralfw-de/event-sourcing-challenge-bowling-game-kata/"},"headline":"Event Sourcing Challenge: Bowling Game Kata","datePublished":"2019-12-17T12:44","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-3.png","height":480,"width":576},"description":" Event Sourcing ist für mich die Zukunft der grundsätzlichen Zustandshaltung in Software. Alles andere ist eine Optimierung, die man nicht leichtfertig und schon gar nicht vorzeitig vornehmen sollte. Mit Event Sourcing verdrängt endlich Konstruktivismus den bisherigen Materialismus des immer noch dominierenden RDBMS/OO-Denkens.1 Und ich&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/website/logo.png","height":860,"width":4068}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/homepage-ralfw-de/"><img src="https://ralfw.github.io/homepage-ralfw-de/media/website/logo.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/homepage-ralfw-de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/approach/" target="_self">Approach</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/about/" target="_self">About</a></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-3.png" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="480" width="576" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-12-17T12:44">17.12.2019</time></div><h1>Event Sourcing Challenge: Bowling Game Kata</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/homepage-ralfw-de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>Event Sourcing ist für mich die Zukunft der grundsätzlichen Zustandshaltung in Software. Alles andere ist eine Optimierung, die man nicht leichtfertig und schon gar nicht vorzeitig vornehmen sollte.</p><p></p><p></p><p>Mit Event Sourcing verdrängt endlich <a href="https://ralfw.de/2019/06/event-sourcing-for-constructivist-software/" target="_blank" rel="noopener">Konstruktivismus</a> den bisherigen Materialismus des immer noch dominierenden RDBMS/OO-Denkens.<sup><a id="ffn1" class="footnote" href="#fn1">1</a></sup> Und ich halte Event Sourcing für die Grundlage von Antifragilität in der Softwareentwicklung.<sup><a id="ffn2" class="footnote" href="#fn2">2</a></sup></p><p></p><p></p><p>Ich finde Event Sourcing also sehr spannend und wichtig – nur leicht ist es nicht. Denn auch wenn Event Sourcing auf das eine Datenmodell, die eine große Datenstruktur verzichtet, bedeutet das nicht, dass man sich keine Gedanken um Datenmodelle machen muss.</p><p></p><p></p><p>Damit meine ich nicht die vielen situationsspezifischen Strukturen, die nun sehr einfach möglich werden. Für jede Interaktion mit einer Software kann es nun ein daraufhin optimiertes Datenmodell geben.</p><p></p><p></p><p>Ich meine die Events, die beim Event Sourcing in einem stetig wachsenden Strom gespeichert werden und den sich entwickelnden Systemzustand repräsentieren. Statt des einen großen Datenmodells gibt es im Event Sourcing ein Granulat bestehend aus kleinen und kleinsten Datenstrukturen, den Events.</p><p></p><p></p><p>Das ist für das RDBMS- oder auch Dokumenten-gewohnte Denken eine Umstellung. Während man bisher versuchen konnte, „die Struktur der Welt“ zu erkennen und möglichst realitätsgetreu in Software abzubilden, geht es jetzt um ihre Entfaltung über die Zeit. Es geht nicht mehr um statische Resultate von letztlich irrelevanten Ereignissen, sondern um höchst relevante Ereignisse, aus denen alle möglichen Resultate in Zukunft abgeleitet werden können.</p><p></p><p></p><p>Die Welt der Zustandshaltung steht damit Kopf, würde ich sagen.&#x1f643;&#x1f601;</p><p></p><p></p><p>Gedanken muss man sich also beim Event Sourcing um die Events machen. Klingt auch ohne große Einleitungsworte plausible, oder?&#x1f609;</p><p></p><p></p><p>Wie findet man aber „die besten“ Events? Was sind überhaupt „gute“ Events? Das sind Fragen, die mich deshalb bewegen. Ich suche Prinzipien und Heuristiken, um für gegebenen Anforderungen mindestens „ziemlich gute“ Events zu finden.</p><p></p><p></p><h2>Die Challenge</h2><p></p><p></p><p>Deshalb habe ich im Domain Driven Design Slack-Workspace „DDD Germany“ mal nachgefragt, wie man dort die Sache sieht. Getan habe ich das mit einer kleinen Aufgabe, die mir einerseits sehr überschaubar scheint, andererseits aber doch ein bisschen Herausforderung bietet.<sup><a id="ffn3" class="footnote" href="#fn3">3</a></sup></p><p></p><p></p><p><a href="https://paper.dropbox.com/doc/EventSourcing-Challenge-Die-Bowling-Game-Kata--AqiYiJ05NEjMjfC6iUSFxU2lAg-MrmZs8ODudTrrlrvSi5i0" target="_blank" rel="noopener">Als Aufgabe</a> habe ich die aus Coding Dojos bekannte Bowling Game Kata gewählt:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="alignnone wp-image-2773"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2xl.png 1600w" alt="" width="548" height="1244"></figure></figure></div><p></p><p></p><p>Es soll ein „Ergebniszähler“ realisiert werden, der die Punktzahl eines Bowling-Spiels bestimmt. Dieser Zähler reagiert auf zwei CQS-Nachrichten: dass ein Wurf registriert und dass das Ergebnis geliefert werden soll. Mehr nicht.</p><p></p><p></p><p>Es gibt also zwei glasklare Interaktionen der Umwelt mit einer Zähler-Software. Darüber muss nicht spekuliert werden. Die einzige Frage, die die Aufgabe stellt, ist die nach den Events.</p><p></p><p></p><p>Die Interaktionen basieren auf gemeinsamem Zustand. Dieser Zustand soll mit Event Sourcing realisiert gedacht werden, d.h. als Strom von Events. Welche Events sollten das sein?</p><p></p><p></p><p>Mehr ist nicht zu liefern, nur die Events. Die Lösung soll gerade nicht komplett implementiert werden, weil es mir ja darum geht, wie Events <em>a priori</em> gefunden werden können.</p><p></p><p></p><p>Event Storming - nomen es omen - ist eine Technik, die dafür zum Einsatz kommen könnte; allerdings sehe ich sie vor allem bei Szenarien, die deutlich größer sind und/oder bei denen es viele Sichtweisen zu berücksichtigen gilt.<sup><a id="ffn4" class="footnote" href="#fn4">4</a></sup></p><p></p><p></p><p>Dass man nach Implementation und Betrieb einer Lösung immer schlauer ist und also vielleicht auch eine noch bessere Idee hat, welche Events nützlich wären, scheint mir ausgemacht. Wie bei RDBMS oder umfänglichen Objektmodellen ist eine Änderung der Datenbasis dann jedoch schwierig. Und Event Sourcing verspricht ja, dass man gerade das nicht tun muss/soll.</p><p></p><p></p><p>Events versionieren, weitere Events später nachschieben, einen Eventstrom komplett umschreiben: das kann man alles machen und es mag zuzeiten nötig sein. Doch so, wie es einige Kriterien für RDBMS-Schemata gibt, um nicht gleich mit dem falschen Fuß aufzustehen, so gibt es ja vielleicht auch Kriterien für das Schneiden von Events, um den Zeitpunkt hinauszuzögern, da man sich in eine Ecke gepinselt hat. Was meint die DDD-Community dazu?</p><p></p><p></p><h2>Die Lösungen</h2><p></p><p></p><p>Ich hatte zuerst für mich selbst die Aufgabe gelöst (und natürlich doch nicht darauf verzichtet, den kompletten Code dafür zu schreiben&#x1f92a;). Ohne meine Events zu verraten, habe ich dann die Aufgabe der Community vorgelegt und weitere vier Lösungen bekommen.</p><p></p><p></p><p>Ich liste sie einfach mal mit den Slack-Benutzernamen ihrer Einreicher in alphabetischer Reihenfolge:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2772"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-1-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-1-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-1-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-1-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-1-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-1-2xl.png 1600w" alt="Lösung von @akii" width="241" height="79"></figure><figcaption>Lösung von @akii</figcaption></figure></div><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2774"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-2-2xl.png 1600w" alt="Lösung von @bwaidelich" width="273" height="77"></figure><figcaption>Lösung von @bwaidelich</figcaption></figure></div><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2769"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-3.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-3-2xl.png 1600w" alt="Lösung von @phj" width="405" height="338"></figure><figcaption>Lösung von @phj</figcaption></figure></div><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2770"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-4.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-4-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-4-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-4-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-4-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-4-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-4-2xl.png 1600w" alt="Meine eigene Lösung (@ralfw)" width="443" height="396"></figure><figcaption>Meine eigene Lösung (@ralfw)</figcaption></figure></div><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2771"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/DraggedImage-5.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-5-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-5-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-5-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-5-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-5-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/138/responsive/DraggedImage-5-2xl.png 1600w" alt="Lösung von @sebastian" width="231" height="211"></figure><figcaption>Lösung von @sebastian</figcaption></figure></div><p></p><p></p><p>Die Lösungen wurden in Pseudocode, Typescript, C#, F# eingereicht. Ich habe sie zur besseren Vergleichbarkeit alle nach C# übersetzt. Ein bisschen ging dabei die Ausdrucksfähigkeit von F# (@phj) verloren, aber das finde ich nicht schlimm.</p><p></p><p></p><p>Außerdem habe ich sie insofern vereinheitlicht, als dass ich eine Game ID, die in manchen Lösungen in den Events stand, gelöscht habe. Ich denke, sie trägt in Bezug auf diese Aufgabe nichts zur Erkenntnis von Prinzipien und Heuristiken bei und betrifft einen orthogonalen Belang.</p><p></p><p></p><h3>Lösungsebenen</h3><p></p><p></p><p>Die Aufgabe war nicht groß. Die Lösungsvorschläge sollten also nicht so weit auseinander liegen. So hatte ich es mir gedacht - und war dann doch überrascht, dass selbst hier eine Lösungsvielfalt entstanden ist.</p><p></p><p></p><p>Ich sehe die Lösungen auf drei Ebenen:</p><p></p><p></p><ol><li>Minimallösung (@akii, @bwaidelich): Es wird nur ein Event benötigt, der die über das Kommando gemeldeten geworfenen Pins aufzeichnet.</li><li>Aufzeichnung von Bonuspunkten (@sebastian): Zusätzlich zum Event der Minimallösung wird aufgezeichnet, dass ein Wurf als Bonus für einen vorhergehenden anerkannt wurde.</li><li>Aufzeichnung von Frames und Bonuswürdigkeit (@phj, @ralfw): Zusätzlich zu den Events der zweiten Ebene wird aufgezeichnet, falls ein Wurf einen Frame beendet hat und ob der Frame bonuswürdig ist (Spare oder Strike).</li></ol><p></p><p></p><h3>Analyse</h3><p></p><p></p><p>Die Idee hinter der Aufgabe war, dass ein Event Store befüllt wird mit Events im Rahmen der Verarbeitung des einen Kommandos - und dass die Events während der einen Query zu einem Gesamtergebnis verarbeitet werden.</p><p></p><p></p><p>Die Logik zur Herstellung des Verhaltens würde sich in einer Implementation also auf einen Command- und einen Query-Handler verteilen. Die Wahl der Events hat darauf einen großen Einfluss.</p><p></p><p></p><p>Die Minimallösungen zeichnen im Grunde nur die mit dem Kommando gemeldeten Pins eines Wurfes 1:1 auf. Das ist trivial, so dass die ganze Last der Ergebnisberechnung bei der Query-Verarbeitung liegt. Die Minimallösungen betreiben mithin eigentlich kein Event Sourcing, sondern eher ein Command Sourcing.</p><p></p><p></p><p>Die Bonuspunktlösung verschiebt die Last zum Command-Handling. Bei der Query-Verarbeitung müssen nur die Pins aus den Events für die Würfe und die Bonuspunkte addiert werden. Das ist trivial - dafür muss die Kommando-Verarbeitung allerdings vorher entschieden haben, wann ein Bonuspunkt-Event aufzuzeichnen ist.</p><p></p><p></p><p>Die Frame-/Bonuswürdigkeit-Lösungen vereinfachen die Logik der Query-Verarbeitung nicht weiter; die bleibt trivial. Die zusätzlichen Events wirken sich vielmehr auf das Command-Handling differenzierend aus. Vielleicht wächst die Logik dort noch ein wenig, vor allem scheint es mir aber einfacher, in der Kommando-Verarbeitung Verantwortlichkeiten zu trennen: festzustellen, ob/ab wann ein Bonus gewährt wird, und einen Bonus zuzuweisen, sind eben zwei verschiedene Aufgaben.</p><p></p><p></p><p>Interessant finde ich, dass keine Lösung einen Event zur Anzeige eines Spielendes definiert.<sup><a id="ffn5" class="footnote" href="#fn5">5</a></sup> Ist das kein Aufzeichnungswürdiges Ereignis? Oder war die Aufgabe so formuliert, dass alle angenommen haben, dass am Spielende der Eventstrom verschwindet? Dagegen spricht, dass einige Lösungen auch die Aufzeichnung einer Game ID vorgeschlagen haben. Da wurde augenscheinlich größer gedacht.</p><p></p><p></p><p>Oder war die Aufgabe unterspezifiziert insofern, als dass nicht angegeben war, was passieren soll, wenn ein Wurf über die maximale Wurfzahl eines Spiels hinaus gemeldet wird? Damit war sozusagen das Spielende kein Thema in der Aufgabenbeschreibung? Hm…&#x1f914;</p><p></p><p></p><h3>Diskussion</h3><p></p><p></p><p>Was tun mit einem Spektrum an Lösungen? Sind sie alle gleichwertig, gleich gut? Welches Für und Wider gibt es? Genau um diese Erkenntnis ging es mir ja, als ich die Aufgabe gestellt habe.</p><p></p><p></p><p>Augenfällig ist zunächst der Unterschied zwischen den Minimallösungen und den anderen in der Verortung der Logik. Die Minimallösungen brauchen gewiss viel Logik während des Query-Handlings - wie viel sie im Command-Handling tun, ist eine Frage des Anspruchs an Validation/Konsistenzprüfung. Im einfachsten Fall ist dort im Grunde gar keine Logik nötig.</p><p></p><p></p><p>Das Argument der Vertreter dieses Ansatzes ist sehr simpel: „Ein Event reicht.“ Und das ist wahr. Aufzuzeichnen, dass ein Wurf gemacht wurde bedeutet, ein reales Ereignis in der Umwelt aufzuzeichnen. Das wird über ein Kommando gemeldet und ist die einzige Anweisung zur Zustandsänderung. Wenn man sich das merkt, kann der Rest jederzeit daraus abgeleitet werden.</p><p></p><p></p><p>Wenn es so einfach funktioniert, warum sind dann aber 60% der Einreicher auf weitere Events gekommen? Ich denke, das liegt an der Abhängigkeit, die mit der Minimallösung einhergeht: Ein bei der Query nach außen gemeldeter Zustand ist vollständig abhängig von Logik. Ändern sich z.B. die Regeln, können die Ergebnisse alter Spiele u.U. nicht mehr nachvollzogen werden.</p><p></p><p></p><p>Das mag ok sein, wenn eine solche Änderung nicht zu erwarten ist, weil die Domäne sehr stabil ist. Oder es mag ok sein für ein so kleines Beispiel mit angenommener Kurzlebigkeit. Für „richtige“ Software jedoch scheint mir da eine Gefahr fehlender Reproduzierbarkeit zu liegen.</p><p></p><p></p><p>Event Sourcing Lösungen sind mehr von Logik abhängig als Lösungen, die Zustand in einem dauerhaften Modell aktuell halten, weil ständig Projektionen von Events auf temporäre, grundsätzlich flüchtige Modelle stattfinden. Deshalb würde ich mich nicht auf nur den einen minimal notwendigen Event verlassen wollen.</p><p></p><p></p><p>Wie viele Events mehr sollen es dann aber sein?</p><p></p><p></p><p>Events repräsentieren Weggabelungen in der Entwicklung der Welt. Wenn etwas passiert, dann kollabiert ein Möglichkeitsraum; ein Weg ist eingeschlagen worden. Vor dem ersten Wurf ist es noch möglich, dass nach dem Wurf 10, 9, …, 1, 0 Pins abgeräumt sein werden; nach dem Wurf ist klar, dass genau z.B. 4 Pins abgeräumt wurden.</p><p></p><p></p><p>Dasselbe ist der Fall bei Entscheidungen: Sie lassen einen Möglichkeitsraum zusammenschnurren auf genau eine Möglichkeit, nämlich die, für die sich entschieden wurde. Vor einer Entscheidung ist es noch möglich, dass z.B. beim Sturz eines Fußballspielers nach Zusammenstoß mit einem anderen ein Fowl gepfiffen wird oder nicht. Der Schiedsrichter kann sich für oder gegen Fowl entscheiden und er kann sich sogar für ein Fowl mit oder ohne Vorteil entscheiden (wenn ich es recht erinnere). Mit der Entscheidung des Schiedsrichters erst schnurrt der Möglichkeitsraum zusammen auf genau ein Urteil; was passiert ist, ist dann ganz klar z.B. ein Fowl gewesen.</p><p></p><p></p><p>Entscheidungen lassen nichts direkt passieren. Vielmehr deuten sie etwas, das passiert ist - und lassen als Ergebnis wieder etwas passieren. Ein Urteil, eine Entscheidung ist ebenfalls ein Ereignis. Mit jeder Entscheidung verändert sich der Weg eines Systems, d.h. sein Zustand. Wer sich nach links wendet, ist in einem anderen Zustand, als hätte er sich nach rechts gewendet.</p><p></p><p></p><p>Die Aufzeichnung des per Kommando gemeldeten Pins betrifft also quasi ein Ereignis 1. Ordnung, ein unmittelbares Ereignis. Das Programm „erleidet“ dieses Ereignis, es kann nichts dafür.</p><p></p><p></p><p>Die Einreicher von Lösungen oberhalb der Minimallösung haben sich nun überlegt, dass es hilfreich wäre, weitere Ereignisse aufzuzeichnen. Die nenne ich mal Ereignisse 2. und höherer Ordnung. Sie repräsentieren Entscheidungen der Spiellogik.</p><p></p><p></p><p>Bei @sebastian wird nur festgehalten, dass die Logik im Command-Handling erkannt hat, dass ein Wurf als Bonus für einen vorhergehenden Frame zu zählen ist. Das reicht aus, um die Query-Logik drastisch zu vereinfachen.</p><p></p><p></p><p>Die Angriffsfläche von Regeländerungen auf die Berechnung eines Spielergebnisses ist damit deutlich kleiner geworden, würde ich sagen. Es muss zwar immer noch summiert werden, doch das liegt auf der Hand, würde ich sagen. Nur ein Spielende-Ereignis, in dem man das Ergebnis festschreibt, würde noch mehr Robustheit gegenüber Regeländerungen versprechen.</p><p></p><p></p><p>Und was ist mit den darüber hinaus gehenden Events der Lösungen von @phj und @ralfw? Sie dokumentieren auch Entscheidungen; oder ich könnte es auch Erkenntnisse nennen. Die Logik entscheidet, dass mit einem Wurf ein Frame abgeschlossen wurde. Die Logik erkennt den Abschluss eines Frame.</p><p></p><p></p><p>Warum diese Entscheidungen auch noch aufzeichnen? Die Ergebnisberechnung profitiert davon nicht mehr. Vielleicht wird es mit diesen Events aber einfacher, einen Bonuswurf zu erkennen? Das könnte sein. Dann wären es „funktionale“ Events.</p><p></p><p></p><p>Oder dienen sie nur der Dokumentation von Entscheidungen, damit die dauerhaft nachvollziehbar und für zukünftige Nachrichtenbehandlungen nützlich sind? Dann wären es zunächst „dokumentierende“ Events.</p><p></p><p></p><p>@phj hat sein Denken so erklärt:</p><p></p><p></p><blockquote class="wp-block-quote"><p>[M]it nur “roll made” wäre ja nur eine nach events aussehende Fassade vor eine nicht wirklich event-orientierte Lösung gekommen. Das wichtige bei ES ist - und das habe ich versucht damit etwas herauszustellen - dass Logik nur in den Command Handlern, aber nicht in den Projektionen stattfindet. Die Entscheidungen, was ein Frame ist, wann ein Bonus erforderlich wird, etc. mussten damit vor dem Veröffentlichen von Events geschehen, und erfordern daher dann auch spezifische Events.</p></blockquote><p></p><p></p><p>Etwas zugespitzt formuliert ist der für mich wesentliche Punkt: <em>„dass [Entscheidungsl]ogik nur in Command Handlern“</em> steht.</p><p></p><p></p><p>@phj sagt weiter:</p><p></p><p></p><blockquote class="wp-block-quote"><p>dass in den Projektionen keine Entscheidungen […] getroffen werden dürfen, [weil] die eventuell nicht dauerhaft in ihrer Struktur oder Parametrisierung sind. […] Ansonsten würde eine zukünftige Regeländerung zu einer nachträglich anderen Interpretation von bereits durchgeführten Spielen führen. Also müssen die Events die Struktur der Vorbedingungen und der Entscheidungsergebnisse der Geschäftslogik festhalten</p></blockquote><p></p><p></p><p>Das deckt sich mit meinem Verständnis; nicht umsonst sind wir auf sehr ähnliche Lösungen gekommen&#x1f609;</p><p></p><p></p><h2>Ergebnis</h2><p></p><p></p><p>Events zu finden für gegebene Kommandos und Queries lässt Raum für Kreativität. Hier wie auch sonst in der Softwareentwicklung ist eine Balance zwischen dem unzweifelhaft jetzt Erkennbaren und dem möglichen Zukünftigen zu finden. Auch beim Schneiden von Events kann man ansonsten wohl vorzeitig optimieren.</p><p></p><p></p><p>Allerdings scheinen mir lieber mehr als weniger Events tendenziell eine relativ harmlose und billige Optimierung im Hinblick auf zukünftige Nachvollziehbarkeit und Events als Ausgangsmaterial für weitere Nachrichtenverarbeitungen.</p><p></p><p></p><p>Sich beim einmaligen Schreiben etwas mehr Mühe zu geben, erleichtert später das häufige Lesen aus unterschiedlichen Blickwinkeln. Event Sourcing unterscheidet sich da nicht von der Programmierung, würde ich sagen.</p><p></p><p></p><p>Die Kunst des Event Sourcing besteht dann wohl darin, schon aus den Anforderungen die wesentlichen, aufzeichnungswürdigen, zu stabilisierenden Entscheidungen herauszudestillieren.</p><p></p><p></p><p>Zu berücksichtigen sind dabei Kommandos wie Queries. Und was man da an Entscheidungen findet, ist in Events zu gießen, die beim Command-Handling generiert werden.</p><p></p><p></p><p>Dass ein Wurf stattgefunden hat, ist keine Entscheidung innerhalb einer Lösung. Aber wenn die Regeln von Frames sprechen, wenn es besondere Wurf-Kombinationen gibt und Boni zugesprochen werden… dann stecken dahinter Entscheidungen und die lohnen der Aufzeichnung „für die Nachwelt“.</p><p></p><p></p><p>Dazu mag noch kommen, Begriffe der Domäne materialisieren. Wenn in den Regeln „Frame“, „Spare“, „Strike“, „Bonus“ als Begriffe vorkommen, dann liegt es nahe zu erwarten, sie in einem Eventstrom zu finden.</p><p></p><p></p><p>Das sind lohnende Erkenntnisse aus der Übung. Ein schönes Beispiel für <em>deliberate practice</em>. Für mich hat sich die Challenge also gelohnt. Ich bin mir klarer geworden über Prinzipien und Heuristiken des Event Sourcing. Damit werde ich in die nächste Challenge gehen… Stay tuned!&#x1f601;</p><p>Endnoten:</p><p></p><p></p><ol><li id="fn1">Materialismus verstehe ich hier als Haltung, die annimmt, dass es außerhalb von Software eine Realität gibt, die es sich lohnt, 1:1 innerhalb der Software mit stabilen Datenstrukturen abzubilden.<br>Konstruktivismus hingegen macht für mich keine solche Annahme. Er konstruiert nach Bedarf immer wieder neue Repräsentationen aus „rohen Wahrnehmungen“, die nicht mehr und nicht weniger als nützlich sind. Ob sie einer „objektiven Realität“ entsprechen oder nicht, ist ihm einerlei. <a href="#ffn1">&#x21a9;</a></li><li id="fn2">Antifragil ist Software bzw. die Softwareentwicklung für mich, wenn sie Änderungswünsche begrüßt. Dann trägt jede Änderung dazu bei, dass Software besser wird und sogar besser im besser werden. <a href="#ffn2">&#x21a9;</a></li><li id="fn3">Auf eine CRUD-Aufgabe habe ich verzichtet, weil die wohl Naserümpfen bei einigen Event Sourcing Freunden hervorgerufen hätte. Die Meinung, dass Event Sourcing sich nicht für CRUD-Szenarien lohne, hält sich noch. Ich bin allerdings anderer Ansicht. Aber davon ein andermal mehr. <a href="#ffn3">&#x21a9;</a></li><li id="fn4">Und das Ergebnis scheinen mir dann auch oft Domänenevents zu sein, die ich in CQNS <a href="https://ralfw.de/2019/07/command-query-notification-separation-cqns/" target="_blank" rel="noopener">Notifications</a> nenne.<br>Domänenevents sind für mich Nachrichten, die zwischen „Akteuren“ fließen. Das bedeutet nicht, dass sie 1:1 in einem Eventstrom aufgezeichnet werden. <a href="#ffn4">&#x21a9;</a></li><li id="fn5">Nur bei @sebastian gibt es eine Frame-Nummer, die implizit eine relativ leichte Erkennung des Spielendes erlaubt, weil jedes Spiel aus 10 Frames besteht. <a href="#ffn5">&#x21a9;</a></li></ol><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/event-orientation/">Event-Orientation</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/homepage-ralfw-de/magically-predictable-software-production-for-projects/" class="invert post__nav-link" rel="prev"><span>Previous</span> Magically Predictable Software Production for Projects</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="imprint">Imprint</a> - <a href="data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/homepage-ralfw-de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>