<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>IODA Architekturbeispiel im Kleinen - Die Bowling Kata - One Man Think Tank</title><meta name="description" content="Auf der OOP 2016 habe ich einen Vortrag zur IODA Architektur gehalten. Darin taucht ein StÃ¼ck Code als Gegenbeispiel auf, also nicht-IODA Code â€“ und Teilnehmer haben gefragt, wie ich denn meine, dass es nach dem IODA-Ansatz gemacht werden kÃ¶nnte. Auf der OOP war dafÃ¼r&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/ioda-architekturbeispiel-im-kleinen-die-bowling-kata/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/feed.json"><meta property="og:title" content="IODA Architekturbeispiel im Kleinen - Die Bowling Kata"><meta property="og:image" content="https://ralfw.github.io/media/posts/42/Bildschirmfoto-2016-02-05-um-17.08.08.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Auf der OOP 2016 habe ich einen Vortrag zur IODA Architektur gehalten. Darin taucht ein StÃ¼ck Code als Gegenbeispiel auf, also nicht-IODA Code â€“ und Teilnehmer haben gefragt, wie ich denn meine, dass es nach dem IODA-Ansatz gemacht werden kÃ¶nnte. Auf der OOP war dafÃ¼r&hellip;"><meta property="og:url" content="https://ralfw.github.io/ioda-architekturbeispiel-im-kleinen-die-bowling-kata/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="IODA Architekturbeispiel im Kleinen - Die Bowling Kata"><meta name="twitter:description" content="Auf der OOP 2016 habe ich einen Vortrag zur IODA Architektur gehalten. Darin taucht ein StÃ¼ck Code als Gegenbeispiel auf, also nicht-IODA Code â€“ und Teilnehmer haben gefragt, wie ich denn meine, dass es nach dem IODA-Ansatz gemacht werden kÃ¶nnte. Auf der OOP war dafÃ¼r&hellip;"><meta name="twitter:image" content="https://ralfw.github.io/media/posts/42/Bildschirmfoto-2016-02-05-um-17.08.08.png"><link rel="shortcut icon" href="https://ralfw.github.io/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/ioda-architekturbeispiel-im-kleinen-die-bowling-kata/"},"headline":"IODA Architekturbeispiel im Kleinen - Die Bowling Kata","datePublished":"2016-02-04T16:09","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/media/posts/42/Bildschirmfoto-2016-02-05-um-17.08.08.png","height":858,"width":1600},"description":"Auf der OOP 2016 habe ich einen Vortrag zur IODA Architektur gehalten. Darin taucht ein StÃ¼ck Code als Gegenbeispiel auf, also nicht-IODA Code â€“ und Teilnehmer haben gefragt, wie ich denn meine, dass es nach dem IODA-Ansatz gemacht werden kÃ¶nnte. Auf der OOP war dafÃ¼r&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/"><img src="https://ralfw.github.io/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/test-first-codierung/" target="_self">Test-first CodierungğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.github.io/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-DesignğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.github.io/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit SlicingğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.github.io/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.github.io/" target="_self" aria-haspopup="true">BlogsğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/" target="_self">ğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§2015..</a></li><li><a href="https://blog.ralfw.de/" target="_blank">ğŸ‡©ğŸ‡ª2007..2015</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">ğŸ‡¬ğŸ‡§2008..2015</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">ğŸ‡¬ğŸ‡§2003..2010</a></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">ğŸ‡©ğŸ‡ªZur Soziokratie</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">ğŸ‡©ğŸ‡ªGedankliche Umtriebe</a></li><li><a href="https://medium.com/personal-flow" target="_blank">ğŸ‡©ğŸ‡ªPersonal Flow</a></li></ul></li><li class="has-submenu"><a href="https://ralfw.github.io/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/data-privacy-policy/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/media/posts/42/Bildschirmfoto-2016-02-05-um-17.08.08.png" srcset="https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-xs.png 300w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-sm.png 480w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-md.png 768w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-lg.png 1024w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-xl.png 1360w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="858" width="1600" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2016-02-04T16:09">04.02.2016</time></div><h1>IODA Architekturbeispiel im Kleinen - Die Bowling Kata</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Auf der OOP 2016 habe ich einen Vortrag zur <a href="http://blog.ralfw.de/2015/04/die-ioda-architektur.html" target="_blank">IODA Architektur</a> gehalten. Darin taucht ein StÃ¼ck Code als Gegenbeispiel auf, also nicht-IODA Code â€“ und Teilnehmer haben gefragt, wie ich denn meine, dass es nach dem IODA-Ansatz gemacht werden kÃ¶nnte.</p><p>Auf der OOP war dafÃ¼r leider keine Zeit. Doch gleich auf dem RÃ¼ckweg habe ich mich im Zug daran gemacht, die Bowling Kata einmal aus der Sicht von IODA zu lÃ¶sen. Das ist zugegeben ein grenzwertiges Beispiel, weil es nur um einen kleinen Algorithmus geht. Architektur wird darin nicht jeder am Werk sehen. Dennoch lassen sich die Prinzipien hinter IODA natÃ¼rlich auch darauf anwenden. IODA steht ja fÃ¼r eine fraktale Sichtweise auf Software: im Kleinen ist sie strukturiert wie im GroÃŸen.</p><h2>Vorher - Die Bowling Game Kata</h2><p>Der Ausgangscode stammt von Robert C. Martin <a href="http://butunclebob.com/files/downloads/Bowling%20Game%20Kata.ppt" target="_blank">aus seiner Beschreibung der LÃ¶sung (PPT)</a>Â der Bowling Game Kata im Vorgehen nach TDD. Ich habe ihn einfach nur nach C# Ã¼bersetzt:</p><pre class="lang:c# decode:true">public class Game {
	private int[] rolls = new int[21];
	private int currentRoll = 0;

	public void roll(int pins) {
		rolls[currentRoll++] = pins;
	}

	public int score() {
		int score = 0;
		int frameIndex = 0;
		for (int frame = 0; frame &lt; 10; frame++) {
			if (isStrike(frameIndex)) {
				score += 10 + strikeBonus(frameIndex);
				frameIndex++;
			} else if (isSpare(frameIndex)) {
				score += 10 + spareBonus(frameIndex);
				frameIndex += 2;
			} else {
				score += sumOfBallsInFrame(frameIndex);
				frameIndex += 2;
			}
		}
		return score;
	}

	private bool isStrike(int frameIndex) {
		return rolls[frameIndex] == 10;
	}

	private int sumOfBallsInFrame(int frameIndex) {
		return rolls[frameIndex] + rolls[frameIndex+1];
	}

	private int spareBonus(int frameIndex) {
		return rolls[frameIndex+2];
	}

	private int strikeBonus(int frameIndex) {
		return rolls[frameIndex+1] + rolls[frameIndex+2];
	}

	private bool isSpare(int frameIndex) {
		return rolls[frameIndex]+rolls[frameIndex+1] == 10;
	}
}</pre><p>Meine Kritik daran: Die Funktion <em>score()</em> hat nicht nur eine einzige Verantwortlichkeit. Ihr Name klingt fokussiert, doch in Wirklichkeit hat sie zumindest zwei <em>formale</em> Verantwortlichkeiten. Sie stellt Verhalten durch Logik herÂ <strong>und</strong> sie integriert Verhalten anderer Funktionen.</p><p>AuÃŸerdemÂ vermischt sie, wie sich herausstellen wird, in ihrer Logik wiederum zwei inhaltliche Teilverantwortlichkeiten bzw. Aspekte des Scoring.</p><p>Das wiederum ist fÃ¼r mich ein Zeichen fÃ¼r <a href="https://ralfw.de/2015/10/who-do-you-want-to-kiss-about-simplicity-in-coding/">eine bestimmte Form von KISS</a>: Ich sehe darin den Willen zur Einfachheit (simplicity) fÃ¼r den Schreiber; der will schnell einen Test auf grÃ¼n bekommen. Dabei bleibtÂ der Leser jedoch schnell auf der Strecke.</p><h2>Nachher</h2><p>Robert C. Martins "ErzÃ¤hlung" seines Weges zum finalen Code beginnt mit "A quick design session". Darin entwirft er ein Klassenmodell - von dem am Ende jedoch auÃŸer der geforderten KlasseÂ <em>BowlingGame</em> nichts im Code enthalten ist. MerkwÃ¼rdig. Denn er erklÃ¤rt nicht, warum es nicht manifestiert. Deshalb wÃ¼rde ich diese Phase der Entwicklung auch nicht "design session" nennen, sondern lediglich "analysis session". Das Klassenmodell hilft ihm (und den Lesern), das Problem besser zu verstehen. Kein schlechter Ansatz, nur sollte er eben, wie ich finde, einen passenden Namen bekommen, damit die Ãœberraschung am Ende nicht so groÃŸ ist. Auch hier gilt dasÂ <em>Principle of Least Astonishment</em> ;-)</p><p>Und dann macht sich Robert C. Martin auf den Weg... Test fÃ¼r Test schreitet er voran. Schrittweise entsteht dabei Logik inÂ <em>BowlingGame</em>, die jeweils ein bisschen mehr des gewÃ¼nschtenÂ Verhaltens liefert.</p><p>Das fÃ¼hrt zum Ziel. Allerdings ist unklar, ob das so einfach geht, wie es dargestellt ist, oder ob das Vorgehen schon durch hÃ¤ufige PrÃ¤sentation und Kenntnis des Zielzustands stromlinienfÃ¶rmig abgerundet ist.</p><p>In jedem Fall kann ich nicht erkennen, dass Robert C. Martin zu Beginn der Codierung eine Vorstellung von einem LÃ¶sungsansatz hat. Er hat in der "analysis session" VerstÃ¤ndnis erarbeitet. Aber VerstÃ¤ndnis ist keine LÃ¶sung. VerstÃ¤ndnis ist kein Plan und kein Entwurf. Es ist eben keine "design session" gewesen.</p><p>FÃ¼r mich gibt es deshalb eine LÃ¼cke in der Entwicklung. Eine LÃ¼cke, die TDD nicht schlieÃŸt, nicht schlieÃŸen kann. Sie kann nur im Kopf geschlossen werden. Und das zeigt sich im resultierenden Code.</p><p>Wie kÃ¶nnte es anders laufen? Wie kÃ¶nnte hier IODA helfen?</p><p>Hier ist mein Vorschlag:</p><h3>1. Inhaltliche Verantwortlichkeiten trennen</h3><p>Ich wÃ¼rde nicht versuchen, die Logik direkt inÂ <em>score()</em>Â zu implementieren. Insbesondere bei unbekanntem Umfang der Logik wÃ¼rde ich das Gesamtproblem in Teilprobleme zerlegen und Ergebnisse in einem kleinen Prozess herstellen lassen:</p><pre class="lang:c# decode:true">public int score() {
	var frames = Detect_frames (rolls);
	var scores = Score_frames (frames, rolls);
	return scores.Sum ();
}

class Frame {
	public enum KindsOfFrame {
		Regular,
		Spare,
		Strike
	}

	public KindsOfFrame Kind;
	public int RollIndex;
}</pre><p><em>score()</em> hat nun eine einzige Verantwortlichkeit: Integration. In der Funktion werden nur andere Funktionen "zusammengesteckt", um im Sinne einer GesamtlÃ¶sung miteinander zu arbeiten.</p><p>So werden auch zentrale Begriffe der Analyse erhalten:</p><ul><li>In der Aufgabenstellung ist vonÂ <em>frames</em> die Rede, d.h. der Zusammenfassung von WÃ¼rfen. Deren Erkennung ist nun klar herausgestellt, z.B. bei einem Strike enthÃ¤lt ein Frame nur einen Wurf, ansonsten zwei. Die Wichtigkeit der Frames als Gliederungsrahmen fÃ¼r WÃ¼rfe findet zudem Ausdruck in einer eigenen Klasse fÃ¼r sie.</li><li>Die Aufgabenstellung dreht sich umÂ <em>scoring</em>, d.h. die Bewertung einzelner Frames. Das ist unabhÃ¤ngig von den Pins im Frame, z.B. bei einem Strike werden die nÃ¤chsten beiden WÃ¼rfe unabhÃ¤ngig von ihren Frames hinzugerechnet. Deshalb bekommtÂ <em>Score_frames</em><em>()</em> auch sowohlÂ <em>frames</em> wieÂ <em>rolls</em> hineingereicht.</li></ul><p>IndemÂ <em>score()</em> keine Logik enthÃ¤lt, ist die Funktion besser zu verstehen. Sie lesen einfach von oben nach unten, was passiert. AuÃŸerdem muss die GesamtfunktionalitÃ¤t der Funktion nicht mit vielen kleinen Tests ermittelt werden. Um die Korrektheit der GesamtlÃ¶sung festzustellen, ist lediglich ein Integrationstest zu schreiben. Dessen Aufgabe ist es festzustellen, dass die Integration korrekt ist, d.h. die einzelnen Funktionen in passender Weise "zusammengesteckt" sind. Da es sich beiÂ <em>score()</em> auch noch um die Funktion an der Wurzel der LÃ¶sung handelt, ist so ein Integrationstest auÃŸerdemÂ ein Akzeptanztest.</p><h3>2. Ebenen der Abstraktion</h3><p>Auf der obersten Ebene ist fÃ¼r mich damit der LÃ¶sungsansatz gut zu verstehen. Sie bietet einen Ãœberblick Ã¼ber alles. Das Abstraktionsniveau ist einheitlich und hoch.</p><p>Jetzt die nÃ¤chste Abstraktionsebene:</p><pre class="lang:c# decode:true">IEnumerable&lt;Frame&gt; Detect_frames(int[] rolls) {
	const int MAX_FRAMES = 10;

	var fc = new FrameClassifier (rolls);
	return Enumerable.Range (1, MAX_FRAMES)
		         .Select (fc.Classify);
}

IEnumerable&lt;int&gt; Score_frames(IEnumerable&lt;Frame&gt; frames, int[] rolls) {
	return frames.Select (f =&gt; Score_frame(f, rolls));
}</pre><p>Auch hier wieder zwei Integrationsfunktionen; noch keine Logik weit und breit.</p><p><em>Detect_frames()</em> macht hier ganz deutlich, dass ein Spiel aus einer fixen Frame-Anzahl besteht, deren jeder einzelne bestimmt werden muss. Konkret geschieht das durch dieÂ KlasseÂ <em>FrameClassifier</em>. Aber warum so umstÃ¤ndlich? Auch das ist Ausdruck einer Eigenheit der DomÃ¤ne. Die Frames sind nicht gleich groÃŸ. Deshalb muss wÃ¤hrend ihrer Bestimmung Zustand gehalten werden. Das tut Robert C. Martins Code natÃ¼rlich auch. Nur ist dort diese Verantwortlichkeit zu einem Logik-Geflecht mit anderen verwoben.</p><p>Durch die Trennung von Frame-Bestimmung und PunktzÃ¤hlung ist nun auch klar, dass die Anzahl der Frames nur fÃ¼r erstere wichtig ist. Deshalb auch die lokale KonstanteÂ <em>MAX_FRAMES</em>.</p><p><em>Score_frames()</em> zeigt ein Integrationsmuster. Hier von n auf 1 umgesetzt. Dieselbe Funktion soll einfach nur mehrfach ausgefÃ¼hrt werden, um ein Gesamtergebnis - eine Liste von Frame-PunktzahlenÂ - zu ermitteln. StattÂ <em>Score_frame()</em> also wiederholt hinzuschreiben, wird die Funktion mittels Linq auf alle Frames angewandt.</p><p>Wenn man es genau nimmt, geschieht da da etwas in einer Schleife. Ist nicht also Logik im Spiel? Ich behaupte, nein. DennÂ <em>frames</em><em>.Select()</em> ist nur eine generische Form fÃ¼r etwas, das auch speziell hÃ¤tte gebaut werden kÃ¶nnen, z.B.</p><pre class="lang:c# decode:true">return Create_stream_from_frame_list(frames,
           f =&gt; Score_frame(f, roll));</pre><p>Wo ist jetzt die Logik? Versteckt inÂ <em>Create_stream_from_frame_list()</em>. Aber lohnt sich das? Nein. FÃ¼r mich istÂ <em>Score_frames()</em> eine Integration im Sinne von IODA.</p><p>Operationen kommen erst auf der nÃ¤chsten Ebene ins Spiel:</p><pre class="lang:c# decode:true">class FrameClassifier {
	int[] rolls;
	int rollIndex = 0;

	public FrameClassifier(int[] rolls) {
		this.rolls = rolls;
	}

	public Frame Classify(int frameNumber) {
		const int MAX_FRAME_PINS = 10;

		dynamic frame = new Frame{ Kind = Frame.KindsOfFrame.Regular, 
                                           RollIndex = rollIndex};

		if (rolls [rollIndex] == MAX_FRAME_PINS) {
			frame.Kind = Frame.KindsOfFrame.Strike;
			rollIndex += 1;
		}  else {
			if (rolls [rollIndex] + rolls [rollIndex + 1] == MAX_FRAME_PINS)
				frame.Kind = Frame.KindsOfFrame.Spare;
			rollIndex += 2;				
		}  
		return frame;
	}
}


int Score_frame(Frame frame, int[] rolls) {
	switch ((Frame.KindsOfFrame)frame.Kind) {
	case Frame.KindsOfFrame.Strike:
	case Frame.KindsOfFrame.Spare:
		return rolls [frame.RollIndex] + 
                       rolls [frame.RollIndex + 1] + 
                       rolls [frame.RollIndex + 2];
	default:
		return rolls [frame.RollIndex] + 
                       rolls [frame.RollIndex + 1];
	}
}</pre><p><em>Classify()</em>Â macht deutlich, dass normale und Spare-Frames gleich groÃŸ sind. Beide setzen denÂ <em>rollIndex</em> um zwei weiter fÃ¼r den nÃ¤chsten Frame. Und zur Bestimmung der Frame-GrÃ¶ÃŸe wird immer die maximal werfbare Pinzahl herangezogen (<em>MAX_FRAME_PINS</em>).</p><p>DerÂ <em>rollIndex</em>, d.h. der Index des Wurfs, mit dem ein Frame beginnt, ist der im Objekt geschÃ¼tzte Zustand. Wenn die Frame-Bestimmung nicht so einfach ist, sollte das nicht unter den Tisch gekehrt werden. Deshalb eine eigene kleine Klasse dafÃ¼r, auch wenn die nur eine Methode enthÃ¤lt. Sollte sich an der Methode zur Framebestimmung etwas Ã¤ndern, ist nur dort einzugreifen. Das scheint mir sehr im Sinne desÂ <em>Single Responsibility Principle</em> vor.</p><p>Bei Robert C. Martin findet die Berechnung des Gesamtergebnisses verwoben mit der Bestimmung der Frame-Arten statt. Hier ist das jedoch herausgelÃ¶st. Die Frame-Art ist bestimmt.Â <em>Score_frame()</em> konzentriert sich damit nur auf die Bestimmung der Punktzahl fÃ¼r einen Frame je nach Art. Deutlich sichtbar nun: FÃ¼r Strike und Spare werden dieselben WÃ¼rfe herangezogen.</p><p>Das ist natÃ¼rlich wieÂ <em>Classify()</em> pure Logik. Damit ist die Unterste Ebene der IODA Architektur erreicht.</p><figure class="alignnone wp-image-630"><img loading="lazy" src="https://ralfw.github.io/media/posts/42/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549-xs.png 300w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549-sm.png 480w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549-md.png 768w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549-lg.png 1024w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549-xl.png 1360w, https://ralfw.github.io/media/posts/42/responsive/Bildschirmfoto-2016-02-05-um-17.08.08-1024x549-2xl.png 1600w" alt="IODA Architektur" width="730" height="391"></figure><p>Den Code im Ãœberblick finden Sie <a href="https://gist.github.com/ralfw/991b1bf473e178fed6f9" target="_blank">hier</a> in einem Gist.</p><h2>Diskussion</h2><p>Hat es etwas gebracht, den Code in eine IODA Architektur zu Ã¼berfÃ¼hren? Ist er nun besser lesbar, besser wandelbar?</p><p>Beide Frage wÃ¼rde ich ganz klar mit Ja beantworten.</p><p>Die Lesbarkeit steigt aus dreiÂ GrÃ¼nden:</p><ul><li>Die Methoden ohne Logik (Integrationen) zeigen auf einen Blick, "was abgeht", wie der LÃ¶sungsansatz also aussieht. Sie kÃ¶nnen sie von oben nach unten einfach lesen. Sie erzÃ¤hlen quasi eine kleine Geschichte.</li><li>Die Methoden mit Logik sind allesamt sehr Ã¼berschaubar.</li><li>Auch mehrzeilige Logik ist nun sehr fokussiert (single responsibility).</li></ul><p>Die Wandelbarkeit steigt aus zwei GrÃ¼nden:</p><ul><li>Methoden mit und ohne Logik haben fokussiertere Verantwortlichkeiten. Bedeutung ist feingranularer zugewiesen.</li><li>Methoden mit Logik sind nicht mehr funktional abhÃ¤ngig und kÃ¶nnen deshalb leichter getestet werden.</li></ul><p>Aber der Code ist nun umfangreicher, mÃ¶gen Sie einwÃ¤nden. Ist das aber in diesem AusmaÃŸ wirklich schlimm? Etwas bessere Lesbarkeit braucht eben manchmal etwas mehr Text.</p><p>Aber das ist doch jetzt alles vÃ¶llig overengineert, mÃ¶gen Sie dagegen halten. Da stimme ich sogar bis zu einem gewissen Grad zu. Aber es ging ja darum, an einem Ã¼berschaubaren Beispiel fÃ¼hlbar zu machen, was IODA bedeutet.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/tags/ioda-architecture/">IODA Architecture</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fralfw.github.io%2Fioda-architekturbeispiel-im-kleinen-die-bowling-kata%2F" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Fralfw.github.io%2Fioda-architekturbeispiel-im-kleinen-die-bowling-kata%2F&amp;via=ralfw&amp;text=IODA%20Architekturbeispiel%20im%20Kleinen%20-%20Die%20Bowling%20Kata" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="http://www.linkedin.com/shareArticle?url=https%3A%2F%2Fralfw.github.io%2Fioda-architekturbeispiel-im-kleinen-die-bowling-kata%2F&amp;title=IODA%20Architekturbeispiel%20im%20Kleinen%20-%20Die%20Bowling%20Kata" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/planvoll-in-den-graben/" class="invert post__nav-link" rel="prev"><span>Previous</span> Planvoll in den Graben</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/raus-aus-dem-geschwindigkeitsrausch/" class="invert post__nav-link" rel="next"><span>Next</span> Raus aus dem Geschwindigkeitsrausch </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>