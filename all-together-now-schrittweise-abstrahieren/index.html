<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>All together now - Schrittweise abstrahieren - One Man Think Tank</title><meta name="description" content="Aggregation, Destillation und Integration sind alle wertvoll f√ºr die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tats√§chlich alle Abstraktionsarten benutzt werden und zwar in einer m√∂glichst hilfreichen&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/feed.json"><meta property="og:title" content="All together now - Schrittweise abstrahieren"><meta property="og:image" content="https://ralfw.github.io/media/posts/100/1522317916.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Aggregation, Destillation und Integration sind alle wertvoll f√ºr die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tats√§chlich alle Abstraktionsarten benutzt werden und zwar in einer m√∂glichst hilfreichen&hellip;"><meta property="og:url" content="https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="All together now - Schrittweise abstrahieren"><meta name="twitter:description" content="Aggregation, Destillation und Integration sind alle wertvoll f√ºr die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tats√§chlich alle Abstraktionsarten benutzt werden und zwar in einer m√∂glichst hilfreichen&hellip;"><meta name="twitter:image" content="https://ralfw.github.io/media/posts/100/1522317916.png"><link rel="shortcut icon" href="https://ralfw.github.io/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/"},"headline":"All together now - Schrittweise abstrahieren","datePublished":"2018-04-05T11:33","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/media/posts/100/1522317916.png","height":704,"width":1682},"description":"Aggregation, Destillation und Integration sind alle wertvoll f√ºr die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tats√§chlich alle Abstraktionsarten benutzt werden und zwar in einer m√∂glichst hilfreichen&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/"><img src="https://ralfw.github.io/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/test-first-codierung/" target="_self">Test-first Codierungüá©üá™</a></li><li><a href="https://ralfw.github.io/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Designüá©üá™</a></li><li><a href="https://ralfw.github.io/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicingüá©üá™</a></li></ul></li><li><a href="https://ralfw.github.io/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.github.io/" target="_self" aria-haspopup="true">Blogs</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/" target="_self">üá©üá™/üá¨üáß</a></li><li><a href="https://blog.ralfw.de/" target="_blank">üá©üá™2010..2015</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">üá¨üáß2010..2015</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">üá¨üáß&lt;&#x3D;2010</a></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">Zur Soziokratieüá©üá™</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">Gedankliche Umtriebeüá©üá™ (medium)</a></li><li><a href="https://medium.com/personal-flow" target="_blank">Personal Flowüá©üá™ (medium)</a></li></ul></li><li class="has-submenu"><a href="https://ralfw.github.io/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/data-privacy-policy/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/media/posts/100/1522317916.png" srcset="https://ralfw.github.io/media/posts/100/responsive/1522317916-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/1522317916-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/1522317916-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/1522317916-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/1522317916-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/1522317916-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="704" width="1682" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2018-04-05T11:33">05.04.2018</time></div><h1>All together now - Schrittweise abstrahieren</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Aggregation, Destillation und Integration sind alle wertvoll f√ºr die Softwareentwicklung. Es ging mir <a href="https://ralfw.de/2018/03/bequeme-abstraktion-ganz-konkret/">bei der Differenzierung im vorherigen Artikel</a> also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tats√§chlich alle Abstraktionsarten benutzt werden und zwar in einer m√∂glichst hilfreichen Weise.</p><p>Aus dem Gesagten sollte klar geworden sein, dass das nicht der Fall ist, solange erstens die Integration keinen gleichberechtigten Platz neben Aggregation und Destillation bekommt. Und zweitens geh√∂rt die Integration an den Anfang der Softwareentwicklung - nicht weil sie ‚Äûbesser‚Äú oder ‚Äûwichtiger‚Äú w√§re, sondern weil schlicht nur f√ºr sie am Anfang √ºberhaupt Material vorhanden ist.</p><p>Wer Softwareentwicklung startet mit der Suche nach Aggregaten oder gar Destillaten, arbeitet mit leeren H√§nden. Es fehlt eine Grundmenge, aus der in dieser Weise abstrahiert werden k√∂nnte. Das Ergebnis: vorzeitige Abstraktion als Spezialfall der vorzeitigen Optimierung.</p><blockquote><p>‚Äû[P]remature optimization is the root of all evil.‚Äú, Donald Knuth</p></blockquote><p>Klassen und Interfaces am Anfang der Softwareentwicklung halte ich aus diesem Grund f√ºr einen Irrweg. Mit ihnen zu beginnen bedeutet, sich der Spekulation hinzugeben und stellt eine Einladung an die Verkrustung dar.</p><p>An einem Beispiel m√∂chte ich meine Sichtweise nun konkret erkl√§ren. Ausgangspunkt sind folgenden Anforderungen. Sie sind notwendig sehr einfach, doch das tut dem Thema keinen Abbruch. Bei umfangreicheren Anforderungen kann es nur umso wichtiger sein, sauber mit Abstraktionen umzugehen.</p><blockquote><p>Entwickle eine Anwendung, die die durchschnittliche Anzahl der Worte ab 3 Zeichen L√§nge pro Zeile in einer Textdatei bestimmt. Worte sind dabei Ketten von non-whitespace Zeichen und ohne √ºbliche Sonderzeichen. Die Textdatei wird der Anwendung bei Start auf der Kommandozeile mitgeteilt.</p></blockquote><p>Was w√ºrde die gemeine Objektorientierung hier jetzt f√ºr Abstraktionen entdecken? Ich habe diese Art der Spekulation inzwischen verloren. Deshalb will ich mich daran gar nicht mehr versuchen.</p><h2>Anwendungen als Integrationen von Logik</h2><p>Es sollte offensichtlich sein, dass Anwendungen selbst Abstraktionen sind. Sie stellen Integrationen dar. In ihnen sind komplement√§re Funktionalit√§ten zu einem Ganzen verdrahtet, das dem Benutzer das Leben einfacher macht. In diesem Fall muss er sich nicht mit den Details der Textbeschaffung, Wortbestimmung und Wortz√§hlung sowie Durchschnittsberechnung befassen. Software ist insofern ein Werkzeug wie eine Waschmaschine oder ein Rasenm√§her, das sich √ºber eine Benutzerschnittstelle bedienen l√§sst.</p><p>F√ºr eine Integration stellt sich die Frage, welche Teile von ihr zusammengefasst werden. Darauf gibt es zwei Antworten. Die triviale lautet: Anwendungen integrieren viele verschiedene Logik-Anweisungen. Ein Beispiel:</p><figure class="alignnone size-large wp-image-1462"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-2xl.png 1600w" alt="" width="720" height="251"></figure><p>Die entscheidenden Zeilen sind die von 12 bis 24. Sie enthalten die Logik, die das gew√ºnschte Verhalten herstellt. Die Anwendung abstrahiert von diesen Details indem sie das Verhalten √ºber <code>textstats.exe</code> als Ganzes zug√§nglich macht.</p><p>Dass hier eine Funktion <code>Main()</code> n√∂tig wird (die sogar noch einer Klasse zugeordnet sein muss), ist eine vernachl√§ssigbare Eigenheit der Sprache C#. Eigentlich geht es nur um die Logikanweisungen, die durch den Compiler zu einer ausf√ºhrbaren Einheit √ºbersetzt werden.</p><p>Software <em>ist</em> eine Abstraktion, die zun√§chst keine weiteren Abstraktionen braucht. Die Bausteine, die sie integriert, sind die Logik-Anweisungen einer Programmiersprache.</p><p>So einfach k√∂nnte es sein mit der Abstraktion in der Softwareentwicklung ‚Äì w√§re da nicht eine klitzekleine Schwierigkeit: Logik als Bausteine von Anwendungen l√§sst sich nur sehr schwer bestimmen.</p><p>F√ºr das obige Problem m√∂gen Sie es einfach finden, die passenden Anweisungen zu finden. Doch schon wenn die Anforderungen etwas umfangreicher und/oder komplizierter werden, ist es damit vorbei.</p><p>Wir werden der Logik innerhalb einer Anwendung schlicht nicht Herr ohne weitere Abstraktionen. Software muss deshalb weitere <em>in sich haben</em>. Eine Anwendung muss abstraktere Bausteine integrieren als Logik-Anweisungen.</p><h2>Anwendungen als Integrationen von Funktionen</h2><p>Die erste Abstraktion <em>innerhalb</em> von Software sind nicht Klassen, wie es die Objektorientierung gern h√§tte, sondern Funktionen. Wenn die Logik schwer handhabbar wird, dann bekommt man sie nicht mit Aggregaten in den Griff, sondern mit weiterer Integration.</p><p>Daf√ºr gibt es drei Gr√ºnde: Zum einen bietet die reine Logik keinen Stoff, aus dem Aggregate abstrahiert werden k√∂nnten. Aggregate, d.h. Module, fassen Funktionen (oder andere Module) zusammen. Reine Logik ist jedoch unstrukturiert, es gibt darin keine Funktionen.</p><p>Zum anderen haben Aggregationen eher keinen Wert f√ºr den Kunden. Sie machen die Entwicklung nicht sp√ºrbar produktiver; sie erzeugen keine Bequemlichkeit f√ºr die Entwicklung.</p><p>Und schlie√ülich stellt Logik ganz nat√ºrlich den Baustoff f√ºr Funktionen dar. In einer Menge von Logik-Anweisungen die zu finden, die in ihrer Verschiedenheit und Komplementarit√§t zu einem Ganzen integriert werden k√∂nnen, ist einfach. Logik hat f√ºr einzelne Funktionen die passende Granularit√§t als Baustein.</p><figure class="alignnone size-large wp-image-1463"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-2xl.png 1600w" alt="" width="720" height="525"></figure><p>Als Ergebnis entstehen Funktionen, die ausschlie√ülich Logik enthalten; ich nenne sie <em>Operationen</em>.</p><p>Anwendungen werden dadurch zu einer integrierenden Abstraktion mit zwei Ebenen (<em>strata</em>). Auf der obersten Ebene ist weiterhin die Anwendung (hier repr√§sentiert durch <code>Main()</code>). Die integriert jedoch nicht mehr feingranulare Logik, sondern Operationen mit einer gr√∂beren Granularit√§t. Und diese Funktionen wiederum integrieren Logik.</p><h2>Funktionen als Integrationen von Funktionen</h2><p>Sie sehen: aus Logik, die unzweifelhaft zur L√∂sung des Problems des Anwenders n√∂tig ist, ergeben sich ganz nat√ºrlich Abstraktionen. Aber nicht, wie es die Objektorientierung denkt, Aggregationen, sondern Integrationen. Sie stellen vereinfachende Zusammenfassungen von Teilfunktionalit√§t dar, die sich der Verwendung in unterschiedlichen Zusammenh√§ngen anbieten - und zudem die Logik besser verst√§ndlich macht, weil sie sie mit Bedeutung aufl√§dt. Funktionsnamen sind abstrakte Platzhalter f√ºr Details. √úber die Signatur einer Funktion lassen sich diese Details bequem bedienen. Das schafft Produktivit√§t.</p><p>F√ºr mich ist das ein Abstraktionsrezept, das der Fortsetzung lohnt. Warum bei Operationen als Integrationen stehenbleiben? <code>Main()</code> zeigt ja schon, dass sich nicht nur Logik integrieren l√§sst. Funktionen sind wunderbare Integrationsbausteine.</p><p>Wenn auf unterster Ebene Logik-Anweisungen integriert werden zu Operationen, dann k√∂nnen auf dar√ºber liegenden Ebenen Funktionen ebenfalls integriert werden. Funktionen, die Funktionen integrieren, nenne ich <em>Integrationen</em>.</p><p>Angewandt auf den bisherigen Code kann das z.B. so aussehen. Die gr√ºnen Funktionen sind Integrationen, die roten Operationen.</p><figure class="alignnone size-full wp-image-1464"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.03.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-2xl.png 1600w" alt="" width="928" height="916"></figure><p><code>Main()</code> als Repr√§sentation der Anwendung ist jetzt eine sehr einfache Integration geworden. In drei Zeilen ist dort ausgedr√ºckt, was vorher 13 Zeilen gebraucht hat. Aber auch <code>LoadData()</code> und <code>ExtractRelevantWordsFromLines()</code> stellen bequeme Integrationen dar. Und wenn sich irgendwo Funktionen zeigen, die zusammen wiederum eine n√ºtzliche (oder auch nur gut verst√§ndliche) Integration ergeben, dann k√∂nnen sie sehr leicht zusammengefasst werden, z.B.</p><figure class="alignnone size-large wp-image-1465"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-2xl.png 1600w" alt="" width="720" height="172"></figure><p>Wichtig ist es, bei der Integration darauf zu achten, dass die Granularit√§t der Bausteine angemessen ist. Funktionen und Logik in einer Integration zu mischen, passt nicht. Nur wenn integrierende Funktionen keine Logik enthalten, bleibt die Testbarkeit von Code hoch. Logik ist dann ausschlie√ülich in Operationen versammelt, die nicht weiter funktional abh√§ngig sind - und insofern leicht zu testen. Wenn Funktionen so strukturiert sind, dann folgen sie f√ºr mich dem <em>Integration Operation Segregation Principle (IOSP)</em>.</p><h2>Klassen als Aggregationen von Funktionen</h2><p>Integration ist f√ºr mich die initiale und sogar prim√§re Abstraktion in der Softwareentwicklung. Durch Integration entstehen Funktionseinheiten, die mehr und mehr Verhalten b√ºndeln und bequem verf√ºgbar machen. Details der Herstellung von Verhalten werden verborgen. Integrationen bieten quasi ‚ÄûVerhalten auf Knopfdruck‚Äú.</p><p>Doch so produktivit√§tssteigernd Integration ist, fr√ºher oder sp√§ter braucht es eine weitere Art der Abstraktion. Zur Beherrschung von wachsenden Mengen an Bausteinen ist Aggregation n√∂tig, sonst verlieren wir die √úbersicht.</p><p>Das ist schon der Fall im obigen Beispiel, w√ºrde ich sagen. Neun Funktionen ‚Äûin einer Reihe‚Äú sind nicht mehr gut zu √ºberblicken, allemal, wenn sie nicht alle gleichzeitig auf den Bildschirm passen.</p><p>Als physische Aggregation w√ºrde sich zur Herstellung von √úbersichtlichtkeit eine Verteilung der Funktionen auf Dateien anbieten. Dadurch w√ºrden Funktionen Kategorien zugewiesen, die durch Dateinamen bezeichnet sind.</p><p>Leider lassen das jedoch nicht alle Programmiersprachen zu. In Java und C# ist eine solche Verteilung z.B. nur m√∂glich, wenn Funktionen als Methoden in Klassen zusammengefasst sind. Deshalb lasse ich im Weiteren Dateien als Abstraktionsmittel au√üen vor und konzentriere mich auf Klassen (bzw. allgemeiner Module).</p><p>Aggregationen abstrahieren von Unterschieden, indem sie das existierende Gemeinsame hervorheben. Inwiefern haben also die Funktionen im Beispiel etwas gemeinsam, inwiefern unterscheiden sie sich andererseits?</p><p>Ich finde f√ºr neun Funktionen zun√§chst f√ºnf Aggregate, d.h. Klassen:</p><figure class="alignnone size-large wp-image-1477"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-2xl.png 1600w" alt="" width="720" height="318"></figure><p>Meine Kriterien f√ºr die Zusammenfassung in einer Klasse einerseits und die Verteilung auf verschiedene Klassen andererseits, will ich hier dahingestellt lassen. Ich habe mich leiten lassen von einem Architekturmuster, das ich [IODA Architektur] nenne.</p><p>Wichtiger als die genauen Kriterien ist mir an dieser Stelle, dass es √ºberhaupt welche gibt. Wer auf die Funktionen blickt, wird durch seine Brille bei manchen irgendwelche Gemeinsamenkeiten finden und bei anderen keine. Manche Funktionen sind durch eine koh√§sive Kraft miteinander verbunden, andere nicht. Und das wird durch die Aggregation in einer Klasse formal hervorgehoben.</p><p>Wie die Klassen auf Dateien verteilt und diese in Verzeichnissen zusammengefasst sind, ist dann eine zweite Sache. Damit kann die Aggregation noch physisch unterstrichen werden.</p><figure class="alignnone size-full wp-image-1468"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.35.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-2xl.png 1600w" alt="" width="396" height="436"></figure><h2>Klassen als Aggregationen von Integrationen</h2><p>Zun√§chst sind Klassen nur Aggregationen. Sie fassen verschiedene Funktionen auf der Basis von etwas Gemeinsamem in einer programmiersprachlich relevanten Weise zusammen. Sie geben dieser Zusammenfassung einen Namen, eine Bedeutung. Sie spannen einen Namensraum auf.</p><figure class="alignnone size-large wp-image-1469"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-2xl.png 1600w" alt="" width="720" height="143"></figure><p>Was in Klassen aggregiert ist, steht ohne weiteren Zusatz gleichberechtigt nebeneinander. Es stellt allerdings eine √ºberschaubarere Menge dar als das, was vorher ohne Klassen auf einem Haufen lag.</p><p>Spannend wird es, wenn das Gemeinsame einer Anzahl von Funktionen ist, dass sie einer Integrationshierarchie angeh√∂ren. In dem Fall helfen Klassen durch Sichtbarkeitsattribute, diesen Umstand zu verschleiern. Sie k√∂nnen also helfen, Integrationen ‚Äûauf den Punkt zu bringen‚Äú, indem sie lediglich die Wurzel eines Integrationsbaumes zug√§nglich machen - und alle darunter h√§ngenden Bausteine verbergen.</p><figure class="alignnone size-large wp-image-1470"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-2xl.png 1600w" alt="" width="720" height="257"></figure><p>Im Fall der Klasse <code>Parser{}</code> ist nur die Integrationswurzel √∂ffentlich, alle anderen Funktionen sind unsichtbare Details der Leistungserbringung der Integration. Ob diese Wurzelfunktion eine Operation ist oder eine Integration? Das kann man ihr und der Klasse als Nutzer von au√üen nicht ansehen.</p><p>In dieser Hinsicht unterscheiden sich Klassen ganz wesentlich von syntaktischen Namensr√§umen und physischen Aggregationen. Klassen helfen hier der Integration, allerdings sind sie deshalb nicht selbst Integrationen. Sie bleiben lediglich Aggregationen.</p><h2>Anwendungen als Aggregationen von Klassen</h2><p>Logik-Anweisungen sind Elemente, die in Funktionen integriert werden. Funktionen sind Elemente, die von anderen Funktionen integriert werden oder von Klassen aggregiert.</p><p>Klassen sind nun Elemente, die von Anwendungen aggregiert werden. Zun√§chst sind Anwendungen - oder allgemeiner: Bibliotheken - nur Sammlungen von Klassen, die etwas gemeinsam haben. Sie alle leisten etwas, das der Erf√ºllung der Anforderungen des Kunden dient. F√ºnf Klassen sind im obigen Bild in den Topf der Anwendung geworfen und mit dem Etikett <code>textstats.exe</code> versehen worden.</p><p>Darin besteht die erste Kunst der gemeinen Objektorientierung. Ihr Ziel ist es, die Klassen zu finden, f√ºr die die zu realisierende Anwendung das Aggregat ist. Sie geht also von der Abstraktion aus und sucht zugeh√∂rige Elemente.</p><p>Der Ansatz, den ich hier beschreibe, beginnt am anderen Ende. In ihm stehen Klassen nicht am Anfang. Weder sieht er die Anwendung als Aggregat noch sucht er nach Aggregaten. Stattdessen ist die Anwendung vor allem ein Ort der Integration. Aggregate m√∂gen sp√§ter kommen, wenn genug Material daf√ºr angeh√§uft ist. Klassen ergeben sich, wenn klar ist, wie das gew√ºnschte Verhalten mittels Logik, Operationen und Integrationen hergestellt werden kann.</p><h2>Klassen als Integrationen von Klassen</h2><p>Bibliotheken m√∂gen als reine Aggregate von Klassen durchgehen; Anwendungen jedoch integrieren immer. Deshalb liegt es nahe, dass es in Anwendungen auch Klassen gibt, die integrieren.</p><p>Integrierende Klassen sind Klassen, die andere, komplement√§re zusammenziehen zu etwas Neuem, zu etwas Gr√∂√üerem, zu etwas Bequemerem. Das zeigt das folgende Listing exemplarisch anhand der neuen Klasse <code>App{}</code>:</p><figure class="alignnone size-large wp-image-1471"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-2xl.png 1600w" alt="" width="720" height="456"></figure><p>Die Aufgabe von <code>App{}</code> ist es, die Leistungen anderer Klassen zu b√ºndeln. Sie enth√§lt deshalb in diesem Beispiel selbst auch keine Logik. Das ist zwar nicht Voraussetzung f√ºr eine integrierende Klasse, unterstreicht ihre Aufgabe jedoch.</p><p>Die Verantwortlichkeit von <code>Program{}</code> reduziert sich damit darauf, den Eintrittspunkt f√ºr die Anwendung zu definieren und alles herzurichten, damit das in <code>App{}</code> integrierte Gesamtverhalten abl√§uft.</p><p>Die integrierende Klasse steht hier an der Spitze und zieht die ansonsten nur aggregierten weiteren Klassen der Anwendung zusammen. Integrationen mit Klassen k√∂nnen aber nat√ºrlich auch an anderer Stelle stattfinden. Ist das sauber gemacht, bergen sie viel Potenzial f√ºr eine Produktivit√§tssteigerung.</p><h2>Interfaces als Destillate von Klassen</h2><p>Aggregate treten f√ºr mich erst nach Integrationen auf die B√ºhne der Softwareentwicklung. Und Destillate kommen sogar noch sp√§ter. Der Grund: F√ºr Destillate braucht es noch mehr Material, damit sich darin √ºberhaupt eine destillierbare Essenz anreichern kann.</p><p>Das ist in einer Anwendung der Fall, wenn sich einige Klassen stabilisiert haben und darin destillierbare Muster zu finden sind. Oder das ist der Fall, wenn √ºber Anwendungen hinweg Muster erkennbar sind.</p><p>Innerhalb von Anwendungen k√∂nnen Destillate dann Grundfunktionalit√§t (oder Grundstruktur) bereitstellen in Form von Basisklassen, die von Ableitungen moduliert werden. Oder Destillate beschreiben abstrakt Funktionalit√§t, die am Nutzungsort in verschiedener Weise konkretisiert werden kann.</p><p>Ein Freund von Destillaten in Form von Basisklassen bin ich nicht. Vererbung verwende ich nur in sehr wenigen und sehr klaren F√§llen der N√ºtzlichkeit und dann vor allem im Zusammenhang mit Datenstrukturen. Stattdessen favorisiere ich die Komposition (<em>Favor Composition over Inheritance, FCoI</em>), also die Integration, um auf vorhandener Funktionalit√§t aufzubauen.</p><p>Interfaces als Form-Destillate finde ich jedoch n√ºtzlich, insbesondere, um die Testbarkeit von Code zu erh√∂hen. Davon kann im Beispiel die Klasse <code>App{}</code> profitieren. Sie ist die Integrationswurzel f√ºr das gesamte Verhalten der Anwendung. Ein automatisierter Akzeptanztest w√§re hier also angezeigt. Doch die Abh√§ngigkeit insbesondere von der Ressource Standard-Output macht das schwierig. Es w√§re sch√∂n, Ressourcen f√ºr einen Test ‚Äûabklemmen‚Äú zu k√∂nnen.</p><p>Mit <em>Dependency Inversion (DI)</em> und <em>Inversion of Control (IoC)</em> ist das ohne technologische Klimmz√ºge m√∂glich. Statt <code>App{}</code> direkt von Ressourcen kapselnden Aggregaten abh√§ngig zu machen, schiebe ich ihr Form-Destillate unter und injiziere Konkretisierungen zur Laufzeit.</p><p>Das ist f√ºr mich ein Muster √ºber Anwendungen hinweg:</p><ul><li>Ressourcenzugriffe machen das automatisierte Testen immer wieder schwierig. Also werden sie in Klassen aggregiert und dann destilliert (DI).</li></ul><figure class="alignnone size-large wp-image-1472"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-2xl.png 1600w" alt="" width="720" height="206"></figure><ul><li>Destillate werden zur Laufzeit durch Produktionsobjekte bzw. Testattrappen konkretisiert.</li></ul><figure class="alignnone size-large wp-image-1473"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-2xl.png 1600w" alt="" width="720" height="245"></figure><p>Der Preis, den der Mehraufwand f√ºr DI und IoC und die steigende Komplexit√§t darstellt, halte ich f√ºr klein im Vergleich zum Gewinn. In Ma√üen eingesetzt ist eine solche Suboptimalit√§t n√ºtzlich, um das Ganze deutlich zu verbessern im Hinblick auf nachweisbare Korrektheit.</p><p>Aber Vorsicht! Lassen Sie sich nicht davontragen von der Verlockung solcher Art Flexibilit√§t. W√ºrde dadurch nicht Software ganz allgemein viel wandelbarer? Das halte ich f√ºr einen Trugschluss, der leider in Robert C. Martins <em>Clean Architecture</em> einen popul√§ren Ausdruck gewonnen hat. Die √úbersichtlichkeit der Beziehungen zwischen Abstraktionen steigt durch DI und IoC nicht. Selbst Martin muss bei Anblick eines ‚ÄûKomponentendiagramms‚Äú f√ºr ein Beispiel in seinem Buch konstatieren:</p><blockquote><p>‚ÄûMuch of the complexity [‚Ä¶] was intended to make sure that the dependencies between the components pointed in the correct direction.‚Äú</p></blockquote><p>Komplexit√§t ist der Feind von Korrektheit und Wandelbarkeit. Auch mit allerbester Absicht sollten komplexit√§tserh√∂hende Ma√ünahmen wie DI und IoC daher nur sehr sparsam eingesetzt werden.</p><p>Das ist auch der Grund, warum Sie im hier vorgestellten Code √ºber eine lange Strecke nur statische Methoden gesehen haben. Ich halte sie schlicht f√ºr besser testbar und leichter verst√§ndlich. Statische Methoden legen einfach nahe, keine Abh√§ngigkeiten von Zustand oder Ressourcen einzugehen. Sie sind f√ºr mich deshalb der default ‚Äì und erst wenn ich deutliche Hinweise habe, dass Daten aggregiert werden sollten oder ein Form-Destillat hilfreich w√§re, r√ºcke ich davon ab.</p><h2>Klassen als Aggregationen von Daten</h2><p>Bisher war nur von der Abstraktion rund um Logik die Rede. Klassen integrieren Klassen, die Funktionen aggregieren, die Funktionen integrieren, die Logik integrieren. Und was ist mit den Daten?</p><p>Mein Blick war bisher vor allem auf Logik und Funktionen gerichtet, weil ich glaube, dass wir Software von ihrem Verhalten her denken sollten. ‚ÄûWas soll Software <em>tun</em>?‚Äú ist die zentrale Frage. Welche Funktionalit√§t und welche Effizienz soll sie haben? Daf√ºr m√ºssen wir Logik finden und zu Funktionen abstrahieren und die dann weiter zu Klassen abstrahieren.</p><p>Daten sind zwar die andere Seite der Softwaremedaille und insofern auf Augenh√∂he mit Verhalten, doch sie stehen f√ºr mich nicht am Anfang von Analyse und Entwurf, jedenfalls nicht jenseits des Offensichtlichen. Ich glaube nicht, dass wir uns einen Gefallen tun, wenn wir auf Anforderungen wie Tr√ºffelschweine losgehen und Datenzusammenh√§nge ausschn√ºffeln. Daten folgen Verhalten selbstverst√§ndlich und in bek√∂mmlichem Ma√üe, eben so, wie sie gebraucht werden.</p><p>Am Ende gilt es dann aber nat√ºrlich auch, f√ºr Daten Abstraktionen zu finden. Welche Daten haben etwas gemeinsam und sollten in einer Klasse aggregiert werden?</p><p>Das Beispiel gibt in dieser Hinsicht leider nicht so viel her. Dennoch habe ich versucht, ein bisschen Datenabstraktion zu betreiben. Herausgekommen sind diese beiden Klassen, die ich dann auch physisch im Projekt separiert habe:</p><figure class="alignnone size-large wp-image-1474"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-2xl.png 1600w" alt="" width="720" height="320"></figure><p>Das hat vor allem zu einem Umbau am <code>Parser{}</code> gef√ºhrt:</p><figure class="alignnone size-large wp-image-1475"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-2xl.png 1600w" alt="" width="720" height="181"></figure><p>Dessen Verantwortlichkeit ist geschrumpft - oder besser: fokussiert. Seine Aufgabe besteht nun einzig darin, einen Text in Zeilen und Worte zu zerlegen. Die entstehenden Daten liefert er nicht mehr in generischer, offener Form als <code>IEnumerable&lt;string[]&gt;</code>, sondern in einer speziellen Datenstruktur <code>Text{}</code>, die aus <code>Line{}</code>-Objekten besteht, die wiederum Worte enthalten.</p><h2>Klassen als Integrationen von Daten</h2><p>Durch die Aggregation sind Daten klar mit Bedeutung aufgeladen und k√∂nnen nun auch passende Funktionalit√§t beigeordnet bekommen. Was vorher der Parser geleistet hat, ist zum Teil in die Datenobjekte gewandert. Die operieren damit auf sich selbst und machen es Nutzern bequemer. Davon profitiert die Dom√§nenlogik in <code>Stats{}</code>:</p><figure class="alignnone size-large wp-image-1476"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-2xl.png 1600w" alt="" width="720" height="174"></figure><p>Die w√ºnscht sich nun einfach etwas von einem <code>Text{}</code>, statt die Daten selbst zu analysieren. Eine Anwendung des <em>Tell, don‚Äôt ask (TDA)</em> Prinzips. Bei umfangreicheren Datenstrukturen ist damit nat√ºrlich mehr zu gewinnen: Konsistenzpr√ºfungen und Navigation in Daten sind Funktionalit√§ten, die sich sehr gut eignen, um mit Daten in einer Klasse verbunden zu werden. Das ist Abstraktion durch Integration, weil eine Einheit entsteht, bei der nicht jeder Nutzer immer wieder alle Feinheiten der richtigen Bedienung beachten muss.</p><p>Das ist eine so typische Situation in der Objektorientierung, dass Sie ausrufen m√∂gen, Integration stehe doch im Vordergrund der gemeinen Objektorientierung. Ich hatte ja etwas anderes behauptet in meinem vorhergehenden Artikel.</p><p>Doch ich bleibe dabei: Dass Funktionen mit Daten in Klassen geb√ºndelt werden k√∂nnen, ist noch kein Zeichen f√ºr integrierendes Denken. Es kommt darauf an, warum und wie man es macht. Schon wenn die Unterscheidung zwischen Klassen, die Daten <em>sind</em>, und Klassen, die Daten <em>haben</em>, nicht getroffen wird, fehlt es an Differenzierung.</p><p><code>Text{}</code> und <code>Line{}</code> sind ganz bewusst als Klassen ausgelegt, die Daten <em>sind</em>, d.h. ihr Zweck ist es, Daten zu aggregieren und ggf. sogar zu integrieren. Die Daten sind nicht dort, weil sie eine Gemeinsamkeit von Funktionen darstellen; sie sind kein zu verbergender Zustand. Deshalb k√∂nnen sie auch offenliegen. Eine Datenstruktur verbirgt ihre Struktur nicht. Sie zu kapseln w√§re wider ihren Zweck.</p><p>Deshalb darf der Zweck einer Datenstruktur auch nicht √ºberladen werden mit Funktionalit√§t. Er muss fokussiert bleiben auf das Strukturieren von Daten. Funktionen sind hier sekund√§r und helfen lediglich der Strukturierung.</p><p>Anders bei Klassen, die Daten <em>haben</em>. Bei ihnen stehen die Funktionen im Vordergrund. Daten bilden zwischen ihnen ein Bindeglied; sie sind quasi notwendiges √úbel, weil sie die Testbarkeit der Methoden herabsetzen.</p><p>In Bezug auf diese Daten sind Klassen lediglich Aggregationen. Ihre eigentliche Funktion: die Aggregation von Funktionen, die Integrationen sind. Solche Klassen sollten keine Daten ver√∂ffentlichen. Die sind lediglich gemeinsame Details der aggregierten Funktionen.</p><p>Sie sehen, Klassen als Integrationen sind kein Selbstg√§nger. Deshalb glaube ich, dass mehr Differenzierung bei den Abstraktionsarten n√∂tig ist.</p><h2>Anwendungen als Aggregationen von Funktionen</h2><p>Zum Schluss noch einmal zur√ºck zu ganzen Anwendungen. Die sind doch nicht nur Integrationen von Logik und Funktionen, sondern auch Aggregationen.</p><p>Anwendungen bieten ihrer Umwelt eine Reihe von zusammengeh√∂rigen Funktionen an, die auf die eine oder andere Weise getriggert werden k√∂nnen. Dann verh√§lt sich die Software, indem sie Input in Output transformiert.</p><p>Im Beispiel ist das leider nicht gut erkennbar. Dort gibt es nur eine triggerbare Funktion: <code>App.Run()</code>. Vom Windows Taschenrechner √ºber ihren Email-Client bis zu einem CRM oder einem online Game sollte es jedoch klar sein: Software macht √ºber ihre Oberfl√§che mit den unterschiedlichsten Mitteln ‚Äì Tastatureingabe, Mausbewegung, Men√º, Buttons, Spracheingabe usw. ‚Äì eine Vielzahl von Funktionen zug√§nglich.</p><p>In CRUD-Anwendung ist das ganz deutlich: Sie k√∂nnen die Listung von Daten triggern, Sie k√∂nnen ihre Aktualisierung, L√∂schung, Beschaffung, Neuanlage triggern. F√ºr jede dieser Funktionalit√§ten gibt es genau eine Funktion als Wurzel, die irgendwie durch den Benutzer gestartet werden kann. Die erh√§lt Daten als Input und erzeugt Daten als Output.</p><p>Anwendung sind mithin kaum etwas anderes als Aggregate von Batch-Programmen - die allerdings √ºber gemeinsamen Zustand im Hauptspeicher (oder in einer Datenbank) verbunden sind. Das macht ja gerade den Zweck der Anwendung als Aggregat aus im Vergleich zu lose nebeneinander liegenden Batch-Programmen.</p><p>Durch die Zusammenfassung der Funktionen in einer Anwendung wird Aufwand gespart und Bequemlichkeit f√ºr den Benutzer erzeugt. Aus der Aggregation wird Integration. Der Abstraktionskreis schlie√üt sich.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/tags/clean-code/">Clean Code</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/bequeme-abstraktion-ganz-konkret/" class="invert post__nav-link" rel="prev"><span>Previous</span> Bequeme Abstraktion ganz konkret</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/messaging-the-missing-ingredient/" class="invert post__nav-link" rel="next"><span>Next</span> Messaging - The Missing Ingredient </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>