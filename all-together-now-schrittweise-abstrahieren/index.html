<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>All together now - Schrittweise abstrahieren - One Man Think Tank</title><meta name="description" content="Aggregation, Destillation und Integration sind alle wertvoll für die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tatsächlich alle Abstraktionsarten benutzt werden und zwar in einer möglichst hilfreichen&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/feed.json"><meta property="og:title" content="All together now - Schrittweise abstrahieren"><meta property="og:image" content="https://ralfw.github.io/media/posts/100/1522317916.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Aggregation, Destillation und Integration sind alle wertvoll für die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tatsächlich alle Abstraktionsarten benutzt werden und zwar in einer möglichst hilfreichen&hellip;"><meta property="og:url" content="https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/"},"headline":"All together now - Schrittweise abstrahieren","datePublished":"2018-04-05T11:33","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/media/posts/100/1522317916.png","height":704,"width":1682},"description":"Aggregation, Destillation und Integration sind alle wertvoll für die Softwareentwicklung. Es ging mir bei der Differenzierung im vorherigen Artikel also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tatsächlich alle Abstraktionsarten benutzt werden und zwar in einer möglichst hilfreichen&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/"><img src="https://ralfw.github.io/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/test-first-codierung/" target="_self">Test-first Codierung</a></li><li><a href="https://ralfw.github.io/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design</a></li><li><a href="https://ralfw.github.io/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing</a></li></ul></li><li><a href="https://ralfw.github.io/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/testimonials/" target="_self">Testimonials</a></li><li><a href="https://ralfw.github.io/" target="_self">Blog</a></li><li class="has-submenu"><a href="https://ralfw.github.io/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/data-privacy-policy-2/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/media/posts/100/1522317916.png" srcset="https://ralfw.github.io/media/posts/100/responsive/1522317916-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/1522317916-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/1522317916-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/1522317916-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/1522317916-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/1522317916-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="704" width="1682" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2018-04-05T11:33">05.04.2018</time></div><h1>All together now - Schrittweise abstrahieren</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Aggregation, Destillation und Integration sind alle wertvoll für die Softwareentwicklung. Es ging mir <a href="https://ralfw.de/2018/03/bequeme-abstraktion-ganz-konkret/">bei der Differenzierung im vorherigen Artikel</a> also nicht darum, die eine oder andere Abstraktion herabzusetzen. Allerdings liegt mir am Herzen, dass tatsächlich alle Abstraktionsarten benutzt werden und zwar in einer möglichst hilfreichen Weise.</p><p>Aus dem Gesagten sollte klar geworden sein, dass das nicht der Fall ist, solange erstens die Integration keinen gleichberechtigten Platz neben Aggregation und Destillation bekommt. Und zweitens gehört die Integration an den Anfang der Softwareentwicklung - nicht weil sie „besser“ oder „wichtiger“ wäre, sondern weil schlicht nur für sie am Anfang überhaupt Material vorhanden ist.</p><p>Wer Softwareentwicklung startet mit der Suche nach Aggregaten oder gar Destillaten, arbeitet mit leeren Händen. Es fehlt eine Grundmenge, aus der in dieser Weise abstrahiert werden könnte. Das Ergebnis: vorzeitige Abstraktion als Spezialfall der vorzeitigen Optimierung.</p><blockquote><p>„[P]remature optimization is the root of all evil.“, Donald Knuth</p></blockquote><p>Klassen und Interfaces am Anfang der Softwareentwicklung halte ich aus diesem Grund für einen Irrweg. Mit ihnen zu beginnen bedeutet, sich der Spekulation hinzugeben und stellt eine Einladung an die Verkrustung dar.</p><p>An einem Beispiel möchte ich meine Sichtweise nun konkret erklären. Ausgangspunkt sind folgenden Anforderungen. Sie sind notwendig sehr einfach, doch das tut dem Thema keinen Abbruch. Bei umfangreicheren Anforderungen kann es nur umso wichtiger sein, sauber mit Abstraktionen umzugehen.</p><blockquote><p>Entwickle eine Anwendung, die die durchschnittliche Anzahl der Worte ab 3 Zeichen Länge pro Zeile in einer Textdatei bestimmt. Worte sind dabei Ketten von non-whitespace Zeichen und ohne übliche Sonderzeichen. Die Textdatei wird der Anwendung bei Start auf der Kommandozeile mitgeteilt.</p></blockquote><p>Was würde die gemeine Objektorientierung hier jetzt für Abstraktionen entdecken? Ich habe diese Art der Spekulation inzwischen verloren. Deshalb will ich mich daran gar nicht mehr versuchen.</p><h2>Anwendungen als Integrationen von Logik</h2><p>Es sollte offensichtlich sein, dass Anwendungen selbst Abstraktionen sind. Sie stellen Integrationen dar. In ihnen sind komplementäre Funktionalitäten zu einem Ganzen verdrahtet, das dem Benutzer das Leben einfacher macht. In diesem Fall muss er sich nicht mit den Details der Textbeschaffung, Wortbestimmung und Wortzählung sowie Durchschnittsberechnung befassen. Software ist insofern ein Werkzeug wie eine Waschmaschine oder ein Rasenmäher, das sich über eine Benutzerschnittstelle bedienen lässt.</p><p>Für eine Integration stellt sich die Frage, welche Teile von ihr zusammengefasst werden. Darauf gibt es zwei Antworten. Die triviale lautet: Anwendungen integrieren viele verschiedene Logik-Anweisungen. Ein Beispiel:</p><figure class="alignnone size-large wp-image-1462"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.37-1024x357-2xl.png 1600w" alt="" width="720" height="251"></figure><p>Die entscheidenden Zeilen sind die von 12 bis 24. Sie enthalten die Logik, die das gewünschte Verhalten herstellt. Die Anwendung abstrahiert von diesen Details indem sie das Verhalten über <code>textstats.exe</code> als Ganzes zugänglich macht.</p><p>Dass hier eine Funktion <code>Main()</code> nötig wird (die sogar noch einer Klasse zugeordnet sein muss), ist eine vernachlässigbare Eigenheit der Sprache C#. Eigentlich geht es nur um die Logikanweisungen, die durch den Compiler zu einer ausführbaren Einheit übersetzt werden.</p><p>Software <em>ist</em> eine Abstraktion, die zunächst keine weiteren Abstraktionen braucht. Die Bausteine, die sie integriert, sind die Logik-Anweisungen einer Programmiersprache.</p><p>So einfach könnte es sein mit der Abstraktion in der Softwareentwicklung – wäre da nicht eine klitzekleine Schwierigkeit: Logik als Bausteine von Anwendungen lässt sich nur sehr schwer bestimmen.</p><p>Für das obige Problem mögen Sie es einfach finden, die passenden Anweisungen zu finden. Doch schon wenn die Anforderungen etwas umfangreicher und/oder komplizierter werden, ist es damit vorbei.</p><p>Wir werden der Logik innerhalb einer Anwendung schlicht nicht Herr ohne weitere Abstraktionen. Software muss deshalb weitere <em>in sich haben</em>. Eine Anwendung muss abstraktere Bausteine integrieren als Logik-Anweisungen.</p><h2>Anwendungen als Integrationen von Funktionen</h2><p>Die erste Abstraktion <em>innerhalb</em> von Software sind nicht Klassen, wie es die Objektorientierung gern hätte, sondern Funktionen. Wenn die Logik schwer handhabbar wird, dann bekommt man sie nicht mit Aggregaten in den Griff, sondern mit weiterer Integration.</p><p>Dafür gibt es drei Gründe: Zum einen bietet die reine Logik keinen Stoff, aus dem Aggregate abstrahiert werden könnten. Aggregate, d.h. Module, fassen Funktionen (oder andere Module) zusammen. Reine Logik ist jedoch unstrukturiert, es gibt darin keine Funktionen.</p><p>Zum anderen haben Aggregationen eher keinen Wert für den Kunden. Sie machen die Entwicklung nicht spürbar produktiver; sie erzeugen keine Bequemlichkeit für die Entwicklung.</p><p>Und schließlich stellt Logik ganz natürlich den Baustoff für Funktionen dar. In einer Menge von Logik-Anweisungen die zu finden, die in ihrer Verschiedenheit und Komplementarität zu einem Ganzen integriert werden können, ist einfach. Logik hat für einzelne Funktionen die passende Granularität als Baustein.</p><figure class="alignnone size-large wp-image-1463"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.08.52-1024x746-2xl.png 1600w" alt="" width="720" height="525"></figure><p>Als Ergebnis entstehen Funktionen, die ausschließlich Logik enthalten; ich nenne sie <em>Operationen</em>.</p><p>Anwendungen werden dadurch zu einer integrierenden Abstraktion mit zwei Ebenen (<em>strata</em>). Auf der obersten Ebene ist weiterhin die Anwendung (hier repräsentiert durch <code>Main()</code>). Die integriert jedoch nicht mehr feingranulare Logik, sondern Operationen mit einer gröberen Granularität. Und diese Funktionen wiederum integrieren Logik.</p><h2>Funktionen als Integrationen von Funktionen</h2><p>Sie sehen: aus Logik, die unzweifelhaft zur Lösung des Problems des Anwenders nötig ist, ergeben sich ganz natürlich Abstraktionen. Aber nicht, wie es die Objektorientierung denkt, Aggregationen, sondern Integrationen. Sie stellen vereinfachende Zusammenfassungen von Teilfunktionalität dar, die sich der Verwendung in unterschiedlichen Zusammenhängen anbieten - und zudem die Logik besser verständlich macht, weil sie sie mit Bedeutung auflädt. Funktionsnamen sind abstrakte Platzhalter für Details. Über die Signatur einer Funktion lassen sich diese Details bequem bedienen. Das schafft Produktivität.</p><p>Für mich ist das ein Abstraktionsrezept, das der Fortsetzung lohnt. Warum bei Operationen als Integrationen stehenbleiben? <code>Main()</code> zeigt ja schon, dass sich nicht nur Logik integrieren lässt. Funktionen sind wunderbare Integrationsbausteine.</p><p>Wenn auf unterster Ebene Logik-Anweisungen integriert werden zu Operationen, dann können auf darüber liegenden Ebenen Funktionen ebenfalls integriert werden. Funktionen, die Funktionen integrieren, nenne ich <em>Integrationen</em>.</p><p>Angewandt auf den bisherigen Code kann das z.B. so aussehen. Die grünen Funktionen sind Integrationen, die roten Operationen.</p><figure class="alignnone size-full wp-image-1464"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.03.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.03-2xl.png 1600w" alt="" width="928" height="916"></figure><p><code>Main()</code> als Repräsentation der Anwendung ist jetzt eine sehr einfache Integration geworden. In drei Zeilen ist dort ausgedrückt, was vorher 13 Zeilen gebraucht hat. Aber auch <code>LoadData()</code> und <code>ExtractRelevantWordsFromLines()</code> stellen bequeme Integrationen dar. Und wenn sich irgendwo Funktionen zeigen, die zusammen wiederum eine nützliche (oder auch nur gut verständliche) Integration ergeben, dann können sie sehr leicht zusammengefasst werden, z.B.</p><figure class="alignnone size-large wp-image-1465"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.14-1024x244-2xl.png 1600w" alt="" width="720" height="172"></figure><p>Wichtig ist es, bei der Integration darauf zu achten, dass die Granularität der Bausteine angemessen ist. Funktionen und Logik in einer Integration zu mischen, passt nicht. Nur wenn integrierende Funktionen keine Logik enthalten, bleibt die Testbarkeit von Code hoch. Logik ist dann ausschließlich in Operationen versammelt, die nicht weiter funktional abhängig sind - und insofern leicht zu testen. Wenn Funktionen so strukturiert sind, dann folgen sie für mich dem <em>Integration Operation Segregation Principle (IOSP)</em>.</p><h2>Klassen als Aggregationen von Funktionen</h2><p>Integration ist für mich die initiale und sogar primäre Abstraktion in der Softwareentwicklung. Durch Integration entstehen Funktionseinheiten, die mehr und mehr Verhalten bündeln und bequem verfügbar machen. Details der Herstellung von Verhalten werden verborgen. Integrationen bieten quasi „Verhalten auf Knopfdruck“.</p><p>Doch so produktivitätssteigernd Integration ist, früher oder später braucht es eine weitere Art der Abstraktion. Zur Beherrschung von wachsenden Mengen an Bausteinen ist Aggregation nötig, sonst verlieren wir die Übersicht.</p><p>Das ist schon der Fall im obigen Beispiel, würde ich sagen. Neun Funktionen „in einer Reihe“ sind nicht mehr gut zu überblicken, allemal, wenn sie nicht alle gleichzeitig auf den Bildschirm passen.</p><p>Als physische Aggregation würde sich zur Herstellung von Übersichtlichtkeit eine Verteilung der Funktionen auf Dateien anbieten. Dadurch würden Funktionen Kategorien zugewiesen, die durch Dateinamen bezeichnet sind.</p><p>Leider lassen das jedoch nicht alle Programmiersprachen zu. In Java und C# ist eine solche Verteilung z.B. nur möglich, wenn Funktionen als Methoden in Klassen zusammengefasst sind. Deshalb lasse ich im Weiteren Dateien als Abstraktionsmittel außen vor und konzentriere mich auf Klassen (bzw. allgemeiner Module).</p><p>Aggregationen abstrahieren von Unterschieden, indem sie das existierende Gemeinsame hervorheben. Inwiefern haben also die Funktionen im Beispiel etwas gemeinsam, inwiefern unterscheiden sie sich andererseits?</p><p>Ich finde für neun Funktionen zunächst fünf Aggregate, d.h. Klassen:</p><figure class="alignnone size-large wp-image-1477"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.26-1024x452-2xl.png 1600w" alt="" width="720" height="318"></figure><p>Meine Kriterien für die Zusammenfassung in einer Klasse einerseits und die Verteilung auf verschiedene Klassen andererseits, will ich hier dahingestellt lassen. Ich habe mich leiten lassen von einem Architekturmuster, das ich [IODA Architektur] nenne.</p><p>Wichtiger als die genauen Kriterien ist mir an dieser Stelle, dass es überhaupt welche gibt. Wer auf die Funktionen blickt, wird durch seine Brille bei manchen irgendwelche Gemeinsamenkeiten finden und bei anderen keine. Manche Funktionen sind durch eine kohäsive Kraft miteinander verbunden, andere nicht. Und das wird durch die Aggregation in einer Klasse formal hervorgehoben.</p><p>Wie die Klassen auf Dateien verteilt und diese in Verzeichnissen zusammengefasst sind, ist dann eine zweite Sache. Damit kann die Aggregation noch physisch unterstrichen werden.</p><figure class="alignnone size-full wp-image-1468"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.35.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.35-2xl.png 1600w" alt="" width="396" height="436"></figure><h2>Klassen als Aggregationen von Integrationen</h2><p>Zunächst sind Klassen nur Aggregationen. Sie fassen verschiedene Funktionen auf der Basis von etwas Gemeinsamem in einer programmiersprachlich relevanten Weise zusammen. Sie geben dieser Zusammenfassung einen Namen, eine Bedeutung. Sie spannen einen Namensraum auf.</p><figure class="alignnone size-large wp-image-1469"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.46-1024x203-2xl.png 1600w" alt="" width="720" height="143"></figure><p>Was in Klassen aggregiert ist, steht ohne weiteren Zusatz gleichberechtigt nebeneinander. Es stellt allerdings eine überschaubarere Menge dar als das, was vorher ohne Klassen auf einem Haufen lag.</p><p>Spannend wird es, wenn das Gemeinsame einer Anzahl von Funktionen ist, dass sie einer Integrationshierarchie angehören. In dem Fall helfen Klassen durch Sichtbarkeitsattribute, diesen Umstand zu verschleiern. Sie können also helfen, Integrationen „auf den Punkt zu bringen“, indem sie lediglich die Wurzel eines Integrationsbaumes zugänglich machen - und alle darunter hängenden Bausteine verbergen.</p><figure class="alignnone size-large wp-image-1470"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.09.57-1024x366-2xl.png 1600w" alt="" width="720" height="257"></figure><p>Im Fall der Klasse <code>Parser{}</code> ist nur die Integrationswurzel öffentlich, alle anderen Funktionen sind unsichtbare Details der Leistungserbringung der Integration. Ob diese Wurzelfunktion eine Operation ist oder eine Integration? Das kann man ihr und der Klasse als Nutzer von außen nicht ansehen.</p><p>In dieser Hinsicht unterscheiden sich Klassen ganz wesentlich von syntaktischen Namensräumen und physischen Aggregationen. Klassen helfen hier der Integration, allerdings sind sie deshalb nicht selbst Integrationen. Sie bleiben lediglich Aggregationen.</p><h2>Anwendungen als Aggregationen von Klassen</h2><p>Logik-Anweisungen sind Elemente, die in Funktionen integriert werden. Funktionen sind Elemente, die von anderen Funktionen integriert werden oder von Klassen aggregiert.</p><p>Klassen sind nun Elemente, die von Anwendungen aggregiert werden. Zunächst sind Anwendungen - oder allgemeiner: Bibliotheken - nur Sammlungen von Klassen, die etwas gemeinsam haben. Sie alle leisten etwas, das der Erfüllung der Anforderungen des Kunden dient. Fünf Klassen sind im obigen Bild in den Topf der Anwendung geworfen und mit dem Etikett <code>textstats.exe</code> versehen worden.</p><p>Darin besteht die erste Kunst der gemeinen Objektorientierung. Ihr Ziel ist es, die Klassen zu finden, für die die zu realisierende Anwendung das Aggregat ist. Sie geht also von der Abstraktion aus und sucht zugehörige Elemente.</p><p>Der Ansatz, den ich hier beschreibe, beginnt am anderen Ende. In ihm stehen Klassen nicht am Anfang. Weder sieht er die Anwendung als Aggregat noch sucht er nach Aggregaten. Stattdessen ist die Anwendung vor allem ein Ort der Integration. Aggregate mögen später kommen, wenn genug Material dafür angehäuft ist. Klassen ergeben sich, wenn klar ist, wie das gewünschte Verhalten mittels Logik, Operationen und Integrationen hergestellt werden kann.</p><h2>Klassen als Integrationen von Klassen</h2><p>Bibliotheken mögen als reine Aggregate von Klassen durchgehen; Anwendungen jedoch integrieren immer. Deshalb liegt es nahe, dass es in Anwendungen auch Klassen gibt, die integrieren.</p><p>Integrierende Klassen sind Klassen, die andere, komplementäre zusammenziehen zu etwas Neuem, zu etwas Größerem, zu etwas Bequemerem. Das zeigt das folgende Listing exemplarisch anhand der neuen Klasse <code>App{}</code>:</p><figure class="alignnone size-large wp-image-1471"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.10-1024x649-2xl.png 1600w" alt="" width="720" height="456"></figure><p>Die Aufgabe von <code>App{}</code> ist es, die Leistungen anderer Klassen zu bündeln. Sie enthält deshalb in diesem Beispiel selbst auch keine Logik. Das ist zwar nicht Voraussetzung für eine integrierende Klasse, unterstreicht ihre Aufgabe jedoch.</p><p>Die Verantwortlichkeit von <code>Program{}</code> reduziert sich damit darauf, den Eintrittspunkt für die Anwendung zu definieren und alles herzurichten, damit das in <code>App{}</code> integrierte Gesamtverhalten abläuft.</p><p>Die integrierende Klasse steht hier an der Spitze und zieht die ansonsten nur aggregierten weiteren Klassen der Anwendung zusammen. Integrationen mit Klassen können aber natürlich auch an anderer Stelle stattfinden. Ist das sauber gemacht, bergen sie viel Potenzial für eine Produktivitätssteigerung.</p><h2>Interfaces als Destillate von Klassen</h2><p>Aggregate treten für mich erst nach Integrationen auf die Bühne der Softwareentwicklung. Und Destillate kommen sogar noch später. Der Grund: Für Destillate braucht es noch mehr Material, damit sich darin überhaupt eine destillierbare Essenz anreichern kann.</p><p>Das ist in einer Anwendung der Fall, wenn sich einige Klassen stabilisiert haben und darin destillierbare Muster zu finden sind. Oder das ist der Fall, wenn über Anwendungen hinweg Muster erkennbar sind.</p><p>Innerhalb von Anwendungen können Destillate dann Grundfunktionalität (oder Grundstruktur) bereitstellen in Form von Basisklassen, die von Ableitungen moduliert werden. Oder Destillate beschreiben abstrakt Funktionalität, die am Nutzungsort in verschiedener Weise konkretisiert werden kann.</p><p>Ein Freund von Destillaten in Form von Basisklassen bin ich nicht. Vererbung verwende ich nur in sehr wenigen und sehr klaren Fällen der Nützlichkeit und dann vor allem im Zusammenhang mit Datenstrukturen. Stattdessen favorisiere ich die Komposition (<em>Favor Composition over Inheritance, FCoI</em>), also die Integration, um auf vorhandener Funktionalität aufzubauen.</p><p>Interfaces als Form-Destillate finde ich jedoch nützlich, insbesondere, um die Testbarkeit von Code zu erhöhen. Davon kann im Beispiel die Klasse <code>App{}</code> profitieren. Sie ist die Integrationswurzel für das gesamte Verhalten der Anwendung. Ein automatisierter Akzeptanztest wäre hier also angezeigt. Doch die Abhängigkeit insbesondere von der Ressource Standard-Output macht das schwierig. Es wäre schön, Ressourcen für einen Test „abklemmen“ zu können.</p><p>Mit <em>Dependency Inversion (DI)</em> und <em>Inversion of Control (IoC)</em> ist das ohne technologische Klimmzüge möglich. Statt <code>App{}</code> direkt von Ressourcen kapselnden Aggregaten abhängig zu machen, schiebe ich ihr Form-Destillate unter und injiziere Konkretisierungen zur Laufzeit.</p><p>Das ist für mich ein Muster über Anwendungen hinweg:</p><ul><li>Ressourcenzugriffe machen das automatisierte Testen immer wieder schwierig. Also werden sie in Klassen aggregiert und dann destilliert (DI).</li></ul><figure class="alignnone size-large wp-image-1472"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.25-1024x293-2xl.png 1600w" alt="" width="720" height="206"></figure><ul><li>Destillate werden zur Laufzeit durch Produktionsobjekte bzw. Testattrappen konkretisiert.</li></ul><figure class="alignnone size-large wp-image-1473"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.34-1024x349-2xl.png 1600w" alt="" width="720" height="245"></figure><p>Der Preis, den der Mehraufwand für DI und IoC und die steigende Komplexität darstellt, halte ich für klein im Vergleich zum Gewinn. In Maßen eingesetzt ist eine solche Suboptimalität nützlich, um das Ganze deutlich zu verbessern im Hinblick auf nachweisbare Korrektheit.</p><p>Aber Vorsicht! Lassen Sie sich nicht davontragen von der Verlockung solcher Art Flexibilität. Würde dadurch nicht Software ganz allgemein viel wandelbarer? Das halte ich für einen Trugschluss, der leider in Robert C. Martins <em>Clean Architecture</em> einen populären Ausdruck gewonnen hat. Die Übersichtlichkeit der Beziehungen zwischen Abstraktionen steigt durch DI und IoC nicht. Selbst Martin muss bei Anblick eines „Komponentendiagramms“ für ein Beispiel in seinem Buch konstatieren:</p><blockquote><p>„Much of the complexity […] was intended to make sure that the dependencies between the components pointed in the correct direction.“</p></blockquote><p>Komplexität ist der Feind von Korrektheit und Wandelbarkeit. Auch mit allerbester Absicht sollten komplexitätserhöhende Maßnahmen wie DI und IoC daher nur sehr sparsam eingesetzt werden.</p><p>Das ist auch der Grund, warum Sie im hier vorgestellten Code über eine lange Strecke nur statische Methoden gesehen haben. Ich halte sie schlicht für besser testbar und leichter verständlich. Statische Methoden legen einfach nahe, keine Abhängigkeiten von Zustand oder Ressourcen einzugehen. Sie sind für mich deshalb der default – und erst wenn ich deutliche Hinweise habe, dass Daten aggregiert werden sollten oder ein Form-Destillat hilfreich wäre, rücke ich davon ab.</p><h2>Klassen als Aggregationen von Daten</h2><p>Bisher war nur von der Abstraktion rund um Logik die Rede. Klassen integrieren Klassen, die Funktionen aggregieren, die Funktionen integrieren, die Logik integrieren. Und was ist mit den Daten?</p><p>Mein Blick war bisher vor allem auf Logik und Funktionen gerichtet, weil ich glaube, dass wir Software von ihrem Verhalten her denken sollten. „Was soll Software <em>tun</em>?“ ist die zentrale Frage. Welche Funktionalität und welche Effizienz soll sie haben? Dafür müssen wir Logik finden und zu Funktionen abstrahieren und die dann weiter zu Klassen abstrahieren.</p><p>Daten sind zwar die andere Seite der Softwaremedaille und insofern auf Augenhöhe mit Verhalten, doch sie stehen für mich nicht am Anfang von Analyse und Entwurf, jedenfalls nicht jenseits des Offensichtlichen. Ich glaube nicht, dass wir uns einen Gefallen tun, wenn wir auf Anforderungen wie Trüffelschweine losgehen und Datenzusammenhänge ausschnüffeln. Daten folgen Verhalten selbstverständlich und in bekömmlichem Maße, eben so, wie sie gebraucht werden.</p><p>Am Ende gilt es dann aber natürlich auch, für Daten Abstraktionen zu finden. Welche Daten haben etwas gemeinsam und sollten in einer Klasse aggregiert werden?</p><p>Das Beispiel gibt in dieser Hinsicht leider nicht so viel her. Dennoch habe ich versucht, ein bisschen Datenabstraktion zu betreiben. Herausgekommen sind diese beiden Klassen, die ich dann auch physisch im Projekt separiert habe:</p><figure class="alignnone size-large wp-image-1474"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.10.51-1024x455-2xl.png 1600w" alt="" width="720" height="320"></figure><p>Das hat vor allem zu einem Umbau am <code>Parser{}</code> geführt:</p><figure class="alignnone size-large wp-image-1475"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.01-1024x257-2xl.png 1600w" alt="" width="720" height="181"></figure><p>Dessen Verantwortlichkeit ist geschrumpft - oder besser: fokussiert. Seine Aufgabe besteht nun einzig darin, einen Text in Zeilen und Worte zu zerlegen. Die entstehenden Daten liefert er nicht mehr in generischer, offener Form als <code>IEnumerable&lt;string[]&gt;</code>, sondern in einer speziellen Datenstruktur <code>Text{}</code>, die aus <code>Line{}</code>-Objekten besteht, die wiederum Worte enthalten.</p><h2>Klassen als Integrationen von Daten</h2><p>Durch die Aggregation sind Daten klar mit Bedeutung aufgeladen und können nun auch passende Funktionalität beigeordnet bekommen. Was vorher der Parser geleistet hat, ist zum Teil in die Datenobjekte gewandert. Die operieren damit auf sich selbst und machen es Nutzern bequemer. Davon profitiert die Domänenlogik in <code>Stats{}</code>:</p><figure class="alignnone size-large wp-image-1476"><img loading="lazy" src="https://ralfw.github.io/media/posts/100/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-xs.png 300w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-sm.png 480w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-md.png 768w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-lg.png 1024w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-xl.png 1360w, https://ralfw.github.io/media/posts/100/responsive/Bildschirmfoto-2018-04-05-um-11.11.11-1024x247-2xl.png 1600w" alt="" width="720" height="174"></figure><p>Die wünscht sich nun einfach etwas von einem <code>Text{}</code>, statt die Daten selbst zu analysieren. Eine Anwendung des <em>Tell, don’t ask (TDA)</em> Prinzips. Bei umfangreicheren Datenstrukturen ist damit natürlich mehr zu gewinnen: Konsistenzprüfungen und Navigation in Daten sind Funktionalitäten, die sich sehr gut eignen, um mit Daten in einer Klasse verbunden zu werden. Das ist Abstraktion durch Integration, weil eine Einheit entsteht, bei der nicht jeder Nutzer immer wieder alle Feinheiten der richtigen Bedienung beachten muss.</p><p>Das ist eine so typische Situation in der Objektorientierung, dass Sie ausrufen mögen, Integration stehe doch im Vordergrund der gemeinen Objektorientierung. Ich hatte ja etwas anderes behauptet in meinem vorhergehenden Artikel.</p><p>Doch ich bleibe dabei: Dass Funktionen mit Daten in Klassen gebündelt werden können, ist noch kein Zeichen für integrierendes Denken. Es kommt darauf an, warum und wie man es macht. Schon wenn die Unterscheidung zwischen Klassen, die Daten <em>sind</em>, und Klassen, die Daten <em>haben</em>, nicht getroffen wird, fehlt es an Differenzierung.</p><p><code>Text{}</code> und <code>Line{}</code> sind ganz bewusst als Klassen ausgelegt, die Daten <em>sind</em>, d.h. ihr Zweck ist es, Daten zu aggregieren und ggf. sogar zu integrieren. Die Daten sind nicht dort, weil sie eine Gemeinsamkeit von Funktionen darstellen; sie sind kein zu verbergender Zustand. Deshalb können sie auch offenliegen. Eine Datenstruktur verbirgt ihre Struktur nicht. Sie zu kapseln wäre wider ihren Zweck.</p><p>Deshalb darf der Zweck einer Datenstruktur auch nicht überladen werden mit Funktionalität. Er muss fokussiert bleiben auf das Strukturieren von Daten. Funktionen sind hier sekundär und helfen lediglich der Strukturierung.</p><p>Anders bei Klassen, die Daten <em>haben</em>. Bei ihnen stehen die Funktionen im Vordergrund. Daten bilden zwischen ihnen ein Bindeglied; sie sind quasi notwendiges Übel, weil sie die Testbarkeit der Methoden herabsetzen.</p><p>In Bezug auf diese Daten sind Klassen lediglich Aggregationen. Ihre eigentliche Funktion: die Aggregation von Funktionen, die Integrationen sind. Solche Klassen sollten keine Daten veröffentlichen. Die sind lediglich gemeinsame Details der aggregierten Funktionen.</p><p>Sie sehen, Klassen als Integrationen sind kein Selbstgänger. Deshalb glaube ich, dass mehr Differenzierung bei den Abstraktionsarten nötig ist.</p><h2>Anwendungen als Aggregationen von Funktionen</h2><p>Zum Schluss noch einmal zurück zu ganzen Anwendungen. Die sind doch nicht nur Integrationen von Logik und Funktionen, sondern auch Aggregationen.</p><p>Anwendungen bieten ihrer Umwelt eine Reihe von zusammengehörigen Funktionen an, die auf die eine oder andere Weise getriggert werden können. Dann verhält sich die Software, indem sie Input in Output transformiert.</p><p>Im Beispiel ist das leider nicht gut erkennbar. Dort gibt es nur eine triggerbare Funktion: <code>App.Run()</code>. Vom Windows Taschenrechner über ihren Email-Client bis zu einem CRM oder einem online Game sollte es jedoch klar sein: Software macht über ihre Oberfläche mit den unterschiedlichsten Mitteln – Tastatureingabe, Mausbewegung, Menü, Buttons, Spracheingabe usw. – eine Vielzahl von Funktionen zugänglich.</p><p>In CRUD-Anwendung ist das ganz deutlich: Sie können die Listung von Daten triggern, Sie können ihre Aktualisierung, Löschung, Beschaffung, Neuanlage triggern. Für jede dieser Funktionalitäten gibt es genau eine Funktion als Wurzel, die irgendwie durch den Benutzer gestartet werden kann. Die erhält Daten als Input und erzeugt Daten als Output.</p><p>Anwendung sind mithin kaum etwas anderes als Aggregate von Batch-Programmen - die allerdings über gemeinsamen Zustand im Hauptspeicher (oder in einer Datenbank) verbunden sind. Das macht ja gerade den Zweck der Anwendung als Aggregat aus im Vergleich zu lose nebeneinander liegenden Batch-Programmen.</p><p>Durch die Zusammenfassung der Funktionen in einer Anwendung wird Aufwand gespart und Bequemlichkeit für den Benutzer erzeugt. Aus der Aggregation wird Integration. Der Abstraktionskreis schließt sich.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/tags/clean-code/">Clean Code</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/bequeme-abstraktion-ganz-konkret/" class="invert post__nav-link" rel="prev"><span>Previous</span> Bequeme Abstraktion ganz konkret</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/messaging-the-missing-ingredient/" class="invert post__nav-link" rel="next"><span>Next</span> Messaging - The Missing Ingredient </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>