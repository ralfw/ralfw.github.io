<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Messaging - The Missing Ingredient - One Man Think Tank</title><meta name="description" content="Robert C. Martin wrote an interesting article on the orthogonality of Object-Orientation (OO) and Functional Programming (FP). There is no rivalry between the two, or at least should not be. Both approaches have their merits. FP and OO work nicely together. Both attributes are desirable&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/messaging-the-missing-ingredient/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/feed.json"><meta property="og:title" content="Messaging - The Missing Ingredient"><meta property="og:image" content="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.29.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Robert C. Martin wrote an interesting article on the orthogonality of Object-Orientation (OO) and Functional Programming (FP). There is no rivalry between the two, or at least should not be. Both approaches have their merits. FP and OO work nicely together. Both attributes are desirable&hellip;"><meta property="og:url" content="https://ralfw.github.io/messaging-the-missing-ingredient/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/messaging-the-missing-ingredient/"},"headline":"Messaging - The Missing Ingredient","datePublished":"2018-04-29T16:28","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.29.png","height":726,"width":1402},"description":"Robert C. Martin wrote an interesting article on the orthogonality of Object-Orientation (OO) and Functional Programming (FP). There is no rivalry between the two, or at least should not be. Both approaches have their merits. FP and OO work nicely together. Both attributes are desirable&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/"><img src="https://ralfw.github.io/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/test-first-codierung/" target="_self">Test-first Codierung</a></li><li><a href="https://ralfw.github.io/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design</a></li><li><a href="https://ralfw.github.io/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing</a></li></ul></li><li><a href="https://ralfw.github.io/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/testimonials/" target="_self">Testimonials</a></li><li><a href="https://ralfw.github.io/" target="_self">Blog</a></li><li class="has-submenu"><a href="https://ralfw.github.io/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/data-privacy-policy/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.29.png" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="726" width="1402" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2018-04-29T16:28">29.04.2018</time></div><h1>Messaging - The Missing Ingredient</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Robert C. Martin wrote an <a href="http://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">interesting article</a> on the orthogonality of Object-Orientation (OO) and Functional Programming (FP). There is no rivalry between the two, or at least should not be. Both approaches have their merits.</p><blockquote><p>FP and OO work nicely together. Both attributes are desirable as part of modern systems.</p></blockquote><p>I can only agree. And I like how Martin distills an essence from both paradigms. OO to him is:</p><blockquote><p>The technique of using dynamic polymorphism to call functions without the source code of the caller depending upon the source code of the callee.</p></blockquote><p>And FP comes down to:</p><blockquote><p>Referential Transparency – no reassignment of values.</p></blockquote><p>He’s sure that both approaches used together will lead to better software. Not in terms of functionality or efficiency, but what I call „sustainable productivity“:</p><blockquote><p>A system that is built on both OO and FP principles will maximize flexibility, maintainability, testability, simplicity, and robustness. Excluding one in favor of the other can only weaken the structure of a system.</p></blockquote><p>In order to be able to deliver new features swiftly not only today but also in the future, software must be:</p><ul><li>correct</li><li>malleable</li></ul><p>Firstly it needs to be „provable“ correct, i.e. needs a reasonable test coverage. That’s what Martin hints at with <em>robustness</em>, I suspect. Automatic tests are the measuring stick for code base’s maturity and freedom of regression. They answer the questions „Is the code already correct?“ and „Is the code still correct?“.</p><p>Secondly code needs to be easy to understand, it needs <em>simplicity</em>. Understanding is the prerequisite for change. It’s the first ingredient of <em>flexibility</em> and <em>maintainability</em> or malleability for short.</p><p>And thirdly code needs <em>testability</em>, i.e. logic pertaining to a particular aspect of the solution should be easy to address with an automated test. That’s the second ingredient of malleability and a tangible manifestation of modularization which always has been a hallmark of malleability.</p><p>But although I like Martin’s article I’m not entirely satisfied with his argument. There’s something missing. And that’s what Alan Kay, the godfather of OO, <a href="http://wiki.c2.com/?AlanKayOnMessaging">called „the big idea“</a>:</p><blockquote><p>The big idea is "messaging" […] The Japanese have a small word - ma - for "that which is in between" - perhaps the nearest English equivalent is "interstitial". The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.</p></blockquote><p>So it’s not just about whether a function is called directly or indirectly (OO) or whether it changes state or is pure (FP) or whether it contains loops or is recursive (FP). It’s also about how functions are „wired together“, how they interact with each other.</p><p>Let me explain what I mean with a couple of examples. Here’s a tiny scenario for which I will present you with different solutions based on Martin’s OO and FP essences:</p><p><em>A program to count the non-empty and non-comment lines in source files within a directory. A root directory is specified upon program start. As a result the program displays the number of files analysed and the total number of relevant lines found. Example usage:</em></p><pre><code>$ loccount /repos/someproject
4,926 lines of code in 12 files
$
</code></pre><h2>„Pragmatism“</h2><p>Let’s start with a straightforward solution as it might be written by someone not much concerned with lofty theories.</p><figure class="alignnone size-large wp-image-1487"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.21-1024x549-2xl.png 1600w" alt="" width="720" height="386"></figure><p>This is pure logic. The function <code>Main()</code> wrapped around it (and the class <code>Program{}</code> around that) is negligible.</p><p>The code is to the point; it delivers the desired behavior. This can be called simplicity - from the point of view of the writer. The writer did not spend time on modularization or recursion.</p><p>But does the code show <em>simplicity</em> from the point of view of a reader? I guess not.</p><p>Sure, this is a toy example, but even those 20 lines of logic are hard to understand. That’s the nature of logic. It’s devoid of meaning by itself. It has to be interpreted by a reader, it has to be mentally simulated; only by that understanding is generated.</p><p>And what about <em>correctness</em>? The pragmatist has not wasted any time on code to check for that either. Starting the program a couple of times while coding was sufficient for him to determine maturity (and as he progressed also freedom of regression). Unfortunately this won’t help a later reader to understand what’s happening nor is „robustness“ supported.</p><p>However, I’d say it’s no small wonder there are no tests since <em>testability</em> is virtually non-existent. The individual aspects of the solution cannot be tested in isolation. Which aspects (or responsibilities) could that be? I count at least the following on the highest level of abstraction:</p><ul><li>Accessing the file system</li><li>Accessing the console</li><li>Analysing file content</li></ul><p>And of these file content analysis is the center piece, that’s the domain logic of the program.</p><p>Even though you might argue this all is so simple it needs not more structure to be quickly understood, I hope you agree something should be done about testability. At least the domain logic should be put under test.</p><p>Here I’m highlighting what I consider domain logic:</p><figure class="alignnone size-large wp-image-1488"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.29-1024x530-2xl.png 1600w" alt="" width="720" height="373"></figure><p>You see it’s pretty scattered throughout the function. Domain logic and other aspects are intertwined. Even though there are no <code>goto</code> statements I’d call this spaghetti code.</p><p>How can a test possibly be focused on just the domain logic?</p><h2>Object-orientation</h2><p>OO to the rescue. Testability can be increased by encapsulating non-domain logic in objects and then replace these at test runtime with some kind of test double.</p><p>To enable this kind of polymorphism the <em>Dependency Inversion (DI)</em> and <em>Inversion of Control (IoC)</em> principles are employed.</p><figure class="alignnone size-large wp-image-1489"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.37-1024x708-2xl.png 1600w" alt="" width="720" height="498"></figure><p>Accessing the file system and displaying the results on the console are non-domain logic, both involve I/O. In the OO code this kind of logic is encapsulated in respective classes: <code>Filesystem{}</code> and <code>Presenter{}</code>. Calling it requires going through an object (highlighted in green). That’s an indirection, an inflection point.</p><p>By making the domain logic not depend on these classes directly but just on abstractions (interfaces, DI), different implementations can be injected at runtime (IoC) (highlighted in yellow).</p><p>And to make injection orthogonal to logic execution the domain logic is wrapped in its own class, <code>App{}</code>.</p><p>That way testing just the domain logic becomes possible:</p><figure class="alignnone wp-image-1490"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.45.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.45-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.45-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.45-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.45-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.45-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.45-2xl.png 1600w" alt="" width="368" height="383"></figure><p>Instead of „real“ file access and display logic a stub provides file data and a mock checks if it was called with the expected parameters.</p><p>This is polymorphism in action. The calling domain logic is not bound statically to specific logic. Its functional dependency can be resolved at runtime with any object living up to the expectations in terms of syntax and semantics.</p><p>At test runtime the test doubles conform to that specification. And at production runtime it’s objects instantiated from real file system and console adapters:</p><figure class="alignnone wp-image-1491"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.52-300x114.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.52-300x114-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.52-300x114-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.52-300x114-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.52-300x114-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.52-300x114-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.52-300x114-2xl.png 1600w" alt="" width="400" height="152"></figure><h2>Functional Programming</h2><p>Introducing inflection points is one way to make the domain logic testable. Disentangling and extracting it from the non-domain logic is another way. That’s what FP would do.</p><figure class="alignnone wp-image-1492"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.08.59-1024x407-2xl.png 1600w" alt="" width="851" height="338"></figure><p>Here all data from files get delivered to the doorstep of the domain logic. And results are just returned to the caller. Side effects like access to the file system or writing on the console happen outside the domain logic. That way the domain logic can be encapsulated in a pure function which is referentially transparent:</p><blockquote><p>f(a) == f(b) when a == b.</p></blockquote><p>Hence you’ll find the domain logic looking quite different from before. It’s now free of (re)assignments. There are no variables whose values get updated. Names like <code>line</code> (line 22) or <code>counters</code>(line 15) are just labels for immutable values.</p><p>To avoid variables I had to get rid of loops and use recursion, though. You decide whether this improves the understandability of the solution or not.</p><p>In any case this way the domain logic is free of resource dependencies and can be easily tested. To underline this I even made its functions static.</p><p>What happens outside the domain logic is of no concern to it. To make it testable I just need to lump together the side effect laden logic:</p><figure class="alignnone size-large wp-image-1493"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.07-1024x492-2xl.png 1600w" alt="" width="720" height="346"></figure><p>Some of it runs before the domain logic function, some after.</p><p>Martin writes:</p><blockquote><p>[I]f we exclude the hardware, and any elements of the outside world, from our referential transparency constraint, then it turns out that we can create very useful systems indeed.</p></blockquote><p>That’s what this solution does.</p><blockquote><p>[I]f we say that function [LineCounting.Count_lines()] represents all functions in the system – that all functions in the system must be referentially transparent – then no function in the system can change any global state at all.</p></blockquote><p>This is true for this solution. So I indulge in thinking it’s a FP solution.</p><h2>Messaging</h2><p>As I said at the beginning: I’m missing something from Martin’s explanation. Even though he expounds the importance of testability and malleability I find the OO and FP approaches lacking.</p><h3>Functional dependency</h3><p>Sure, they have been boiled down to just an essence and there’s more to them. But even if I take that into account the situation does not improve. Both do not tackle a fundamental problem which has been haunting software development since the invention of subroutines: functional dependency.</p><blockquote><p>Functional dependency to me means: logic calling another function to offload some work, waiting for a result, and then to continue with the result of that function.</p></blockquote><p>This is so natural to programmers, so prevalent in code bases, why should that be a problem? Because it makes code difficult to understand and hard to test.</p><p>Functional dependencies to me are the number one reason why functions grow almost indefinitely. 1000, 5000, even 10000 lines in a function are not even possible but common - and a huge impediment for reasoning about the code and changing it.</p><p>Functional dependencies violate the <em>Single Level of Abstraction (SLA)</em> principle. Logic in a function always is on a lower level of abstraction than calling another function.</p><p>Functional dependencies split logic in parts which cannot be tested independently. Also the logic can only be tested by itself if the dependency gets „defused“ by using a test double.</p><p>As you can see functional dependency is present in both the OO and FP solutions:</p><figure class="alignnone wp-image-1494"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.15-1024x581-2xl.png 1600w" alt="" width="868" height="493"></figure><p>In the OO solution it got defused in order to test the domain logic. In the FP solution it got ignored by extracting the domain logic.</p><p>Defusing by using DI/IoC introduces complexity, and does not solve the problem of unbounded function growth and violation of the SLA. Extraction of the „system under test“ on the other hand leaves the surrounding logic untestable by itself.</p><h3>Functions as objects</h3><p>Functional dependency stems from a time without objects. Encapsulation and polymorphism were no virtues. Software was behavior creating logic interspersed with subroutine calls.</p><p>But then came object-orientation. Alan Kay envisioned it <a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">like this</a>:</p><blockquote><p>I thought of objects being like biological cells […] only able to communicate with messages[,] so messaging came at the very beginning</p></blockquote><p>Two things are notable about his definition:</p><ul><li>Objects are like cells, i.e. they contain all that’s needed to accomplish a task, albeit a small one. They encapsulate logic, but do not depend on other objects’ logic.</li><li>Objects are like cells, i.e. they „do their thing“ upon reception of a message and send on results as messages. They neither know where input is coming from, nor do they know where output is going to. Message flow is unidirectional like the flow of molecules across the synaptic cleft between a nerve cell and a muscle cell.</li></ul><p>To put it bluntly: Alan Kay envisioned software built from parts without functional dependencies. Because there is no such thing in nature. Biological cells are not connected in request/response relationships.</p><p>Although this might sound a bit esoteric it is not. Rather it is very pragmatic advice and easily implemented. The most difficult part is to leave mainstream object-orientation behind for a moment.</p><p>Here’s some procedural code, even though technically an object is involved:</p><pre><code>int f(int a) {
  var x = … a …;
  var y = o.g(x);
  var z = … y … a …;
  return z;
}
</code></pre><p>This code is procedural because it contains a functional dependency. The logic in <code>f()</code> depends on the logic in <code>g()</code> of object <code>o</code>.</p><p>The logic before and after the function call is hard to test in isolation. And it cannot be tested independently of each other.</p><p>Even though <code>f()</code> might belong to a class and be called through a mainstream object - e.g. <code>p.f(42)</code> - it’s not object-oriented along Alan Kay’s notion of OO. <code>f()</code> cannot just „do its thing“. It can start, but then needs to stop and wait, and can only continue after it received some result from some other function. Messages between <code>f()</code> and <code>o</code> don’t flow unidirectionally but bidirectionally.</p><p>This might seem like a small thing. After all this is how almost all functions look like; they are a mixture of logic and calls to other functions of the same code base. Nothing has changed in this regard since the mainstream adoption of object-orientation.</p><p>That’s my point: The most important aspect of OO - at least according to Alan Kay - is still missing. We don’t build software on the notion of messaging. And the negative effects of that are numerous.</p><p>So let me add to Martin’s definition of OO:</p><blockquote><p>OO is messaging plus polymorphism. Where messaging means functions free of functional dependencies.</p></blockquote><p>How can this be accomplished? Very easily: Just have functions either contain logic or just calls to other functions of the same code base. Here’s the OO version of the above code:</p><pre><code>int fv2(int a) {
  var x = f_before(a);
  var y = o.g(x);
  var z = f_after(y,a);
  return z;
}

int f_before_(int a) =&gt; … a …;

int f_after(int y, inta) =&gt; … y … a …;
</code></pre><p>The new function <code>fv2()</code> does not contain any logic. I call that kind of function an <em>integration</em>. Its job now is only to pull together three functions into a message flow.</p><p>Since <code>fv2()</code> does not contain any logic it cannot - by definition - be functionally dependent.</p><p>The logic from <code>f()</code> has been moved to two new functions. Their job is to just execute this logic. They are focused on what I call <em>operation</em>. They play the role of objects in Alan Kay’s analogy. Messages flow in, get processed, results flow out. Operations don’t know where they get their input from or where their output goes to. Of course they also are not functionally dependent; they don’t call a function.</p><p>This is, I think and experience every day, a huge improvement over the usual way of connecting functions through functional dependencies.</p><ul><li>Improvement #1: High testability of operations. No dependencies have to be replaced with test doubles.</li><li>Improvement #2: Easy to understand integrations. They better conform to the SLA. The absence of loops requires less mental state while studying them.</li><li>Improvement #3: Very short functions. Without functional dependencies functions do not grow because an integration of dozens of lines is hard to read and easy to refactor; there’s no reason not to do it. And because an operation of dozens of lines cries for extraction of some logic into another function - but as soon as that’s done all logic has to be extracted and the operation turns into an integration.</li></ul><h3>All together now</h3><p>After this detour into theory let me show you what that means applied to the solution of the line counting problem.</p><p>Starting from the FP solution the first step is to extract the I/O logic into their own methods, operations that is. This makes it individually testable in general. <code>Main()</code> thus becomes an integration:</p><figure class="alignnone wp-image-1495"><a href="https://ralfw.de/wp-content/uploads/2018/04/Bildschirmfoto-2018-04-29-um-16.09.23.png"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.23-1024x335-2xl.png 1600w" alt="" width="843" height="275"></a></figure><p></p><p>The second step would be to overhaul the FP line counting. Check above: <code>Count_lines_rec()</code> is a mess in terms of functional dependencies, even though recursion looked so intriguing.</p><p>I’d rather not use recursion and don’t follow FP lore if the code was easier to understand. So maybe go back to the OO solution and improve it? How about removing the functional dependencies and make line counting an operation?</p><figure class="alignnone wp-image-1496"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.33-1024x413-2xl.png 1600w" alt="" width="817" height="329"></figure><p>This is still least easy to test, if not even easy to understand. No functional dependencies; even a pure function in the FP sense.</p><p>From the messaging point of view this would be a sufficient solution: I/O extracted into operations, line counting made into an operation, <code>Main()</code> an integration. The glaring concerns are testable in isolation. Each operation is focused. All operations easily fit on the screen.</p><p>But how testable is the whole? Since all functions are static so far and <code>Main()</code> does the integration, the whole can only be tested manually by running the program.</p><p>So after the application of some messaging I’d say some polymorphism is in order, too. The original OO solution had its merits. Why not keep that and improve on it by applying some messaging?</p><figure class="alignnone size-large wp-image-1497"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.41-1024x542-2xl.png 1600w" alt="" width="720" height="381"></figure><p>The <code>App{}</code> class returns to make IoC possible. The <code>Filesystem{}</code>and <code>Presenter{}</code> classes together with their interfaces return for DI. But with messaging the <code>Run()</code> method now looks clean. For that though, another method needed to be introduced which integrates the two file system methods previously needed when resource access still was scattered across the OO domain logic.</p><p>Not bad, I’d say. However <em>Load_files()</em> is striking me strange. Firstly, is it really a true integration? Doesn’t the <code>Select()</code> look like a loop, i.e. logic? Yes, that’s close to logic, but it does neither hamper understandability nor does it compromise testability. It’s a form of declarative programming. I count it as a form of integration.</p><p>Secondly why have this method in <code>App{}</code> when it integrates two functions from the same object? Yes, that does not make sense. The method can be moved to <code>Filesystem{}</code> thereby leading to even more encapsulation.</p><figure class="alignnone size-large wp-image-1498"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.09.53-1024x643-2xl.png 1600w" alt="" width="720" height="452"></figure><p>Please note that I now made the two former methods of <code>Filesystem{}</code> static. To me that’s the default. The reason is simple: static methods are easier to test. I need compelling reasons to make methods non-static. And the only compelling reasons I can think of are a need for polymorphism or shared state.</p><p>FP thinking drives me away from shared state, and polymorphism is mostly needed just to increase testability which is also increased by messaging. Hence you’ll find many more static method in my code bases than usual.</p><h2>Summary</h2><p>There is no contradiction between OO and FP. There is no either-or. Both can and should co-exist in the same code base. But don’t mistake these labels for the real thing. It’s always about purpose, about beneficial effects.</p><p>Hence I’d rather leave the labels behind and focus on the principles. However, to me most helpful there are not just the two Robert C. Martin distilled, but three:</p><ul><li>messaging</li><li>polymorphism</li><li>referential transparency</li></ul><p>In this order:</p><ul><li>First apply messaging systematically and you’ll see how understandability and testability go up tremendously.</li><li>Then add polymorphism to increase testability where needed.</li><li>Finally use referential transparency to further isolate logic from side effects in order to gain understandability and testability.</li></ul><p>To underscore it even more let me say: Without messaging, i.e. the absence of functional dependencies, all else stays a struggle in attaining correctness and malleability.</p><h2>Addendum I</h2><p>Of course I know that <code>Get_lines_in_file()</code> can be replaced by just one line of code. But I used more logic to have a bit more „logical meat“ on this small example solution. The file system adapter could look as simple as this:</p><figure class="alignnone size-large wp-image-1499"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.04-1024x353-2xl.png 1600w" alt="" width="720" height="248"></figure><p>Even merging the two static methods into <code>Load_files()</code> would be ok, I guess. But of course then independent testability of the respective logic would be gone.</p><h2>Addendum II</h2><p>Even after application of the above principles there’s one part of the solution I’m not really satisfied with. It’s the domain logic. Despite being confined to a pure function and easy to test, it’s quite a lot to test. There are at least two responsibilities blended together in the function:</p><figure class="alignnone wp-image-1500"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.13-1024x409-2xl.png 1600w" alt="" width="823" height="329"></figure><p>It’s handling files (enumeration and counting) and handling lines (enumeration, classification, counting).</p><p>To improve the conformance to the <em>Single Responsibility Principle (SRP)</em> for more testability and understandability I would like to refactor the logic a bit.</p><p>I could extract the inner responsibility into a method of its own:</p><figure class="alignnone wp-image-1501"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.23-1024x513-2xl.png 1600w" alt="" width="832" height="417"></figure><p>This does not look bad. The operation now is smaller, more focused, and the calling method is smaller too, although it’s not a true integration. But the „pseudo-integration“ is so simple, maybe that’s ok for understandability and testability. Its logic cannot be tested standalone, but with simple input data the call to <code>Count_lines_in_file()</code> is negligible.</p><p>However I feel the messaging principle urging me to think again. So I come up with this:</p><figure class="alignnone size-large wp-image-1502"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.33-1024x135-2xl.png 1600w" alt="" width="720" height="95"></figure><p>The logic in <code>Count_lines()</code> is gone. The imperative <code>foreach</code> has been replaced by declarative looping with Linq. Also no more incrementing of any counters. This has been extracted into a pure function which can be tested even more easily. <code>Count_lines()</code> now clearly shows its nature of a map-reduce processing step. It has become an integration. Messaging is established: <code>fileLines.Select()</code> is sending blocks of lines to <code>Count_lines_in_file()</code> which in turn is sending LOC counts on to <code>Aggregate()</code> which sends them on to <code>Total()</code>.</p><p>But what about <code>Count_lines_in_file()</code>? To be honest, I now find it comparatively complicated and mixing responsibilities. Enumeration and classification and counting are happening all within a single function. That’s not very SRP.</p><p>But when I again try to apply the messaging principle I’m able to pull the different responsibilities apart into a message flow:</p><figure class="alignnone wp-image-1503"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.42-1024x746-2xl.png 1600w" alt="" width="773" height="564"></figure><p><code>lines.Select()</code> produces a stream of single lines which are passed into a state automaton to be classified as relevant or not. And this result then flows into a counting operation.</p><p>The state automaton is a real object even in the mainstream OO sense. It encapsulates state which is shared across calls to its single method. To me that’s a perfect example for the co-existence of OO and FP in the same program, even the same class. <code>Count_relevant_lines()</code> is a pure function (FP), but <code>IsRelevant()</code> is the opposite: a stateful function made possible with the help of OO features.</p><p>And why not? It’s easy to test with a little help of an internal constructor:</p><figure class="alignnone wp-image-1504"><img loading="lazy" src="https://ralfw.github.io/media/posts/101/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302-xs.png 300w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302-sm.png 480w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302-md.png 768w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302-lg.png 1024w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302-xl.png 1360w, https://ralfw.github.io/media/posts/101/responsive/Bildschirmfoto-2018-04-29-um-16.10.51-1024x302-2xl.png 1600w" alt="" width="869" height="257"></figure><p>Alternatively I could use a second parameter to a static function and a closure, I guess. But that to me would be less encapsulating. I’m happy to mix FP and OO in the way shown.</p><p>But note the driver behind these refactorings: it’s the messaging principle. I want to get rid of functional dependencies wherever I can.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/tags/clean-code/">Clean Code</a></li><li><a href="https://ralfw.github.io/tags/oop/">OOP</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/all-together-now-schrittweise-abstrahieren/" class="invert post__nav-link" rel="prev"><span>Previous</span> All together now - Schrittweise abstrahieren</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/organisationen-bootstrappen-mit-soziokratie-teil-1/" class="invert post__nav-link" rel="next"><span>Next</span> Organisationen bootstrappen mit Soziokratie - Teil 1 </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>