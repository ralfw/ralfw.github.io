<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Nachhaltig wertvolle Software liefern - One Man Think Tank</title><meta name="description" content="Unter der Lupe zeigt sich, dass das Agile Manifest nicht nur auf working software abzielt, sondern auf valuable software. Das ist jedenfalls mein Ergebnis einer näheren Betrachtung. Es geht darum, wertvolle Software in nachhaltiger Weise zu liefern. Und dafür braucht es einen fundamentalen Modus der&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/homepage-ralfw-de/nachhaltig-wertvolle-software-liefern/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/homepage-ralfw-de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/homepage-ralfw-de/feed.json"><meta property="og:title" content="Nachhaltig wertvolle Software liefern"><meta property="og:image" content="https://ralfw.github.io/homepage-ralfw-de/media/posts/98/fruit-1929879_1280.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Unter der Lupe zeigt sich, dass das Agile Manifest nicht nur auf working software abzielt, sondern auf valuable software. Das ist jedenfalls mein Ergebnis einer näheren Betrachtung. Es geht darum, wertvolle Software in nachhaltiger Weise zu liefern. Und dafür braucht es einen fundamentalen Modus der&hellip;"><meta property="og:url" content="https://ralfw.github.io/homepage-ralfw-de/nachhaltig-wertvolle-software-liefern/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/homepage-ralfw-de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/homepage-ralfw-de/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/homepage-ralfw-de/nachhaltig-wertvolle-software-liefern/"},"headline":"Nachhaltig wertvolle Software liefern","datePublished":"2018-03-21T21:59","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/posts/98/fruit-1929879_1280.png","height":853,"width":1280},"description":"Unter der Lupe zeigt sich, dass das Agile Manifest nicht nur auf working software abzielt, sondern auf valuable software. Das ist jedenfalls mein Ergebnis einer näheren Betrachtung. Es geht darum, wertvolle Software in nachhaltiger Weise zu liefern. Und dafür braucht es einen fundamentalen Modus der&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/homepage-ralfw-de/"><img src="https://ralfw.github.io/homepage-ralfw-de/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/homepage-ralfw-de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/homepage-ralfw-de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/homepage-ralfw-de/test-first-codierung/" target="_self">Test-first Codierung</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing</a></li></ul></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/testimonials/" target="_self">Testimonials</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/" target="_self">Blog</a></li><li class="has-submenu"><a href="https://ralfw.github.io/homepage-ralfw-de/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/homepage-ralfw-de/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/data-privacy-policy-2/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/homepage-ralfw-de/media/posts/98/fruit-1929879_1280.png" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/98/responsive/fruit-1929879_1280-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/98/responsive/fruit-1929879_1280-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/98/responsive/fruit-1929879_1280-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/98/responsive/fruit-1929879_1280-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/98/responsive/fruit-1929879_1280-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/98/responsive/fruit-1929879_1280-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="853" width="1280" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2018-03-21T21:59">21.03.2018</time></div><h1>Nachhaltig wertvolle Software liefern</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/homepage-ralfw-de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Unter der Lupe zeigt sich, dass das Agile Manifest nicht nur auf <em>working software</em> abzielt, sondern auf <em>valuable software</em>. Das ist jedenfalls mein Ergebnis <a href="https://ralfw.de/2018/03/das-agile-manifest-unter-der-lupe/" target="_blank" rel="noopener noreferrer">einer näheren Betrachtung</a>.</p><p>Es geht darum, wertvolle Software in nachhaltiger Weise zu liefern. Und dafür braucht es einen fundamentalen Modus der für mich so aussieht:</p><blockquote><p>Produktion eines stetigen Stroms von zielführenden Artefaktänderungen ohne Budgetvorgabe.</p></blockquote><p>Wenn das für Sie provokant klingt, dann ist das Absicht. Ja, es soll provozieren, es soll an Gewohnheiten und Glaubenssätzen rütteln. Nur wenn wir unser Denken in solcher Weise an die Grenze bringen, können wir hoffen, unseren Horizont zu erweitern und (noch) bessere Ergebnisse zu erzielen.</p><p>Doch natürlich soll das nicht ohne weitere Erklärung im Raum stehenbleiben. Die Begriffe verdienen eine Definition.</p><h2>Wert</h2><p>Das Agile Manifest erklärt nicht näher, was <em>working software</em> ist. Liegt das nicht auch auf der Hand? Es ist Software, die ihre Aufgabe erfüllt, die nützlich ist. Nützliche Software ist wertvoll für den Kunden, dafür ist er bereit, Geld zu bezahlen.</p><p>Eine aus meiner Sicht oberflächliche Lesart des Agilen Manifests fokussiert die Softwareentwicklung also darauf, einen Strom lauffähiger Software zu produzieren. Der Scrum Guide formuliert es so:</p><blockquote><p>The heart of Scrum is a Sprint, a time-box of one month or less during which a “Done”, useable, and potentially releasable product Increment is created.</p></blockquote><p>Ob eine Software <em>useable</em> oder <em>working</em> ist, kann der Kunde beurteilen. Er muss sie nur ausprobieren. Stellvertretend für den Kunden definiert und überprüft der Product Owner diese Qualität.</p><p>Allerdings glaube ich, dass mit diesem Fokus das Agile Manifest und noch konkreter der Scrum Guide zu kurz greifen. <em>Working software</em> darf nicht der einzige Marktstein für den Fortschritt der Softwareentwicklung sein.</p><p><em>Working software</em> ist nämlich nur das: <em>working</em>, nützlich, brauchbar im Moment. Was aber in der Zukunft? Wenn eines gewiss ist in der Softwareentwicklung, dann dass der Kunde gerade wenn er <em>working software</em> in den Händen hält, bald mehr davon haben will. <em>Working software</em> heute, soll morgen schon wieder anders aussehen.</p><p>Dass jedoch eine Anpassung von Software an immer neue Wünsche des Kunden ohne weiteres Zutun möglich sei, ist ein Trugschluss, dem nicht nur Laien wie der Kunde unterliegen.</p><p><strong>Die Anpassbarkeit, die Wandelbarkeit, die eine Codebasis braucht, um dauerhaft ohne steigenden Aufwand neuen Anforderungen nachgeführt werden zu können, braucht explizite Aufmerksamkeit</strong>. Darum muss sich die Softwareentwicklung sehr bewusst bemühen. Flexibilität ergibt sich nicht einfach so.</p><p>Für mich steckt diese Notwendigkeit jedoch nicht im Begriff <em>working software</em>. <em>Working software</em> zeigt lediglich gewünschtes Verhalten im Moment, also Funktionalität und Effizienz gemäß der Anforderungen.</p><p>Aber wie steht es mit der ebenfalls notwendig zu wünschenden Wandlungsfähigkeit? Zugegeben, die kann der Kunde nicht direkt überprüfen. Sie ist keine Laufzeiteigenschaft. Indirekt jedoch zeigt sie sich ihm im Trend der Produktivität der Softwareentwicklung.</p><p>Nur weil der Kunde keine unmittelbare Aussage über die Wandelbarkeit einer Codebasis machen kann, heißt das jedoch nicht, dass niemand dazu ein Urteil abgeben könnte. Die Rolle, die traditionell dazu eine Meinung haben sollte, ist der Architekt. Seine Aufgabe ist es, die Erfüllung nicht-funktionaler Anforderungen sicherzustellen. Dazu gehören aber nicht nur Effizienzen wie Performance oder Security, sondern eben auch Zukunftsfähigkeit durch Korrektheit und Wandelbarkeit.</p><p>In Scrum spielt der Architekt allerdings keine Rolle. Ob es einen gibt, wie auf die Anforderung „Wandelbarkeit“ geachtet wird, ist kein Thema. In <a href="https://de.wikipedia.org/wiki/Extreme_Programming" target="_blank" rel="noopener noreferrer">eXtreme Programming</a> hingegen gibt es ausdrücklich Praktiken, die sich darum kümmern, z.B. Refactoring oder TDD. Demgegenüber finde ich im Agilen Manifest eine Formulierung wie „good design enhances agility“ schwach - und sehe als Resultat auch in Scrum-agilen Teams oft nur schwache Testabdeckung und Berge an <em>legacy code</em>.</p><p>Also: <strong>Nachhaltige Produktivität ist kein Zufall und muss den Kunden interessieren.</strong> Sie gehört zu den Anforderungen an die Softwareentwicklung. Die Softwareentwicklung, allemal die agile, muss auch sie liefern. Dafür braucht es einen Begriff, in dem sie mit gefasst ist; der ist für mich <em>valuable software</em>.</p><p><em>Valuable software</em> ist denn auch deutlich mehr, als lauffähige, nützliche Software. Der Wert von <em>valuable software</em> zeigt sich nicht nur an Laufzeiteigenschaften, sondern an all dem, was in einem Code-Repository zu finden ist.</p><h2>Zielführende Artefaktänderungen</h2><p>Wenn am Repository eine Änderung vorgenommen wird, die dazu führt, dass die Software mehr kann (<strong>Funktionalität</strong>), dann steigt ihr Wert.</p><p>Wenn am Repository eine Änderung vorgenommen wird, die dazu führt, dass sich die <strong>Effizienz</strong> der Software verbessert, dann steigt ihr Wert.</p><p>Und wenn am Repository eine Änderung vorgenommen wird, die dazu führt, dass die <strong>Korrektheit</strong> sichergestellt oder die <strong>Wandelbarkeit</strong> größer ist, dann steigt der Wert der Software ebenfalls.</p><p>Den Kunden interessiert für <em>working software</em> lediglich die Logik in einem Code-Repository, also die Anweisungen, die Eingaben in Ausgaben transformieren. Logik ist jedoch nur ein Teil dessen, was sich im Code-Repository findet. Mit ihr lassen sich Funktionalität und Effizienz beeinflussen.</p><p>Was ist mit Bibliotheken, Komponenten, Services? Sind die nötig für <em>working software</em>? Durchaus, denn durch eine geschickte Modularisierung und Verteilung lässt sich ebenfalls die Effizienz günstig beeinflussen. Außerdem kann die Bereitstellung von Software vereinfacht werden. Ein nicht zu vernachlässigender Aspekt von <em>working software</em>, der auch noch recht unmittelbar spürbar für den Kunden ist, aber schon zur Forderung nach Produktivität gehört. Dem dienen übrigens auch z.B. CI-Skripte oder Docker Container.</p><p>So weit der übliche Fokus der Softwareentwicklung.</p><p>Änderungen an Code, die hier eingreifen und die Softwareeigenschaften verbessern, sind deutlich zielführend mit Blick auf <em>working software</em>.</p><p>Was aber mit Funktionen und Klassen? Was mit Variablennamen, Kommentaren oder gar Dokumenten wie Glossar oder Entwurfsdiagramm? Was mit automatisierten Tests?</p><p>Sie sind für <em>working software</em> nicht nötig. Sie machen nur Sinn, wenn es um <em>valuable software</em> geht. Tests dienen der Überprüfung von Reife und Regressionsfreiheit; Funktionen dienen der Testbarkeit; Variablennamen, Klassen, Kommentare, Dokumente dienen der Verständlichkeit.</p><p>Änderungen an diesen Artefakten in einer Code-Basis sind also nicht minder wertvoll. Eine Refaktorisierung, ein weiterer Test, ein besserer Variablenname, ein begründender Kommentar, ein verständlicher Entwurf sind genauso zielführend wie Veränderungen an der Logik. Der Zweck ist nur nicht wertvolleres Softwareverhalten, sondern die Zukunftsfähigkeit der Softwareentwicklung. Es geht um die Lebenszeit der Software.</p><p>Ich glaube ganz fest, dass wir gut daran tun, auch für diese Veränderungen Wertschätzung zu entwickeln. Der Kunde wird es uns danken, weil er bemerkt, dass wir produktiver und verlässlicher werden. Er bekommt mehr Wert für sein Geld, nicht nur, weil mehr unserer Arbeit als wertvoll klassifiziert ist, sondern weil wir damit auch der <em>working software</em> auf die Sprünge helfen. Nachhaltigkeit hat einen spürbaren Effekt - allerdings ist sie kein <em>quick win</em>.</p><p>Wenn die Erfüllung einer Aufgabe (z.B. User Story, Task) in der Softwareentwicklung dazu führt, dass ein Artefakt zielführend in der obigen Weise verändert wird, dann ist das ein positives Resultat der Arbeit. Es entsteht Wert - entweder im Auge des betrachtenden Product Owners oder im Auge des betrachtenden Architekten als Stellvertreter des Kunden.</p><p>Jetzt kommt es nur darauf an, dass solche Werte zuverlässig entstehen.</p><h2>Ohne Budgetvorgaben</h2><p>Kunden wollen Fortschritt und das verlässlich. Sie wollen sicher sein, dass ihr Geld tatsächlich in Wert transformiert wird.</p><p>Üblicherweise versucht man Kunden diese Sicherheit zu geben, indem man ein Ergebnisversprechen macht: es wird ein inhaltlicher Umfang für eine Veränderung verhandelt, der im Rahmen eines Budgets geleistet wird. Scope und Budget sind fix.</p><p>Der Scope kann sich dabei nur auf das Softwareverhalten beziehen, denn nur das ist für den Kunden bei Lieferung nach Ausschöpfen des Budgets unmittelbar überprüfbar. Für den Kunden geht es deshalb sehr verständlich um <em>working software</em>.</p><p>Und wenn das so ist, dann ist es nicht verwunderlich, dass das Budget von der Softwareentwicklung vor allem für <em>working software</em> eingesetzt wird - auch wenn <em>valuable software</em> der eigentliche Zweck der Agilität ist. Mit der fixierten Kombination <em>(Scope, Budget)</em> wird mithin notorisch zu wenig Wert hergestellt.</p><p>Dazu kommt, dass sich selbst für einen (scheinbar) fixen Scope für einen Zuwachs an Wert bei <em>working software</em> nur schwer ein Budget (z.B. für den zeitlichen Aufwand) bestimmen lässt. <strong>Die Kunst der Abschätzung ist eine Jahrmarktskunst, die selten mit ihren Konsequenzen zu leben hat.</strong> Die kommen an anderer Stelle zum Tragen und erzeugen große Mengen an Verschwendung, ganz zu schweigen von einem Mangel an Wert. Die fixierte Kombination <em>(Scope, Budget)</em> behindert die Herstellung von <em>valuable software</em>.</p><p>Dieser Effekt mag geringer sein, wenn man den Scope verringert und somit das Budget verkleinert. Statt einen riesigen Scope in 3 Jahren mit 10 Personen zu realisieren, geht es heute nur noch um einen kleinen Scope, der z.B. in 2 Wochen mit 4 Personen umgesetzt werden soll.</p><p>Iterativ-inkrementelles Vorgehen reduziert zwar das Leiden an Ergebnisversprechen in gewisser Weise. Geheilt ist das fundamentale Problem damit jedoch nicht. Allemal nicht, solange der Fokus weiterhin auf <em>working software</em> und nicht auf <em>valuable software</em> ist.</p><p>Deshalb halte ich es für ein Gebot wahrhafter Agilität, genau hier einen anderen Kurs einzuschlagen. Es passt schlicht nicht zum Anspruch der Agilität, die Provokation von Konflikten hinzunehmen, die in Ergebnisversprechen immer lauert.</p><p>Anders als bisher gedacht ist dafür eine Verkleinerung der Ergebnisversprechen jedoch nicht genug. Auf 2 Wochen etwas zu versprechen statt auf 3 Jahre, stellt keinen fundamentalen Wandel zu dem dar, was die Agilität ursprünglich motiviert hatte.</p><p>Ich denke, es ist nötig, nicht im Versuch einer graduellen Verbesserung zu verharren, sondern das Wurzelproblem bei den Hörnern zu packen. <strong>Unzuverlässigkeit, wie sie immer noch die Branche jeden Tag schüttelt, bekämpft man nicht mit einer Erhöhung der Taktzahl für Ergebnisversprechen.</strong></p><p>Erstens ist weiter zu fassen, was überhaupt versprochen wird. Man muss klar haben, dass es um <em>valuable software</em> geht.</p><p>Zweitens ist die Kopplung von Scope und Budget aufzugeben.</p><blockquote><p>Der Kunde darf für sein Geld keine Lösungen mehr erwarten!</p></blockquote><p>Die Herstellung von Lösungen für Probleme (Scope) im Rahmen eines fixen Budgets kann Softwareentwicklung nicht leisten und sollte es nicht mehr versprechen. Alles andere macht unglücklich. Und das geht so lange, bis einer weint.</p><h2>Resultatsorientierte Softwareentwicklung</h2><p>Unerhört, oder? „Keine Lösungen mehr fürs Geld? Wie soll das denn gehen? Das macht der Kunde nie mit!“</p><p>Natürlich habe ich die obige Forderung absichtlich etwas provokant formuliert. Sie soll überspitzt auf den Punkt bringen, welches Umdenken ich für nötig halte.</p><p>Verständlich wird es hoffentlich, wenn ich den Dreh- und Angelpunkt benenne: Verantwortlichkeit.</p><p>Ich glaube, bei Agilität geht es ganz grundsätzlich um eine Umkehrung der Verantwortlichkeit, sozusagen <em>inversion of responsibility</em>.</p><p>Wer von einem Dienstleister eine Lösung will, der muss ihm ganz präzise beschreiben, wie das Problem lautet und was die Eigenschaften der Lösung sein sollen. <em>Ganz präzise</em> bedeutet, dass der Dienstleister wirklich, wirklich beurteilen kann, ob er die Lösung auch tatsächlich herstellen kann. Wenn er das verspricht, übernimmt er die Verantwortung. Dann ist der Ball in seinem Spielfeld und er muss leisten. Der Kunde kann sich zurücklehnen und auf die Lieferung der Lösung warten.</p><p>Ein solches Verhältnis besteht zwischen Ihnen und zum Beispiel einer Bäckerei. Sie gehen in den Laden, fragen nach einem Dinkelbrot – und der Verkäufer kann entscheiden, ob er eine Lösung für Sie hat.</p><p>Ein solches Verhältnis besteht aber z.B. schon nicht mehr zwischen Ihnen und einem Friseur. Dem beschreiben Sie nämlich nicht präzise, wie eine Lösung für Ihr Haarproblem aussieht und überlassen sich ihm dann blind. Nicht umsonst sitzen Sie während der Dienstleistung vor einem Spiegel. Sie sollen und müssen sehen, wie sich die Lösungsherstellung entwickelt. Gegen Ende hält dann der Friseur auch noch einen Spiegel hinter Sie, so dass sie beurteilen können, ob die Lösung schon am Hinterkopf erreicht ist.</p><p>Der Friseur hat eine Menge Kompetenzen, die er Ihnen gern anbietet als Hilfestellung bei der Lösungserarbeitung. Aber letztlich benutzen Sie den Friseur nur als Werkzeug. Sie selbst sind es, der die Lösung herstellt. Die Verantwortung bleibt bei Ihnen.</p><p>Das glauben Sie nicht? Dann setzen Sie nächstes Mal beim Friseurgang eine Augenbinde auf. Vermeiden Sie den Blick in jeden Spiegel, bevor Sie wieder zuhause sind. Wie fühlen Sie sich damit?</p><p>Die Softwareentwicklung muss klar machen, dass sie keine Lösungen produziert, sondern lediglich dem Kunden ein williges Werkzeug ist, das zielführende Resultate liefert – die der Kunde zu einer Lösung zusammensetzt. Er behält die Hoheit der Steuerung.</p><p>Für die Steuerung braucht der Kunde jedoch zweierlei:</p><ul><li>Kontakt zur Softwareentwicklung, denn er muss spüren, wie sie sich bewegt, und mit Anforderungen immer wieder steuernd eingreifen.</li><li>Feingranulare Resultate zu fixem Preis, um die Kosten des Fortschritts im Blick zu behalten und ggf. umzusteuern.</li></ul><p>Kunde und Softwareentwicklung müssen also <em>in touch</em> sein. Entfernt der Kunde sich, widmet er der Softwareentwicklung keine Aufmerksamkeit, wird er seiner Verantwortung als Lösungsproduzent nicht gerecht. So weit war das Agile Manifest auch noch klar in seinen Werten. <em>Customer collaboration</em> sei zentral. <em>„Business people and developers must work together daily throughout the project“</em> heißt es fordernd.</p><p>Doch auch das Agile Manifest verlagert nicht ausdrücklich die Verantwortung für die Lösung dorthin, wohin sie gehört: zum Kunden. Softwareentwicklung wird noch als Lösungshersteller angesehen. Ich glaube, genau das funktioniert jedoch nicht. Denn was schon beim Friseur keine Option ist, kann bei etwas so viel Komplexerem wie Software gar nicht funktionieren.</p><p>Wenn die Verantwortung jedoch zum Kunden (zurück)verlagert wird, was liefert dann die Softwareentwicklung? Wie oben gesagt: zielführende Veränderung am Code-Repository im Sinne von <em>valuable software</em>.</p><p>Da nun jedoch keine Lösung mehr von der Softwareentwicklung erwartet wird, ist es auch nicht nötig, für solche Veränderungen vorher ein Budget zu vereinbaren. Es muss lediglich feststellbar sein und festgestellt werden, welche Veränderungen auf welches Ziel hin vorgenommen wurden. Resultate müssen klar zuordnbar sein.</p><p>Was wurde für diese Funktionalitätsanforderung getan? Wie viel wurde für jene Effizienzanforderung aufgewendet? Wann wurde etwas für die Wandelbarkeit geleistet?</p><p>Das muss der Kunde grundsätzlich sehen können, wenn er auch nicht immer selbst einschätzen kann, ob das alles nach den Regeln der höchsten Kunst geschehen ist.</p><p>Insbesondere müssen klare Resultate in Richtung nachhaltiger Produktivität überhaupt identifizierbar sein. Das Herumeiern um Refactorings und automatisierte Tests, für die angeblich nie Zeit und Geld vorhanden sind, kann so nicht weitergehen. Es ist eine Schande für die Branche. <strong>Unsicherheit darüber, ob und wann man sich für nachhaltige Qualität engagieren darf, ist im höchsten Grade unprofessionell.</strong></p><p>Softwareentwicklung darf sich deshalb nur agil nennen, wenn sie dem Kunden gegenüber in diesem Punkt glasklar die Wahrheit sagt. Sie muss ihn in die Lage versetzen, auch in dieser Hinsicht Vertrauen zu entwickeln. Das Mittel dazu ist Transparenz. Wofür und in welcher Menge wird Aufwand für nachhaltige Produktivität und nicht nur für Funktionalität und Effizienz getrieben?</p><p>Sollte der Kunde mit dieser Transparenz nichts anfangen können, steht es ihm frei, einen Sachverständigen hinzuzuziehen, der auf die gemeldeten Resultate einen Blick wirft. Das macht jeder Kunde eines Immobilienherstellers nicht anders. Bauingenieure arbeiten nicht nur beim Hersteller, sondern auch beim Abnehmer.</p><p>Damit meine ich allerdings nicht, dass auf platte Code-Metriken gestarrt werden sollte. Es geht vielmehr um den Strom der Resultate. Auf ihm schwimmt der Kunde in Richtung Lösung, in ihm muss er steuern. Produktivität und Fortschritt sind nichts, was man aus einem Schnappschuss herauslesen kann.</p><p>Die Lösung entsteht also im Auge des betrachtenden Kunden (bzw. seiner Stellvertreter). Fast bin ich versucht zu sagen, sie emergiert. <strong>Denn die Lösung im Ganzen als Ergebnis der Softwareentwicklung ist nicht für die Softwareentwicklung im Detail mit vorhersehbaren Schritten kontrolliert herstellbar.</strong> Die Softwareentwicklung konzentriert sich nur auf sicheren Tritt, sie setzt einen Fuß vor den anderen. Gesteuert wird sie dabei vom Kunden bzw. von den Verhältnissen des Terrains.</p><p><strong>Mit der Verantwortung für die Lösung beim Kunden ist die Softwareentwicklung reduziert auf die verlässliche Lieferung von Fortschritten. </strong>Ja, Verlässlichkeit steht im Kern agiler Softwareentwicklung. Dafür ist alles zu tun. Sie ist nämlich die hauptsächliche Zutat für Kleber und Schmierstoff zwischen Kunde und Dienstleister: Vertrauen.</p><p><strong>Agilität kreist mithin um die Frage, wie Verlässlichkeit geradlinig und dauerhaft hergestellt werden kann.</strong></p><h3>Fixe Budgets</h3><p>Es ist etwas dran an dem überkommenen Liefermuster. Verlässlichkeit profitiert von einem fixen Budget. Es stellt ein minimales Versprechen dar, das in jedem Fall erfüllt werden muss:</p><ul><li>Die Softwareentwicklung arbeitet das Budget für eine Aufgabe konzentriert ab.</li><li>Nach Ausschöpfung des Budgets liefert die Softwareentwicklung und der Kunde gibt Feedback.</li></ul><p>Dieses Versprechen ist schon schwierig genug zu erfüllen. Denn: Konzentrierte Arbeit ist eine Seltenheit in den Softwareabteilungen, die ich kenne.</p><p>Ohne Konzentration geht es jedoch nicht, weil das Budget sonst verschwendet wird. Die Lieferung fällt kleiner aus als sie könnte. Ein Kunde, der bemerkt, dass das gewährte Budget verschwendet wird, ist kein glücklicher Kunde.</p><p><strong>Agiles Vorgehen bedeutet also, dass sich Softwareentwicklung um fixe Budgets dreht.</strong> Allemal braucht es vordefinierte Timeboxes, in denen sie stattfindet.</p><p><strong>Allerdings ist die Größe der Budgets eben nicht abhängig von einem abgeschätzten Lösungsumfang!</strong> Die Softwareentwicklung produziert ja keine Lösungen mehr. Stattdessen ist das Budget schon vorher festgelegt und steht höchstens in Zusammenhang mit einer Aufgabenkategorie. Eine Aufgabe im Frontend könnte mit einem anderen fixen Budget angegangen werden als eine Aufgabe im Backend, eine Codierungsaufgabe könnte ein anderes fixes Budget haben als eine Analyseaufgabe usw.</p><p>Wesentlich ist jedoch nicht der genaue Budgetumfang, sondern seine Unabhängigkeit von genauer Aufgabe und Lösung. <strong>Damit wird das Budget zum verlässlichen Taktgeber. Damit entsteht Zug in der Softwareentwicklung, denn Lieferungen erfolgen stets am Ende des Budgets.</strong> An dieser Gewissheit muss sich alles ausrichten. Softwareentwicklung findet somit quasi vom Ende her statt.</p><h3>Minimale Budgets</h3><p>Fixierte Budgets können zwar grundsätzlich unterschiedlich groß sein, doch wie berechnet sich diese Größe? Eine Schätzung findet nicht mehr statt. Die Schätzung hat sich ja als fundamental untauglich zur Herstellung konfliktfreier Softwareentwicklung herausgestellt. Das ist die Erkenntnis der Agilität – auch wenn sie so nicht gelebt wird.</p><p>Statt die Größe eines Budgets zu schätzen, wird es einfach festgesetzt. Der Umfang ist im Grunde beliebig. Allerdings gibt es zu bedenken: je größer das Budgets, desto größer auch die Gefahr für Konzentrationsverlust, desto länger die Zeit bis zu einer Lieferung inkl. Feedback, desto wahrscheinlicher, dass Verschwendung entsteht.</p><p>Wenn also schon keine Lösung mehr durch Ausschöpfen des Budgets hergestellt wird, dann sollte es so gewählt werden, dass ein Strom an Lieferungen entsteht, der leicht gesteuert werden kann. Das klappt am besten bei feingranularen Lieferungen.</p><p>Mir scheint deshalb empfehlenswert, das Budget aggressiv klein zu halten. Eine Timebox für übliche Softwareentwicklungsaufgaben sehe ich bei einer Dauer von 30min bis 90min - wobei ich derzeit 30min oder 45min favorisiere.</p><p>„Was, so kurz?! In der Zeit kann man doch nichts schaffen!“ mögen Sie jetzt ausrufen. Doch bitte bedenken Sie: Es geht nicht darum, in dieser Timebox eine Lösung herzustellen. Selbst für die Aufgabe „Entwickle einen Twitter-Klon“ wäre die Timebox nicht größer ;-) Das ist ja mein Punkt: <strong>Agilität entsteht nur durch radikale Aufgabe der Vorstellung, dass Lösungen mit abschätzbaren Budgets punktgenau realisiert werden können</strong> oder überhaupt von der Softwareentwicklung geliefert werden sollten.</p><p>Im Rahmen der einzelnen Timebox ist die ganze Lösung nicht bewältigbar, nicht erkennbar. Nur so kann Emergenz entsteht. Nur so kann die Illusion, dass Lösungen kontrolliert geradlinig entwickelt werden können, durchbrochen werden.</p><p><strong>Innerhalb einer Timebox gibt es keinen Druck, eine Lösung zu erzielen, also einen Scope garantiert umzusetzen. In ihr besteht die einzige Aufgabe darin, <em>konzentriert</em> und nach Kräften Wert zu erzeugen.</strong> Das kann in Bezug auf die Funktionalität oder Effizienz oder Korrektheit oder Wandelbarkeit geschehen.</p><p>Es geht ausschließlich um Fortschritt im Sinne einer Wertsteigerung. Wie viel Wert entsteht dann in einer Timebox? Das hängt davon ab, wie konzentriert die Arbeit in der Timebox ist und welche Kompetenz die beteiligten Personen haben. Wer mehr Wert herstellen will, der konzentriert sich besser und achtet darauf, unabhängig und befähigt zu sein.</p><p><strong>Eine aggressiv kleine Timebox hilft, die Verschwendung zu begrenzen.</strong> Mehr als 90min konzentrierte Arbeit ist kaum möglich. Wer es länger versucht, der erhöht die Wahrscheinlichkeit zum Konzentrationsverlust und damit zu einer Lieferung, die kleiner als möglich ausfällt.</p><p><strong>Aggressiv kleine Timeboxes takten die Arbeit in einer Weise, die durch häufige konzentrierte Lieferungen befriedigt und gleichzeitig offen hält für Kontakt mit der Umwelt.</strong></p><p>Bei Timeboxes von 30min bis 45min lassen sich Fortschritte sogar quasi zwischendurch erzielen.</p><p>Wie gesagt: Es geht bei dieser Art fixer, minimaler Budgets nicht um die Herstellung von Lösungen, sondern um Fokus und garantierten Fortschritt in Form eines Wertzuwachses.</p><h3>Struktur der Lieferung</h3><p>Wenn aber mit Budgets keine Lösungen mehr geliefert werden sollen, was dann?</p><p>Die Umkehrung der Budgetverhältnisse führt aus meiner Sicht dazu, dass Aufgaben kein „monolithisches“ Ergebnis mehr haben, sondern ein strukturiertes.</p><p>Die übliche, nicht agile Transformation lautet: (Aufgabe,Budget) -&gt; Lösung</p><p>In der Agilität verändert sie sich jedoch zu:</p><blockquote><p>Aufgabe -&gt; (Resultat, Backlog)</p></blockquote><p>Die Lieferung am Ende jedes vorfixierten Budgets, das deshalb nicht mehr auf der linken Seite der Transformation auftaucht, ist ein Tupel! Das ist von allergrößter Wichtigkeit. Das ermöglicht Fortschritt ohne Lösungszwang.</p><ul><li><strong>Resultat</strong>: eine zielführende Veränderung an Artefakten im Code-Repository.</li><li><strong>Backlog</strong>: eine Liste von Aufgaben, die sich aus der Arbeit an der ursprünglichen Aufgabe ergeben.</li></ul><p>Jede Aufgabe führt innerhalb des Budgets also garantiert zu einem Wertzuwachs. Den bezeichnet der Resultatsanteil der Lieferung. Zielführende Veränderungen am Code-Repository, d.h. solche, die es einer Lösung der Aufgabe näher bringen, oder solche, die die Korrektheit bzw. Wandelbarkeit erhalten oder erhöhen, sind per definitionem wertvoll.</p><p>Der Resultatsanteil ist so groß, wie es die Konzentration innerhalb des Budgets kombiniert mit der Kompetenz zulässt.</p><p>Darüber hinaus stellt aber auch das Backlog einen Wert dar. Der besteht nicht in Artefaktänderungen, sondern in Erkenntnissen. <em>Weil</em> keine Lösung mehr innerhalb des Budgets möglich oder auch nur angestrebt ist, müssen Erkenntnisse, die auf dem Weg zur Lösung hin entstehen, explizit gemacht werden. Sie sind nicht mehr ungreifbar in einem Kopf oder in der informellen Kommunikation zwischen Entwicklern, sondern hinterlassen eine nachvollziehbare Spur.</p><p>Das Backlog einer Lieferung wird Teil des Gesamtbacklogs. Dessen Einträge stehen ständig zur Disposition. Der Kunde kann also jederzeit den einen hoch priorisieren oder den anderen streichen. Es entsteht durch die Aufgabe der Lösungslieferung deshalb sichtbare Freiheit für die Steuerung. Verschwendung durch Planverfolgung ist nicht mehr nötig.</p><p>Inhalt des aus einer Aufgabe resultierenden Backlogs können schlichte Folgeaufgaben sein, die Aspekte der ursprünglichen adressieren, die noch nicht in der Timebox geschafft wurden. Darüber hinaus sind nicht nur erlaubt, sondern sogar gewünscht Aufgaben, die über die unmittelbare Aufgabe hinaus weisen. Vielleicht wurde während der Aufgabenbearbeitung ein Bug gefunden? Das ist eine Information, die ins Backlog gehört. Ihn in der Timebox zu fixen würde die eigentliche Aufgabenumsetzung behindern. Oder die Aufgabe konnte gar nicht erst solide begonnen werden, weil der Code schwer verständlich ist? Das sollte mit einer Refaktorisierungsaufgabe im Backlog protokolliert werden. Oder der Erlediger der Aufgabe konnte sich keinen Reim auf einen Teil der Dokumentation machen? Dann gehört eine Aufgabe ins Backlog, die eine Verbesserung der Dokumentation anfordert.</p><p>Bug, Sauberkeitsmangel, Verständnishindernisse: all das sind wichtige Informationen für die Softwareentwicklung. Solche Mängel eher stillschweigend von einzelnen Entwicklern nebenbei kompensieren zu lassen, führt erstens zu einer Überlastung der Einzelnen, zweitens zu Unzufriedenheit, weil damit die Lösungsfindung innerhalb des üblichen Budgets behindert wird, drittens zu einem kontinuierlichen Rückschritt der Produktivität.</p><p>Gerade wo kontinuierliche Verbesserung auf dem Banner steht wie bei der Agilität, kann es nicht sein, dass „unterwegs“ gewonnene Erkenntnisse nicht transparent gemacht werden. Das ist jedoch der Fall, solange Lösungen mit großzügigen Budgets erarbeitet werden sollen. Die unselige Verquickung von (Scope, Budget) fördert die lokale Optimierung – die alsbald zu einer globalen Verschlechterung führt. So viel kann man gar nicht Retrospektiven reflektieren, dass man all die en passant gewonnenen Erkenntnisse und irgendwie kompensierten oder umgangenen Probleme finden und verarbeiten könnte. Eine Retrospektive findet schlicht zu spät und zu weit weg vom Geschehen statt.</p><p>Wenn allerdings Erkenntnisse zur Lieferung gehören… dann ändert sich alles. Dann gibt es eine Motivation für jeden Entwickler, sie zu gewinnen. Voraussetzung dafür ist allerdings die Aufgabe des Lösungsversprechens und die Minimierung der Timebox.</p><p>Sehen Sie es so: Softwareentwicklung ist eine forschende Tätigkeit. Lieferungen an den Kunden sind darin Experimente, die eine Hypothese über die Anforderungen und eine dazu passende Lösung bestätigen oder widerlegen. Und zur Forschung gehört es, Erkenntnisse zu publizieren. Das geschieht hier mittels des Backlogs als Teil der Lieferung und anschließend in Form von weiteren Resultaten.</p><p>Diese Art der Softwareentwicklung nenne ich <strong>resultatsorientiert</strong> (oder: <em>Results-Oriented Software Development (ROSD)</em>) und wurde dazu angeregt durch die Beschäftigung mit <a href="http://www.xdsd.org" target="_blank" rel="noopener noreferrer">XDSD (eXtremely Distributed Software Development)</a>.</p><p>Übliches Vorgehen ist schmerzhaft lösungsorientiert. Echt agiles Vorgehen, so meine ich, ist hingegen resultatsorientiert. Oder etwas mehr fürs Management formuliert: agile Softwareentwicklung ist wertorientiert. Denn auch wenn der Blick zunächst zu den Resultaten geht, stellen die Backlogs der Lieferungen ebenfalls Wert dar. Sie tragen dazu bei, dass die Entwicklung nicht stehenbleibt. Fortschritt wird gemacht!</p><p>Bei ROSD erwächst aus einer initialen Aufgabe ein Baum an weiteren Aufgaben, an dessen Ästen Resultate als Früchte hängen. Ist das nicht ein schönes Bild? ;-)</p><p>Wie weit der Kunde einen Resultatsbaum wachsen lässt, wie viele Früchte er davon ernten will, bis sein Lösungskorb voll ist, das entscheidet er. Er kann den Baum wild sprießen lassen oder ihn beschneiden.</p><p>Über den Fortschritt des Resultatswachstums wird der Kunde mit jeder Lieferung informiert. Er bewegt sich also auf einem Strom von Wertzuwächsen, in dem er steuern kann. Abgerechnet wird stets das fixe, kleine Budget, also pro Resultat. Geld für glasklare Leistung bei voller, feingranularer Kontrolle. Was will der Kunde mehr?</p><p>—</p><p>In diesem Sinne beende ich auch diesen Artikel. Ich hatte mir dafür eine Timebox eingerichtet, die nun ausgefüllt ist. Eine komplette Beschreibung dessen, was ich mir unter wahrhaft agiler Softwareentwicklung vorstelle, habe ich Ihnen darin nicht liefern können. Ich bin untröstlich, keine Lösung für Ihre Probleme geliefert zu haben ;-) Doch selbst wenn das schön gewesen wäre, es war nicht mein Ziel. Stattdessen habe ich Ihnen Denkanstöße gegeben - ob Sie mit mir übereinstimmen oder nicht ;-) Das sind meine Resultate für Sie.</p><p>In meinem Backlog stehen nun weitere Themen, die ich in dem einen oder anderen Artikel noch abhandeln will. Wie steht es z.B. mit der Teamorganisation bei einer ROSD-Entwicklung? Oder woher weiß man, wie viel ein ROSD-Projekt kostet?</p><p>Stay tuned!</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/agilitaet/">Agilität</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/high-value-team/">High Value Team</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/homepage-ralfw-de/das-agile-manifest-unter-der-lupe/" class="invert post__nav-link" rel="prev"><span>Previous</span> Das Agile Manifest unter der Lupe</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/homepage-ralfw-de/bequeme-abstraktion-ganz-konkret/" class="invert post__nav-link" rel="next"><span>Next</span> Bequeme Abstraktion ganz konkret </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/homepage-ralfw-de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>