<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dependencies Flow Down Abstractions - One Man Think Tank</title><meta name="description" content="Dependencies are the bane of software development. They make code rigid, difficult to understand, and hard to test. If we want to do better we need to deal better with dependencies. Of course quite some efforts have been made in this direction. The SOLID principles&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/homepage-ralfw-de/dependencies-flow-down-abstractions/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/homepage-ralfw-de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/homepage-ralfw-de/feed.json"><meta property="og:title" content="Dependencies Flow Down Abstractions"><meta property="og:image" content="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.19.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Dependencies are the bane of software development. They make code rigid, difficult to understand, and hard to test. If we want to do better we need to deal better with dependencies. Of course quite some efforts have been made in this direction. The SOLID principles&hellip;"><meta property="og:url" content="https://ralfw.github.io/homepage-ralfw-de/dependencies-flow-down-abstractions/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/homepage-ralfw-de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/homepage-ralfw-de/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/homepage-ralfw-de/dependencies-flow-down-abstractions/"},"headline":"Dependencies Flow Down Abstractions","datePublished":"2018-07-23T14:28","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.19.png","height":664,"width":934},"description":"Dependencies are the bane of software development. They make code rigid, difficult to understand, and hard to test. If we want to do better we need to deal better with dependencies. Of course quite some efforts have been made in this direction. The SOLID principles&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/homepage-ralfw-de/"><img src="https://ralfw.github.io/homepage-ralfw-de/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/homepage-ralfw-de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/homepage-ralfw-de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/homepage-ralfw-de/test-first-codierung/" target="_self">Test-first Codierung</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing</a></li></ul></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/testimonials/" target="_self">Testimonials</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/" target="_self">Blog</a></li><li class="has-submenu"><a href="https://ralfw.github.io/homepage-ralfw-de/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/homepage-ralfw-de/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/data-privacy-policy-2/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.19.png" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="664" width="934" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2018-07-23T14:28">23.07.2018</time></div><h1>Dependencies Flow Down Abstractions</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/homepage-ralfw-de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Dependencies are the bane of software development. They make code rigid, difficult to understand, and hard to test. If we want to do better we need to deal better with dependencies.</p><p>Of course quite some efforts have been made in this direction. The <a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">SOLID principles</a> are trying to give good advice: Use the Dependency Inversion Principle! And patterns like „<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="noopener">MVC</a>“ or „<a href="https://dzone.com/articles/layered-architecture-is-good" target="_blank" rel="noopener">layered architecture</a>“ or „<a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank" rel="noopener">Hexagonal Architecture</a>“ or „<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">Clean Architecture</a>“ are trying to do good by prescribing a certain use of dependencies.</p><p>This is all good and well - but unfortunately misses the point, I fear. And that’s why even code that’s based on SOLID and one of these patterns quickly becomes hard to change.</p><p>I don’t know when things started to go bad (or why they never really started out good) with dependencies. Maybe it’s rooted in decades of scarcity in memory and computing power? Maybe the kind of spaghetti code we see despite all these efforts is a kind of premature optimisation? I don’t know.</p><p>But one thing has become clear to me: We need to get to the bottom of this. We need to stop kidding ourselves. SOLID is definitely not enough - or even outright harmful.</p><p>So much for my rant to unsettle you ;-) Now let me substantiate my view.</p><h2>What kind of dependencies?</h2><p>First let me make clear what kind of dependencies I’m talking about.</p><p>Software has two sides: behaviour and data. Behaviour is about action, about transformation. Behaviour is what you can observe. When you enter data into a program it responds with data. That’s the software’s behaviour. It’s always about input-to-output transformation. Object-orientation has not changed a bit of that.</p><figure class="alignnone wp-image-1710"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.54.57-300x124.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.54.57-300x124-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.54.57-300x124-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.54.57-300x124-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.54.57-300x124-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.54.57-300x124-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.54.57-300x124-2xl.png 1600w" alt="" width="447" height="184"></figure><p>Software is a diligent servant. It executes our requests stated in the form of data by transforming the data, by getting additional data from resources, by sending data to resources, and finally by responding with some data.</p><p>Data in itself is passive. It does not work, but is worked on and with. Data flows through processing steps and gets transformed. Data sits around waiting as state. It’s read from (re)source, it’s written to resources/sinks.</p><p>Dependencies can exist between a) parts of behaviour and between b) parts of data. And they can exist between c) parts of behaviour and parts of data.</p><ul><li>Example for a): Function <code>f()</code> calls function <code>g()</code></li><li>Example for b): Data structure <code>p{}</code> contains a reference to data structure <code>a{}</code>.</li><li>Example for c): Function <code>f()</code> receives data of structure <code>p{}</code> as input or function <code>g()</code> access global state of structure <code>a{}</code>.</li></ul><p>Dependency means, one part cannot do its job without the other. Or one part cannot be fully understood without the other. Or one part is incomplete without the other.</p><p>These are tangible, physical dependencies. But there are also intangible, logical dependencies. For example: Function <code>f()</code>might depend on the data in structure <code>p[]</code> to be sorted. This is important to show correct behaviour at runtime, but at compile time it is hardly visible and cannot be checked. Even if you write a test for that it’s not as clear cut as a physical dependency - because you simply can forget to write this test.</p><p>Now, what I’m (primarily) concerned with here are tangible dependencies between <em>behavioural</em> parts of software. That’s the realm of SOLID and design patterns of all sorts.</p><p>I want to focus on functions calling other functions, and <a href="http://flow-design.org/modulehierarchy" target="_blank" rel="noopener">modules</a> containing functions calling functions from the same or other modules.</p><h2>The purpose of dependencies</h2><p>How are dependencies used in behaviour creation today? The first description coming to my mind is: unsystematically.</p><p>A developer lets a function call another function whenever she likes. Maybe the motivation is re-use: some problem has already been solved and the solution wrapped into a function - why not call thi function instead of solving the problem again? Maybe the motivation is better understandability: the <a href="http://flow-design.org/logic" target="_blank" rel="noopener">logic</a> inside a function for solving a problem becomes too convoluted, so the developer extracts a part of it into a separate functions which the previous function then calls.</p><p>Although these and other reasons for letting functions call other functions are noble, I think such use is still unsystematic. My reason for that: there is no clear understanding of what the <em>purpose</em> of behavioural dependencies is. What are they there for in the first place? Decades ago they were means to save memory. But today?</p><p>The purpose of a wall is to separate space. The purpose of a lightbulb is to provide visibility of the surroundings. The purpose of glue is to keep things stuck together. What’s the purpose of behavioural dependencies?</p><p>Here’s my answer:</p><blockquote><p>The purpose of behavioural dependencies is to abstract by integration (or composition).</p></blockquote><p>Let me explain:</p><p>When you see an apple, an orange, and a cherry you see… fruits. „Fruit“ is an abstraction. It’s an <em>abstraction by aggregation</em> from a set of concrete things (or details) to help you make sense of the world. „Fruit“ is a category; it’s not inherent in an apple or a cherry. You make it up on the basis of some similarities you see between apple, orange, and cherry.</p><figure class="alignnone wp-image-1711"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.04-1024x462-2xl.png 1600w" alt="" width="556" height="251"></figure><p>The category „fruit“ now depends on its elements. Without elements it vanishes. Should the perceived similarities be a misunderstanding the category does not provide any help anymore.</p><figure class="alignnone wp-image-1712"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.55.15.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.15-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.15-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.15-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.15-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.15-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.15-2xl.png 1600w" alt="" width="365" height="361"></figure><p>When you see a car you see… a whole. You don’t usually see tires, hull, motor, seats, steering wheel etc. as separate parts. Rather you see the car as the relevant and useful thing it is to you. And that’s an <em>abstraction by integration</em>. The term „car“ abstracts from all the different parts and their relationships. The car is a composition of compositions of compositions which as a whole provides some service to you. It makes something possible (or at least easier) which a heap of parts wasn’t able to. A car is more than the sum of its parts. That’s what the power of integration is!</p><figure class="alignnone size-large wp-image-1713"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.24-1024x535-2xl.png 1600w" alt="" width="720" height="376"></figure><p>Aggregation just draws a line around stuff. „Fruit“, „Seed“, „Vegetable“ are just heaps to put on this or that according to some similarity.</p><p>But integration not just draws a line around stuff, it also connects stuff. „Car“ describes more than a heap. It also stands for certain relationships between what’s on the heap. A car needs to be assembled.</p><p>Aggregations assemble very similar parts into a whole. But integrations assemble very different parts into a whole. That’s the point of integration: it creates something new by connecting what has been assembled.</p><p>Integration is a tool of creation. Aggregation is a tool of analysis.</p><p>But of course, as aggregations only make sense with parts on their heap, so make integrations only sense with correctly assembled parts. Integrations depend on their parts.</p><p>To make it very clear let me <em>abstract by distillation</em> from this. Let me extract the essence from aggregation and integration for my purpose:</p><blockquote><p>In abstractions dependencies point from the whole to the parts</p></blockquote><p>Or to say it the other way around: the purpose of dependencies in abstractions is to tie the parts to the whole.</p><p>The part - an apple or a tire - exists perfectly well without any abstraction. It does not depend on it. But the category „fruit“ or the tool „car“ don’t make sense, are not useful, cannot exist without their parts. Thus dependencies point downwards from the whole, from the abstraction towards the parts, to the details.</p><p>And there are no dependencies between the parts either! An apple exists perfectly well without an orange or a cherry. Also a spark plug does not need for its existence or even functionality a steering wheel or a trunk or a tail light.</p><p>There is no existential dependency between parts of a whole. They only come together with regard to a whole. The whole spans an umbrella of meaning over them.</p><p>What a spark plug depends on is a current as input. But it does not care where that’s coming from. Likewise a tire depends on some force to turn it. But it does not care where that’s coming from or how it’s generated.</p><p>Let me emphasise it again:</p><blockquote><p>In abstractions there are only dependencies from the top of the whole down to the parts. There are no dependencies between the parts.</p></blockquote><p>Integration is how we build tools. Progressive integration is how things become easier and easier to use. That’s what I see around me every day.</p><p>Hence I strongly believe: In order to build good software we should stick to this principle found in cars, computers, drills, blenders, fountain pens, and even organisms. Let me call this the</p><blockquote><p>Dependency Follows Abstraction (DFA) principle</p></blockquote><h2>Levels of abstraction</h2><p>Abstraction, or to be more precise: integration is all around us. Integration (or composition) is what delivers ease of use every day. You don’t have to care about a gazillion „moving pieces“! Just step into your car, turn the key, and drive off. Whatever is happening behind the scene is abstracted away. You’re interacting with integrations of integrations of integrations… It’s compositions all the way down.</p><p>And that’s the point: there is not just one level of abstraction. Today’s useful and convenient integrations are deep, deep hierarchies of dependencies.</p><p>At the top level you might interact with a car. That’s the whole integrating all the parts like tire, seat, steering wheel, cigarette lighter, engine, transmission etc.</p><p>But those parts are not monolithic. A car manufacturer might buy them as smaller wholes and assemble them into a new whole, the car. But for the manufacturer of a seat the seat is not a monolith, but again a whole consisting of parts.</p><p>The car seat abstraction might depend on parts like head rest, back rest, cushion etc.</p><p>And a head rest might be an integration itself. It depends on guides, screws, cover, a tube etc.</p><p>You see what I mean? It’s integrations integrating integrations across many levels. And only at the bottom of this integration tree sit some monoliths.</p><figure class="alignnone size-large wp-image-1714"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.34-1024x523-2xl.png 1600w" alt="" width="720" height="368"></figure><p>Those atomic elements don’t consist of any manufactured parts. Their elements are molecules and atoms - but that’s not relevant from the integration point of view of a car manufacturer, for example.</p><p>Take this integration hierarchy:</p><ul><li>W<ul><li>P1<ul><li>SP1.1</li><li>SP1.2</li></ul></li><li>P2<ul><li>SP2.1<ul><li>SSP2.1.1</li><li>SSP2.1.2</li></ul></li><li>SP2.2</li><li>SP2.3</li></ul></li><li>P3</li></ul></li></ul><p>A Whole consist of Part 1 to 3. But Parts 1 and 2 are smaller wholes by themselves: they consist of Sub-Parts. Those sub-parts are of no interest to the manufacturer of W. W is only concerned with integrating Part 1..3. And Sub-Part 2.1 again consists of Sub-Sub-Parts!</p><p>Whatever the purpose of W is it is fully represented by W. W has the highest level of abstraction. It hides all the details (parts) which are necessary to achieve the purpose.</p><p>But the purpose is also present on the next lower level: P1+P2+P3 together also represent the purpose - but on a lower level of abstraction. P1+P2+P3 plus their relationships serve the purpose like W does. But who wants to deal with so much detail?</p><p>On the next lower level of abstraction are SP1.1+SP1.2 + SP2.1+SP2.2+SP2.3 + P3. They together with their relationships also represent the purpose. In fact it’s them „working together“ which do the job.</p><p>Or the lowest level of abstraction, where most detail is present: SP1.1+SP1.2 + SSP2.1.1+SSP2.1.2 +SP2.2+SP2.3 + P3.</p><p>Abelson/Sussman call these levels of abstraction <em>strata</em>. Hierarchies of this kind show a <a href="http://ccd-school.de/2017/06/stratified-design-over-layered-design/" target="_blank" rel="noopener">stratified design</a>: more useful „stuff“ is built from parts which is less useful because of its larger generality.</p><figure class="alignnone size-large wp-image-1715"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.44-1024x484-2xl.png 1600w" alt="" width="720" height="340"></figure><p>Heterogeneous, but complementary parts are assembled in a manner as to yield some larger whole serving a more specific purpose than the parts: a car has much more specific use cases than a screw in one of its seats or the rubber in one of its tires.</p><p>A perfect example of this principle of building in software is a communication stack like the <a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI model</a>: on every level (stratum) the purpose is the same; they are all about communication. But with each lower the means of communication become more fine grained. From level to level the abstraction decreases and the number of details to know increases.</p><p>Today communication between two processes, even on two machines across the world is easy: just issue a HTTP call. In C# it might look like this:</p><pre><code>WebClient client = new WebClient();
var downloadString = client.DownloadString("http://www.gooogle.com");
</code></pre><p>Think about the huge amount of details hidden by this abstraction! Think about what you would have had to do 10 or 20 years ago. At the lowest level of abstraction things might not have changed that much since then: streams are involved, TCP connections are necessary etc. But over the years integration layers were heaped on integration layers to finally make it that easy.</p><p>That’s abstraction I like! That’s a use of dependencies which makes a lot of sense to me!</p><p>Higher levels of abstractions using parts from lower levels of abstraction to provide useful services. Great!</p><p>Please note: „using“ implies knowing which implies depending on. The high level (of abstraction) class <code>WebClient{}</code> builds on the lower level class <code>HttpWebRequest{}</code>, i.e. a <code>WebClient{}</code> object depends on a <code>HttpWebRequest{}</code> object. And that in turn depends on even lower level objects and so on. All the way down to byte streams and TCP sockets. And below that hardware.</p><p>Dependencies are inevitable to achieve this. Dependencies pointing down from higher strata to lower strata are necessary, they are good, we need to keep them. They are even easy to understand.</p><p>But now see how behavioural dependencies are used in software development…</p><h2>Dysfunctional dependencies</h2><p>Let me remind you: what is more abstract depends on parts which are less abstract. But these less abstract parts do not (!) depend on each other. Parts assembled into a whole just depend on certain input. And they produce certain output. Input might be fuel or electricity or a force, output might be heat or pressure or sound. But no screw „knows“ about another screw, no tire „knows“ about another tire, no head rest „knows“ about a steering wheel etc. There are no (!) dependencies between parts of an integrating whole. That’s how our mechanical and electrical tools are design. From bicycle to hair blower to train to chemical plant.</p><p>Just software development begs to differ. Just in software development we think we should not follow this time tested principle.</p><p>Look at the dependencies in these popular patterns:</p><h3>Model-View-Controller (MVC)</h3><figure class="alignnone wp-image-1716"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.55.55.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.55-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.55-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.55-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.55-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.55-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.55.55-2xl.png 1600w" alt="" width="279" height="299"></figure><p>Image source: <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller%0D%0A" target="_blank" rel="noopener">Wikipedia</a></p><p>The Controller depends on the Model which it manipulates. The Model depends on the View which it updates. Each of the boxes knows about the next one. They are connected by dependencies. That’s what the arrows are about. They don’t show data flowing, but runtime dependencies, which in OO means object references.</p><p>But do those dependencies follow the DFA? I don’t think so. The reason is simple: there is no whole tangible for the user. The whole of her user experience entails interaction with two boxes: Controller - to issue requests, and View to observe responses. The whole lives just in the head of the user. But there is no whole in the code. Rather, Controller, Model and View are complementary parts of the conceptual whole. Hence they should not depend on each other.</p><p>Or ask yourself: Does a Controller do the same as a Model does, just on a higher level of abstraction? Does a Model have the same purpose as a View, just on a higher level of abstraction? To me the answer to both questions is a wholehearted No. Controller, Model, and View are all very different. And it’s this difference which makes them parts of some whole. Call that the application, if you like. But please realise there is no representation of an application in the MVC model; let alone an application which as a whole has dependencies to Controller, Model, and View as its parts.</p><p>And so the dependencies to me are dysfunctional. They create pain: they make all dependent parts more difficult to understand and harder to test.</p><h3>Layered architecture</h3><figure class="alignnone wp-image-1717"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.02.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.02-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.02-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.02-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.02-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.02-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.02-2xl.png 1600w" alt="" width="577" height="423"></figure><p>Image source: <a href="http://www.hanselman.com/blog/AReminderOnThreeMultiTierLayerArchitectureDesignBroughtToYouByMyLateNightFrustrations.aspx%0D%0A" target="_blank" rel="noopener">Scott Hanselman at Microsoft</a></p><p>Upper layers depend on lower layers. Layers depend on cross-layer concerns. I added the red arrows to make these dependencies very clear.</p><p>Do those dependencies follow the DFA? I don’t think so. Again, ask yourself: Does a box like Business Component do the same as for example Security - just on a higher level of abstraction?</p><p>There are just two boxes of which I might think of as a whole: UIC and UIP. Behaviour is created by processes, i.e. by stepwise transformation from input to output. Behind each button or menu item a user can click such a process sits and waits to execute a request.</p><p>The UIC could be viewed as the top representation of what a software can do. It’s all the details hidden behind a button.</p><p>Then on the next level multi-step processes represents what a software can do. That’s a more detailed view of how the purpose is fulfilled.</p><p>But beneath that I don’t see further levels of abstraction but just parts for the process level of abstraction. Even more so with the orthogonal concerns.</p><p>Bottom line: most of the dependencies in the layered architecture are dysfunctional. They make understanding and testing more difficult. No small wonder they have to be defused by applying the DIP (and then <a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">Inversion of Control (IOC)</a>) - which creates accidental complexity.</p><h3>Clean Architecture</h3><figure class="alignnone wp-image-1718"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.11.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.11-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.11-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.11-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.11-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.11-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.11-2xl.png 1600w" alt="" width="562" height="412"></figure><p>Image source: <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html%0D%0A" target="_blank" rel="noopener">Robert C. Martin</a></p><p>Outer circles depend on inner circles. Technology depends on domain; let the pretty unmovable and crucial not be tainted by the fleeting concrete. That sounds reasonable. At least until you compare it with the DFA.</p><p>Do Devices or the Web do the same as Entities, just on a higher level of abstraction? I don’t think so. Or if they did the same on different levels of abstraction, the Entities would need to depend on devices and/or web. Because Entities are more abstract than a DB.</p><p>Or are Presenters on a higher level of abstraction than Use Cases? I don’t think so, either.</p><p>The whole, i.e. purpose of the software, to me is only represented by the Use Case circle. Use Cases are like processes: they tie together different parts to create a larger behaviour. A single intent of the user is implemented by a Use Case. But the rest then is all details, details, details residing on lower, and still lower levels of abstraction and to be hidden beneath.</p><p>The Clean Architecture is well intentioned, of course. It tries to improve on the layered architecture and unify different concentric approaches.</p><p>Unfortunately it does not solve the problem which has riddled software development for ages: how do arrange dependencies in a reasonable manner. Most of the behavioural dependencies even in the Clean Architecture are dysfunctional - which leads even to more accidental complexity from the application of DIP/IoC. (I might even say that the purpose behind the Clean Architecture like the Hexagonal Architecture before it is to let dependencies contradict the DFA. Both clearly state that the concrete, the details should depend on the essential. That both focus on compile time dependencies and not runtime dependencies does not mitigate the contradiction.)</p><p>But don’t take my word for it. Even Robert C. Martin says in his book <em>Clean Architecture</em> about a class diagram he presented: „Much of the complexity in that diagram was intended to make sure that the dependencies between the components pointed in the correct direction.“</p><p>If the DFA was observed this would not happen, at least not to this degree. The reason: the direction of dependencies would be natural and helpful.</p><h2>Moving towards stratified designs</h2><p>Robert C. Martin did not only come up with the Clean Architecture, but also with what he called <a href="https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html" target="_blank" rel="noopener">screaming architecture</a>.</p><blockquote><p>Your architectures should tell readers about the system, not about the frameworks you used in your system.</p></blockquote><p>I like that idea of his very much. First and foremost architecture should express the purpose of a software system. That is, I think, in perfect alignment with the DFA and stratified design.</p><p>The patterns presented, though, pretty much contradict this idea. Because in them frameworks are precisely positioned, be it the View in MVC or the Presentation Layer or Devices in the Clean Architecture. The first thing you’re told when looking for guidance on how to structure your software is that you need to find a place for all the frameworks. If screaming architectures are to be desired, then why put frameworks so squarely into the patterns?</p><p>Sure, the pattern advice continues by telling how those frameworks are best connected to other parts of the software. And some other parts are even mentioned as to not be forgotten. The Clean Architecture puts the purpose even in the center of its depiction.</p><p>Nevertheless what’s completely forgotten is that first and foremost it’s about „the system“ as Robert C. Martin calls it. Or I’d say „the purpose“ or „the behaviour“.</p><p>A fundamental pattern for software architecture should not even mention any frameworks. Or if they are mentioned, then lump them all together. „Yes, there are frameworks you’ll need to use, but focus on the purpose first! Focus on abstractions!“</p><p>A fundamental pattern for software architecture should emphasise what has been the formula for success in all the rest of the world: abstraction. Or more specifically: abstraction by integration. Because only through abstraction by integration (or composition) large systems are built from small systems. Coarse grained specific „components“ on higher levels of abstraction get assembled from finer grained more general „components“ on lower levels of abstraction.</p><p>Think of the OSI layers. Think of the layers of abstraction of code itself: on the lowest level there is microcode, above that machine code, above that some virtual machine code (e.g. .NET IL, Java JVM), above that 3GL code, above that maybe even some Domain Specific Language. What a success this is: building easier stuff on top of more difficult stuff! Build new behaviour as a whole from „older“, partial behaviour as parts.</p><p>And the dependencies only and always point down, down, down from abstraction to detail, from whole to part.</p><p>That (!) to me needs to be expressed by a fundamental pattern for software architecture:</p><figure class="alignnone wp-image-1719"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.19.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.19-2xl.png 1600w" alt="" width="530" height="377"></figure><p>Please note how all specific concerns like View, Presenter, Entities are gone! That’s not a bug, but the main feature of this pattern. This way the focus is on what’s paramount for clean code development: find good abstractions.</p><p>And by that I don’t mean a couple of data structures loaded up with functionality like in mainstream object-orientaction. No, I mean real levels of abstractions in terms of the solution.</p><p>Pick out one problem from the many that a software facing the user should solve. Example: A Tic Tac Toe game application needs to solve the problem of a player making a move. Upon the player pointing to a cell on the game board, where she wants her next token to appear, the software should behave appropriately.</p><figure class="alignnone wp-image-1720"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.28-1024x143-2xl.png 1600w" alt="" width="562" height="78"></figure><p>Image source: <a href="https://en.wikipedia.org/wiki/Tic-tac-toe%0D%0A" target="_blank" rel="noopener">Wikipedia</a></p><ul><li>The top level abstraction might be called „Make move“.</li><li>The process behind this abstraction then could consist of three stages: accept the coordinates for the token from a player, execute the request to place the token, show the updated game.</li><li>Each processing step then is not only a part, but a whole again. Because each step might be made up of yet smaller steps on a next lower level of abstraction. For example request execution could be made up of: validate the move, place the token, check for a game-over situation, determine the next player.</li></ul><p>That’s stratified design! That’s a design where problems are solved on successively more detailed levels in a very systematic way. It even naturally follows the <a href="http://www.principles-wiki.net/principles:single_level_of_abstraction" target="_blank" rel="noopener">Single Level of Abtraction</a> principle.</p><p>Every stratum mirrors the whole purpose - although in various degrees of granularity.</p><p>Of course frameworks in the end have their place in such architectures. But they don’t depend on higher level „components“, nor do „components“ within the same stratum depend on each other.</p><p>Let me show you what that would mean for the functional „components“ of the above patterns:</p><figure class="alignnone wp-image-1737"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-30-um-08.05.17.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-30-um-08.05.17-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-30-um-08.05.17-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-30-um-08.05.17-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-30-um-08.05.17-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-30-um-08.05.17-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-30-um-08.05.17-2xl.png 1600w" alt="" width="606" height="261"></figure><p>In the MVC pattern a new „authority“ would need to be introduced to represent the overall purpose which then ties together the pattern’s concerns.</p><p>A simplified layer architecture would morph into this:</p><figure class="alignnone wp-image-1722"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.48.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.48-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.48-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.48-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.48-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.48-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.48-2xl.png 1600w" alt="" width="602" height="236"></figure><p>Since the concerns are all on the same level of abstraction another level needs to be put on top of them to tie them together - and to make them independent of each other.</p><p>And finally a somewhat simplified Clean Architecture:</p><figure class="alignnone wp-image-1723"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.56.55.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.55-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.55-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.55-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.55-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.55-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.56.55-2xl.png 1600w" alt="" width="610" height="342"></figure><p>Some dependencies look like in the original definition, eg. Use Cases depending on Entities. But others would look differently, e.g. Presenters not depending on Use Cases or Use Cases depending on Data Access.</p><p>The sum of Controllers, Use Cases, and Presenters has the same purpose as the top stratum. And the sum of Entities and Data Access has the same purpose as the Use Cases. Whereas the integrating „component“ always adds something to the sum of its parts: relationships between the parts.</p><p>But these relationships are not dependencies! Like a spark plug does not depend on a distributor or a valve or a piston. All the parts are just fit together in a productive way by a completely separate whole.</p><h2>Summary</h2><p>The point of the DFA is very systematically about abstraction. No top-down, clockwise, or outside-in dependencies serving some arbitrary shape. The DFA just cares about what’s more abstract vs more concrete, what’s a whole, what’s a detail? Use any shape you like to arrange your „components“ - but focus on the purpose.</p><p>As you see the fundamental pattern for software - or maybe I should call it a meta-pattern? - can be used to accommodate different ideas as to what kind of functional „components“ software should consist of.</p><p>Here’s a stratified design for the Tic Tac Toe game above with a number of „components“ instead of processing steps. For some people it’s more natural to think of software first in terms of nouns instead of verbs (even though software is dynamic and about behaviour).</p><figure class="alignnone wp-image-1724"><img loading="lazy" src="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/Bildschirmfoto-2018-07-23-um-13.57.03.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.57.03-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.57.03-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.57.03-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.57.03-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.57.03-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/115/responsive/Bildschirmfoto-2018-07-23-um-13.57.03-2xl.png 1600w" alt="" width="461" height="316"></figure><p>This I’d call a screaming architecture (albeit a small one). Because not only is the focus on abstractions, but also the size of the boxes somewhat mirrors the amount of code needed to deliver on a respective purpose.</p><p>Here’s a challenge for you: The next time you look at your code and see a dependency between classes or functions think about the DFA. Does the dependency point down from higher abstraction to lower? Or is it a pointer between parts on the same level of abstraction?</p><p>Becoming aware of the DFA is a first step towards cleaner code. That’s my strong belief.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/clean-code-development/">Clean Code Development</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/software-architecture/">Software architecture</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/homepage-ralfw-de/when-to-turn-to-microservices-for-help/" class="invert post__nav-link" rel="prev"><span>Previous</span> When to Turn to Microservices for Help</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/homepage-ralfw-de/koordinieren-ist-nicht-fuehren/" class="invert post__nav-link" rel="next"><span>Next</span> Koordinieren ist nicht Führen </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/homepage-ralfw-de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>