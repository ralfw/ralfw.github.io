<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Don&#x27;t Let Cleaning-Up Go Overboard - One Man Think Tank</title><meta name="description" content="When a tweet pointed me to Radoslaw Sadowski's 'Learn how to make a good code by bad example' I was excited to see how the author would go about showing how to clean-up brownfield code. Although his example looked simplistic, it turned out to be&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/dont-let-cleaning-up-go-overboard/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/feed.json"><meta property="og:title" content="Don't Let Cleaning-Up Go Overboard"><meta property="og:image" content="https://ralfw.github.io/media/posts/51/img_56e909d58e49b.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="When a tweet pointed me to Radoslaw Sadowski's 'Learn how to make a good code by bad example' I was excited to see how the author would go about showing how to clean-up brownfield code. Although his example looked simplistic, it turned out to be&hellip;"><meta property="og:url" content="https://ralfw.github.io/dont-let-cleaning-up-go-overboard/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/dont-let-cleaning-up-go-overboard/"},"headline":"Don't Let Cleaning-Up Go Overboard","datePublished":"2016-03-16T10:25","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/media/posts/51/img_56e909d58e49b.png","height":790,"width":1206},"description":"When a tweet pointed me to Radoslaw Sadowski's \"Learn how to make a good code by bad example\" I was excited to see how the author would go about showing how to clean-up brownfield code. Although his example looked simplistic, it turned out to be&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/"><img src="https://ralfw.github.io/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/test-first-codierung/" target="_self">Test-first Codierung</a></li><li><a href="https://ralfw.github.io/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design</a></li><li><a href="https://ralfw.github.io/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing</a></li></ul></li><li><a href="https://ralfw.github.io/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/testimonials/" target="_self">Testimonials</a></li><li><a href="https://ralfw.github.io/" target="_self">Blog</a></li><li class="has-submenu"><a href="https://ralfw.github.io/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/data-privacy-policy/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/media/posts/51/img_56e909d58e49b.png" srcset="https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-xs.png 300w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-sm.png 480w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-md.png 768w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-lg.png 1024w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-xl.png 1360w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="790" width="1206" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2016-03-16T10:25">16.03.2016</time></div><h1>Don&#x27;t Let Cleaning-Up Go Overboard</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>When a tweet pointed me to Radoslaw Sadowski's "<a href="http://www.codeproject.com/Articles/1083348/Csharp-BAD-PRACTICES-Learn-how-to-make-a-good-code" target="_blank">Learn how to make a good code by bad example</a>" I was excited to see how the author would go about showing how to clean-up brownfield code. Although his example looked simplistic, it turned out to be quite interesting. It's about some price discount calculation:</p><pre class="lang:c# decode:true">public class Class1
{
  public decimal Calculate(decimal ammount, int type, int years)
  {
    decimal result = 0;
    decimal disc = (years &gt; 5) ? (decimal)5/100 : (decimal)years/100; 
    if (type == 1)
    {
      result = ammount;
    }
    else if (type == 2)
    {
      result = (ammount - (0.1m * ammount)) - disc * (ammount - (0.1m * ammount));
    }
    else if (type == 3)
    {
      result = (0.7m * ammount) - disc * (0.7m * ammount);
    }
    else if (type == 4)
    {
      result = (ammount - (0.5m * ammount)) - disc * (ammount - (0.5m * ammount));
    }
    return result;
  }
}</pre><p>I liked how the author pointed out deficiencies and started removing them through simple refactorings.</p><p>This went well for the first half of his article – but then turned really bad. To my taste he went overboard following the "Thou shalt apply all design patterns thou knowest" commandment. Sad, very sad.</p><p>Just compare the number of lines of code:</p><ul><li>Original brownfield solution: 25 lines of code (LOC)</li><li>Reasonably refactored solution: 55 LOC</li><li>Final solution: 118 LOC</li></ul><p>By this the author says, that roughly 5 (!) times the size of the original dirty code is the pinnacle of cleanliness. Is he serious? And he even does this in the name of the DRY principle (see STEP VII in the article) and contrary to his insight <em>"We should write as short and simple code as it is possible. Shorter code = less possible bugs, shorter time of understanding the business logic."</em> (see STEP VIII).</p><p>What has gone wrong in the Clean Code camp?</p><h2>A Different Approach</h2><p>But I don't want to just bemoan this well meant attempt gone overboard. Let me try to improve upon it.</p><h3>Test First</h3><p>As much as I liked the first refactorings of the author, I disagree that's where you should start when cleaning up dirty code.</p><p>The first thing you always should do: Put the code to refactor under test. If there aren't any automated tests yet, set up at least a couple of integration tests. That's what I did when I took my stab at this refactoring problem. Here's the tests I came up with:</p><pre class="lang:c# decode:true">[TestCase(100.0, 1, 1, 100.0)]
[TestCase(100.0, 2, 1, 89.1)]
[TestCase(100.0, 3, 1, 69.3)]
[TestCase(100.0, 4, 1, 49.5)]
[TestCase(100.0, 0, 1, 0)]
[TestCase(100.0, 1, 6, 100.0)]
[TestCase(100.0, 2, 6, 85.5)]
[TestCase(100.0, 3, 6, 66.5)]
[TestCase(100.0, 4, 6, 47.5)]
[TestCase(100.0, 0, 6, 0)]
public void Test_discounting (decimal amount, int type, int years, decimal expected)
{
	var sut = new Class1 ();
	var result = sut.Calculate (amount, type, years);
	Assert.AreEqual (expected, result);
}</pre><p>I looked at the different paths through the code and tried to find simple test cases for them. They reflect how the code currently works – whether that's ultimately correct or not.</p><p>After that all refactoring had to produce code which complied with these formalized requirements.</p><p>Interestingly the author's final version does not pass this test. It fails on type 1 accounts ("not registered") to which it incorrectly applies a loyality discount.</p><p>How come? The author did not realize the change in the semantics of the code during refactoring, when he moved application of the loyality discount to the end of the function.</p><p>He still gets it right in an intermediate version, though:</p><pre class="lang:c# mark:10-11,13-14 decode:true">public class DiscountManager
{
  public decimal AddDiscount(decimal price, AccountStatuses accountStatus, int timeOfHavingAccountInYears)
  {
    decimal priceAfterDiscount = 0;
    decimal discountForLoyaltyInPercentage = (timeOfHavingAccountInYears &gt; Constants.MAXIMUM_DISCOUNT_FOR_LOYALTY) ? (decimal)Constants.MAXIMUM_DISCOUNT_FOR_LOYALTY/100 : (decimal)timeOfHavingAccountInYears/100;
    switch (accountStatus)
    {
      case AccountStatuses.NotRegistered:
        priceAfterDiscount = price;
        break;
      case AccountStatuses.SimpleCustomer:
        priceAfterDiscount = (price - (Constants.DISCOUNT_FOR_SIMPLE_CUSTOMERS * price));
        priceAfterDiscount = priceAfterDiscount - (discountForLoyaltyInPercentage * priceAfterDiscount);
        break;
      case AccountStatuses.ValuableCustomer:
        priceAfterDiscount = (price - (Constants.DISCOUNT_FOR_VALUABLE_CUSTOMERS * price));
        priceAfterDiscount = priceAfterDiscount - (discountForLoyaltyInPercentage * priceAfterDiscount);
        break;
      case AccountStatuses.MostValuableCustomer:
        priceAfterDiscount = (price - (Constants.DISCOUNT_FOR_MOST_VALUABLE_CUSTOMERS * price));
        priceAfterDiscount = priceAfterDiscount - (discountForLoyaltyInPercentage * priceAfterDiscount);
        break;
      default:
        throw new NotImplementedException();
    }
    return priceAfterDiscount;
  }
}</pre><p>The highlighted lines show: a loyality discount only gets applied for registered customers within the <em>switch</em> statement. But later the discount gets applied in all cases:</p><pre class="lang:c# mark:5 decode:true">public decimal AddDiscount(decimal price, AccountStatuses accountStatus, int timeOfHavingAccountInYears)
{
  decimal priceAfterDiscount = 0;
  priceAfterDiscount = _factory.GetAccountDiscountCalculator(accountStatus).AddDiscount(price);
  priceAfterDiscount = _loyaltyDiscountCalculator.AddDiscount(priceAfterDiscount, timeOfHavingAccountInYears);
  return priceAfterDiscount;
}</pre><h3>Design Before Refactor</h3><p>A test could have caught this error. But how to avoid it in the first place during clean-up/refactoring? I suggest you do an explicit design first.</p><p>When I say "design" you don't need to fear a full blown mainstream OO design with UML diagrams. No, it's much, much simpler. The author unwittingly almost did it, when he wrote:</p><figure class="alignnone size-full wp-image-722"><a href="https://ralfw.github.io/media/posts/51/img_56e8419a07670.png"><img loading="lazy" src="https://ralfw.github.io/media/posts/51/img_56e8419a07670.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/51/responsive/img_56e8419a07670-xs.png 300w, https://ralfw.github.io/media/posts/51/responsive/img_56e8419a07670-sm.png 480w, https://ralfw.github.io/media/posts/51/responsive/img_56e8419a07670-md.png 768w, https://ralfw.github.io/media/posts/51/responsive/img_56e8419a07670-lg.png 1024w, https://ralfw.github.io/media/posts/51/responsive/img_56e8419a07670-xl.png 1360w, https://ralfw.github.io/media/posts/51/responsive/img_56e8419a07670-2xl.png 1600w" alt=""></a></figure><p></p><p>Yes, an ordered list like this can be a poor man's design to start with.</p><p>Design is about responsibilities which get translated into modules (i.e. functions and classes among others). And it's about how those responsibilties should be put together to form the overall responsibility. The requirements state a certain behavior which then is produced through collaboration of many parts.</p><p>Despite his "design attempt", though, I don't agree with the author's solution approach.</p><p>There is no calculation algorithm to be determined. And the order of processing steps is wrong – especially if it's supposed to mean the loyality discount is always applied.</p><p>Let's look at the dirty code and highlight the different responsibilities:</p><figure class="alignnone wp-image-725"><img loading="lazy" src="https://ralfw.github.io/media/posts/51/img_56e909d58e49b.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-xs.png 300w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-sm.png 480w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-md.png 768w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-lg.png 1024w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-xl.png 1360w, https://ralfw.github.io/media/posts/51/responsive/img_56e909d58e49b-2xl.png 1600w" alt="" width="600" height="393"></figure><p>I can spot three aspects of which two are badly intertwined:</p><ol><li>The loyality discount is determined.</li><li>The status discount is determined. Only registered users are eligible to status discounts.</li><li>Status discount and loyality discount are applied only if the customer is eligible for a status discount.</li></ol><p>Those aspects need to be retained – but brought in a proper order and cleaned-up. On my way to reach that goal I find it very useful to step back from hard to overlook imperative code. Instead I like to visualize the solution first in a declarative way.</p><p>Here's a simple data flow sketching how the desired behavior can be achieved by a small process of focused steps. The colors of the functional units match the aspects found in the original code:</p><figure class="alignnone wp-image-727 size-full"><img loading="lazy" src="https://ralfw.github.io/media/posts/51/img_56e90c3e8a7db.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.github.io/media/posts/51/responsive/img_56e90c3e8a7db-xs.png 300w, https://ralfw.github.io/media/posts/51/responsive/img_56e90c3e8a7db-sm.png 480w, https://ralfw.github.io/media/posts/51/responsive/img_56e90c3e8a7db-md.png 768w, https://ralfw.github.io/media/posts/51/responsive/img_56e90c3e8a7db-lg.png 1024w, https://ralfw.github.io/media/posts/51/responsive/img_56e90c3e8a7db-xl.png 1360w, https://ralfw.github.io/media/posts/51/responsive/img_56e90c3e8a7db-2xl.png 1600w" alt="" width="1910" height="824"></figure><p>As you clearly can see, a loyality discount now only needs to be determined if the customer if eligible for a (status) discount. Likewise only then a discounted price is calculated.</p><p>Each functional unit now has only a single responsibility. And on top there is another functional unit to integrate them all into a whole – which also is a responsibility of its own.</p><h3>Implement Clean Code Without Frills</h3><p>Such a straightforward easy to understand design sure is easy to implement. Every functional unit ("bubble") becomes a function of its own:</p><pre class="tab-size:2 lang:c# decode:true">public enum AccountStatuses
{
	NotRegistered = 1,
	SimpleCustomer = 2,
	ValuableCustomer = 3,
	MostValuableCustomer = 4
}

public class Discounting
{  
	public decimal Adjust(decimal price, AccountStatuses accountStatus, int yearsLoyal)
	{
		decimal discountedPrice = 0.0m;
		Determine_status_discount (accountStatus,
			statusDiscount =&gt; {
				var loyalityDiscount = Determine_discount_for_loyality (yearsLoyal);
				discountedPrice = Calc_discounted_price (price, loyalityDiscount, statusDiscount);
			},
			() =&gt; discountedPrice = price);
		return discountedPrice;
	}

	void Determine_status_discount(AccountStatuses status, Action&lt;decimal&gt; onEligible, Action onNotEligible) {
		switch (status) {
		case AccountStatuses.NotRegistered:
			onNotEligible ();  break;
		case AccountStatuses.SimpleCustomer:
			onEligible (0.1m); break;
		case AccountStatuses.ValuableCustomer:
			onEligible (0.3m); break;
		case AccountStatuses.MostValuableCustomer:
			onEligible (0.5m); break;
		default:
			throw new NotImplementedException ("Not discount registered for status: " + status.ToString());
		}
	}

	decimal Determine_discount_for_loyality(int yearsLoyal) {
		const decimal MAX_RELEVANT_LOYALITY_YEARS = 5;
		return yearsLoyal &gt; MAX_RELEVANT_LOYALITY_YEARS
					? (decimal)MAX_RELEVANT_LOYALITY_YEARS/100 
					: (decimal)yearsLoyal/100;
	}

	decimal Calc_discounted_price (decimal price, decimal loyalityDiscount, decimal statusDiscount)
	{
		decimal discountedPrice = price;
		discountedPrice -= discountedPrice * statusDiscount; // status is more valuable than loyality
		discountedPrice -= discountedPrice * loyalityDiscount;
		return discountedPrice;
	}
}</pre><p>That's 52 lines of code, i.e. roughly twice as much code as the original. But these 52 lines of code are, well, easy to read and follow the SRP:</p><ul><li><em>Calc_discounted_price()</em>: Calculating a discounted price is two lines of trivial math. It's crystal clear how the discounts are applied. As you can see, the status discount is applied first, which means status is more important than loyality (because it's calculated based on a larger value). In Radoslaw's final code there is no function where this can be seen this clearly.</li><li><em>Determine_discount_for_loyality()</em>: This differs not much from the original. But giving it its own function adds meaning to the one statement and wraps a contract around the responsibility. In case the calculation changes it's easy to spot where to intervene.</li><li><em>Determine_status_discount()</em>: A very, very simple <em>switch</em>-statement suffices to map a status to a discount percentage. Here's where Radoslaw's solution slips into textbook overengineering. What a waste to set up interfaces and factory and strategy classes for a simple mapping! Even a dictionary data structure would do – were there not the special case of the unregistered customer. So what happens if a status discount changes? Alter the percentage in the method. What happens if a new status is introduced? Add it to the <em>enum</em> and add a case in the <em>switch</em>; that's probably 3 lines of code. Very, very easy and straightforward.</li><li><em>Adjust()</em>: This method's responsibility is just to wire-up the data flow. It deliberately does not contain any logic. That's why it probably looks a bit funny to you: no <em>if-then-else</em> in there. Instead the two branches of the data flow are implemented using continuations. This is to follow the <em><a href="http://geekswithblogs.net/theArchitectsNapkin/archive/2014/09/13/the-incremental-architectacutes-napkin---7---nest-flows-to.aspx" target="_blank">Integration Operation Segregation Principle</a></em> (IOSP). This is how I "mechanically" translate a design like above; but if you don't want to be that rigorous you could use an <em>if-then-else</em> like so:</li></ul><pre class="lang:c# decode:true">public decimal Adjust(decimal price, AccountStatuses accountStatus, int yearsLoyal)
{
	decimal statusDiscount;
	if (Determine_status_discount(accountStatus, out statusDiscount)) {
		var loyalityDiscount = Determine_discount_for_loyality (yearsLoyal);
		return Calc_discounted_price (price, loyalityDiscount, statusDiscount);
	}
	else
		return price;
}

bool Determine_status_discount(AccountStatuses status, out decimal discount) {
	discount = 0.0m;
	switch (status) {
	case AccountStatuses.NotRegistered:
		return false;
	case AccountStatuses.SimpleCustomer:
		discount = 0.1m;
		return true;
	case AccountStatuses.ValuableCustomer:
		discount = 0.3m;
		return true;
	case AccountStatuses.MostValuableCustomer:
		discount = 0.5m;
		return true;
	default:
		throw new NotImplementedException ("Not discount registered for status: " + status.ToString());
	}
}</pre><p>In the name of Clean Code we could now argue about whether <em>Determine_status_discount()</em> really has only a single responsibility, though. Because currently it not only determines the status discount, but also whether any discount should be applied at all (which is different from a 0% status discount).</p><p>But, well... to me that's only a bit of dust left in the code. Negligible dirt ;-) Not extracting this responsibility keeps the code shorter without sacrificing too much readability/evolvability.</p><p>If you like, though, extract it. In any case that would be much more reasonable than introducing design patterns to blow up the code 5 times thereby obscuring the purpose of it: to calculate a discount.</p><h2>Summary</h2><p>It's great to explain Clean Code development by actually cleaning up dirty code. But as Radoslaw's code shows me it's very important to be careful to not overdo it. Applying all those pure principles and shiny design patterns is not an end in itself. We've to keep the reader in mind and stay humble.</p><p>Simplicity in coding is not about writing code quickly, but making it easy to understand.</p><p>And Clean Code is not about showing off yet another hyped concept, but staying true to what the code is supposed to do in the first place.</p><p>To that I find it useful to progress in a systematic way:</p><ol><li>Put the code to refactor under test.</li><li>Identify the responsibilities in the code. Use color markers.</li><li>Design a solution before any code showing how the responsibilities collaborate towards the overall required behavior. This design should be <em>declarative</em>!</li><li>Refactor the code to your design; partially rewrite if needed.</li></ol><p>Happy cleaning! :-)</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/tags/clean-code/">Clean Code</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/its-the-goals-stupid/" class="invert post__nav-link" rel="prev"><span>Previous</span> It&#x27;s the Goals, Stupid</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/vorschlag-fuer-einen-gesundheitsindex/" class="invert post__nav-link" rel="next"><span>Next</span> Vorschlag für einen Gesundheitsindex </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>