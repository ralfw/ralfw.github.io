<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Event Sourcing for Constructivist Software - ralfw-de</title><meta name="description" content="Whatâ€™s Event Sourcing (ES) for? Why deviate from the all encompassing cosy domain data models for keeping and storing application state? Why jump through all the hoops of ES and risk overengineered code? The other day I read an article about Event Sourcing by Tobias&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/event-sourcing-for-constructivist-software/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Event Sourcing for Constructivist Software"><meta property="og:image" content="https://ralfw.de/media/posts/127/potters-410292_1280.jpg"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="Whatâ€™s Event Sourcing (ES) for? Why deviate from the all encompassing cosy domain data models for keeping and storing application state? Why jump through all the hoops of ES and risk overengineered code? The other day I read an article about Event Sourcing by Tobias&hellip;"><meta property="og:url" content="https://ralfw.de/event-sourcing-for-constructivist-software/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Event Sourcing for Constructivist Software"><meta name="twitter:description" content="Whatâ€™s Event Sourcing (ES) for? Why deviate from the all encompassing cosy domain data models for keeping and storing application state? Why jump through all the hoops of ES and risk overengineered code? The other day I read an article about Event Sourcing by Tobias&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/posts/127/potters-410292_1280.jpg"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/event-sourcing-for-constructivist-software/"},"headline":"Event Sourcing for Constructivist Software","datePublished":"2019-06-19T09:30","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.de/media/posts/127/potters-410292_1280.jpg","height":847,"width":1280},"description":"Whatâ€™s Event Sourcing (ES) for? Why deviate from the all encompassing cosy domain data models for keeping and storing application state? Why jump through all the hoops of ES and risk overengineered code? The other day I read an article about Event Sourcing by Tobias&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><script type="text/javascript">var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/606e06a2f7ce1827093813ae/1f2msm5ed';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();</script><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first CodierungğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-DesignğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit SlicingğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">BlogsğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. ğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a></li><li><a href="https://blog.ralfw.de/" target="_blank">ğŸŒ2007..2015ğŸ‡©ğŸ‡ª</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">ğŸŒ2008..2015ğŸ‡¬ğŸ‡§</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">ğŸŒ2003..2010ğŸ‡¬ğŸ‡§</a></li><li><span class="is-separator">â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">ğŸŒZur SoziokratieğŸ‡©ğŸ‡ª</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">ğŸŒGedankliche UmtriebeğŸ‡©ğŸ‡ª</a></li><li><a href="https://medium.com/personal-flow" target="_blank">ğŸŒPersonal FlowğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.de/media/posts/127/potters-410292_1280.jpg" srcset="https://ralfw.de/media/posts/127/responsive/potters-410292_1280-xs.jpg 300w, https://ralfw.de/media/posts/127/responsive/potters-410292_1280-sm.jpg 480w, https://ralfw.de/media/posts/127/responsive/potters-410292_1280-md.jpg 768w, https://ralfw.de/media/posts/127/responsive/potters-410292_1280-lg.jpg 1024w, https://ralfw.de/media/posts/127/responsive/potters-410292_1280-xl.jpg 1360w, https://ralfw.de/media/posts/127/responsive/potters-410292_1280-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="847" width="1280" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-06-19T09:30">19.06.2019</time></div><h1>Event Sourcing for Constructivist Software</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>Whatâ€™s Event Sourcing (ES) for? Why deviate from the all encompassing cosy domain data models for keeping and storing application state? Why jump through all the hoops of ES and risk overengineered code?</p><p></p><p></p><p>The other day I read <a href="https://www.dotnetpro.de/core/events/passiert-1715221.html">an article about Event Sourcing by Tobias Richling</a> in issue 7/2019 of the German .NET magazine <a href="http://dotnetpro.de">dotnetpro</a>. I was happy to see the topic discussed - but from the second page of the article on my disagreement with the author grew. I disagreed with his approach to explaining Event Sourcing which he rooted in object state and described as â€â€šjustâ€˜ a pattern for persistence.â€œ</p><p></p><p></p><p>Sorry, no, thatâ€™s no what Event Sourcing is to me. Right to the contrary!</p><p></p><p></p><p>ES has nothing (!) to do with single objects, or collections of objects, or object graphs.</p><p></p><p></p><p>ES has nothing (!) to do with persistence, either.</p><p></p><p></p><p>ES might me used in conjunction with objects or persistence, but thatâ€™s not defining ES, itâ€™s not mandatory, itâ€™s not why Iâ€™m so excited about ES.</p><p></p><p></p><p>Even <a href="https://martinfowler.com/eaaDev/EventSourcing.html">Martin Fowlerâ€™s article on ES</a> does not catch what makes ES so revolutionary to me. Hereâ€™s a tell tale excerpt:</p><p></p><p></p><blockquote class="wp-block-quote"><p>The most obvious thing we've gained by using Event Sourcing is that we now have a log of all the changes.</p></blockquote><p></p><p></p><p>Heâ€™s talking about events as representing changes. But changes to what? To an application state, or more specifically to a simple domain model consisting of ship object heâ€™s using.</p><p></p><p></p><p>But I argue: events are not changes, they are not differences. There does not need to be a reference point for events. If change happened the question is, what changed. A change always refers to something which changed.</p><p></p><p></p><p>ES does not require such a reference for any event. A â€somethingâ€œ that changes and whose changes need to be recorded instead of overwriting each other is not the point of ES.</p><h2>Events as experiences</h2><p></p><p></p><p>ES events are more universal, broader, less specific: <strong>ES events are just descriptions of things happening.</strong> Whatever that may be. ES events are traces of experiences. The only thing to be in existence for that is an experiencing system.</p><p></p><p></p><p>Maybe an object happens to change. Fine, use an event to record that. However, to me that is only a special case. And itâ€™s a case which requires an abstraction to exist already: an object.</p><p></p><p></p><p>Where does such an abstraction come from, though?</p><p></p><p></p><p>Does it exist on itâ€™s own; is it absolute? That, to me, kind of sounds like platonism.</p><p></p><p></p><p>I donâ€™t believe in that (anymore). Instead Iâ€™ve come to value the constructivist approach to â€explaining the worldâ€œ. <a href="https://en.wikipedia.org/wiki/Constructivism_(psychological_school)">It refutes the idea</a> that â€the act of knowing, produces a copy of the order of reality.â€œ To constructivists the mind is not passively observing an independently existing reality. Rather each mind constructs (builds) itâ€™s own model of reality from purely personal experiences.</p><p></p><p></p><p>This is very plausible to me because it explains what I see in the world, e.g. people with very different beliefs, opinions, understanding of the same worldly events, or why <a href="https://en.wikipedia.org/wiki/Cognitive_reframing">cognitive reframing</a> works.</p><p></p><p></p><p>There is no mirror image of the world in peopleâ€™s heads. There is also <a href="https://en.wikipedia.org/wiki/Homunculus_argument">no homunculus</a> sitting inside of peopleâ€™s heads interpreting their perceptions.</p><p></p><p></p><p>And people (or all organisms for that matter) are doing fine, arenâ€™t they? They are impressively adaptable. They even grow from a single cell to a full blown being with trillions of cells. What a wonder to behold!</p><p></p><p></p><p>People (or all organisms for that matter) donâ€™t need fixed or pre-defined models of the world hard wired into their heads. The more hard wired any aspect of a world view (model) is, Iâ€™d say, the harder itâ€™s for an organism to deal with change. Take <a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases">cognitive biases</a> as an example; I think they are pretty hard wired â€rulesâ€œ for how to interpret perceptions. And what suffering they cause!</p><p></p><p></p><p>Anyway, what I wanted to say: a fixed model of the world to me is a recipe for disaster in a changing world. It might be honed for very specific circumstances, it might allow very efficient and effective behavior in certain situations â€“ but itâ€™s the antithesis of adaptability. At least adaptability during an organismâ€™s life time. Over generations even a fixed model might change and thus adapt members of a species to a new environment. But thatâ€™s little solace for a single member confronted with an environment which its particular fixed model does not fit.</p><p></p><p></p><p>The same is true for software, I think. Software with a single and fixed (data) model is effective and efficient in a very narrow range of situations. Much software development goes into imagining all possible situations an application might encounter (requirements analysis) and then deriving from that a single (data) model to help dealing with them (design).</p><p></p><p></p><p>This is really hard stuff! And it does not become easier when considering all the unknown changes in the environment in the near and far future. Such single (data) models thus need to be concrete and efficient for imminent situations, but at the same time be open and flexible for unknown situations some day.</p><p></p><p></p><p>Somehow software teams pull that feat off again and again. Or at least they think so, until their progress slows down or even comes to a halt. Because they realize their (data) models have been patched and tweaked into exhaustion.</p><p></p><p></p><p>So I guess itâ€™s more accurate to say, software teams are trying this single fixed (data) model approach again and again, and shoot themselves in the foot with it again and again. Iâ€™ve done so myself very often in the past. And Iâ€™ve seen many teams suffering from calcified single (data) models (be they in memory or persistent). Now Iâ€™m eager to find a different approach. ES to me is very promising in that regard.</p><h2>The single model fallacy</h2><p></p><p></p><p>Now that Iâ€™m thinking about itâ€¦ I guess I havenâ€™t seen a single project where this kind of fixed (data) model thinking has led to a happy end. Hence Iâ€™d call it the â€single model fallacyâ€œ. <strong>Itâ€™s a fallacy to believe you can get the single model right for now and at the same time easy to change for the unknown future to come.</strong></p><p></p><p></p><p>To me this kind of software platonism is dead. And neither O/R mappers for RDBMS, nor document databases, nor graph databases or the like are going to change that.</p><p></p><p></p><p>The fundamental flaw in all those meta-models is the single (data) model. Some technologies may make it easier (or harder) to adapt the schema of such a model. But they donâ€™t question the model. A fixed (data) model might be more or less open for change, but still itâ€™s a single model.</p><p></p><p></p><p>Reframing is not part of the picture of single (data) models. Slight and slow change might be ok, but nothing radically new. The fixed (data) model is how the world is perceived. A software with a single (data) model can only serve a world which conforms to this model. And then it has to fear the world changingâ€¦ A single (data) model cannot possibly embrace change.</p><p></p><p></p><p>And that might have been ok for many decades. Software created in the image of machines, or maybe later software created in the image of bureaucratic organizations. Because they world was changing slower than today or easier to understand in the first place. Or maybe just because software systems were necessarily simpler/smaller due to resource constraints.</p><p></p><p></p><p>It worked for the structure of software and for the software production process.</p><p></p><p></p><p>Until it did not anymore. At least for the software production process. Enter: Agility.</p><p></p><p></p><p>The core insight of Agility: software cannot be built in one pass. It needs incremental iterative development to be of constant and increasing value in an ever changing environment.</p><p></p><p></p><p>And nowâ€™s the time to realize it does not work for the internal structure of software anymore either. We need to rethink the basic paradigm weâ€™re basing software structure on. And I donâ€™t mean â€the monolithâ€œ. That has already been broken up.</p><p></p><p></p><p>No, the monolithic architecture or its successor the distributed and then micro-service architecture are the platform to implement functionality on. How can and should functionality be distributed?</p><p></p><p></p><p>What I mean, though, is the paradigm underlying (!) a software system of any structure, be that a monolith or a network of micro-services.</p><p></p><p></p><p>Moving from monolith to micro-services does not force anyone to question the single, fixed (data) model. But itâ€™s that what needs to be challenged, I think.</p><p></p><p></p><p>I understand if you flinch at this suggestion. Event Sourcing can never be the default, right? Itâ€™s not efficient enough, it causes overhead to build (compared to the traditional approach) etc. etc.</p><h2>Time for a new paradigm</h2><p></p><p></p><p>But Iâ€™d like to invite you to clear your mind! Let go of all that youâ€™ve learned as a programmer. Start at day one of your career and imagine what you get told is very, very different from what you remember.</p><p></p><p></p><p><em>Imagine you get told software systems are like organisms triggered by stimuli and producing responses based on perceptions. And each reaction is a cascade of events modulated by data received from the environment and past events (experiences).</em></p><p></p><p></p><p><em>And these strange virtual organisms observe their environment as well whatâ€™s happening internally. And wherever it appears to helpful they build local and temporary abstractions to make their reactions more efficient and effective. But as soon as those abstractions start to hamper them, they amend them or even throw them away. Because any such abstraction is an illusion since it necessarily is out of sync with the ever changing facts (eventual consistency) and/or misses now pertinent data.</em></p><p></p><p></p><p>Just imagine developer newbies got taught programming in such a radically different way. They would not feel any pain because their worldview got challenged. ES would be their first worldview. And thatâ€™s very different from any software developer steeped in RDBMS and OOP from the beginning.</p><p></p><p></p><p>By the way, I think the same is true for Functional Programming (FP) as opposed to OOP when itâ€™s the first paradigm you learn. And it would be true for asynchronous programming as opposed to synchronous programming as itâ€™s taught first today. And it would be true for test-first development from day one on as opposed to test negligence or test later as itâ€™s commonly taught today.</p><p></p><p></p><p>Your gut reaction â€ES cannot possibly be the default!â€œ is - sorry to say - no (!) proof of anything (except that you havenâ€™t been brought up as a programmer with ES being your default worldview).</p><p></p><p></p><p>Sure, I donâ€™t have the proof either, that ES really will make that much of a radically positive difference if it was the default. But I dare to imagine, I dare to challenge the status quo.</p><p></p><p></p><p>Please understand me right: Iâ€™m not against all the cherished paradigms and technologies like OOP or RDBMS or document databases or monolithic software or what not. I donâ€™t want to deny them their usefulness.</p><p></p><p></p><p>However, what I want to get across is: they are optimizations. And as that they are comparatively narrow, inflexible solutions - with all the good and bad attributes of narrow and inflexible.</p><p></p><p></p><p><a href="https://blog.logos.com/2013/11/plato-christianity-church-fathers/">Platonism influenced christianity</a> and Iâ€™d say even current software development. But the world has changed since then. Why not follow constructivism and pluralism not only â€spirituallyâ€œ (as the west at least has increasingly done in the past 50 years or so), but also in software development?</p><p></p><p></p><p>I strongly believe the malleability, the flexibility, the suppleness of software will greatly benefit from moving to an â€ES firstâ€œ worldview. Itâ€™s a very fundamental shift and not for everyone, sure. But I find it worth entertaining the idea, letting inspire me, and trying.</p><p></p><p></p><p>Software systems are not about a single (data) model; they should not be â€monisticâ€œ. Instead they should fundamentally embrace pluralism. There is room for more than one model. In fact there is room for any number of models in a software system. As many as are helpful to deal with all the different triggers assailing it.</p><p></p><p></p><p>Models are means to an end. Not more. They are not the purpose of software. Hence <strong>itâ€™s not your job as a software developer to devise models.</strong> <strong>Your job is to endow software with valuable <em>behavior</em>.</strong> And that probably will be easier or only possible if software keeps track of its experiences. And experiences are nothing more than encountered/produced events.</p><p></p><p></p><p><strong>There is no model in experience. Models are generated, abstracted, built from experiences.</strong> But why stick to just one model?</p><p></p><p></p><p>Set your applications free to construct all sorts of models from their experiences! Events are first, models are second.</p><p></p><p></p><p>Thatâ€™s what Event Sourcing is about, I believe.</p><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/event-orientation/">Event-Orientation</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/eventual-consistency-for-mere-mortals/" class="invert post__nav-link" rel="prev"><span>Previous</span> Eventual Consistency for Mere Mortals</a></div><div class="post__nav-next"><a href="https://ralfw.de/revolutions-over-velocity/" class="invert post__nav-link" rel="next"><span>Next</span> Revolutions Over Velocity </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>