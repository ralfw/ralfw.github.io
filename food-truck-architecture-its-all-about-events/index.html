<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Food Truck Architecture - It’s all about events - ralfw-de</title><meta name="description" content="As you might have guessed if you’ve followed my postings about the Sleepy Hollow Architecture and the Terminus Architecture, I’m on a quest. I want to find a better way to fundamentally structure software for higher evolvability. Not as an end to itself, but because&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/food-truck-architecture-its-all-about-events/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Food Truck Architecture - It’s all about events"><meta property="og:image" content="https://ralfw.de/media/posts/125/DraggedImage-11-1.png"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="As you might have guessed if you’ve followed my postings about the Sleepy Hollow Architecture and the Terminus Architecture, I’m on a quest. I want to find a better way to fundamentally structure software for higher evolvability. Not as an end to itself, but because&hellip;"><meta property="og:url" content="https://ralfw.de/food-truck-architecture-its-all-about-events/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Food Truck Architecture - It’s all about events"><meta name="twitter:description" content="As you might have guessed if you’ve followed my postings about the Sleepy Hollow Architecture and the Terminus Architecture, I’m on a quest. I want to find a better way to fundamentally structure software for higher evolvability. Not as an end to itself, but because&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/posts/125/DraggedImage-11-1.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/food-truck-architecture-its-all-about-events/"},"headline":"Food Truck Architecture - It’s all about events","datePublished":"2019-05-16T14:27","dateModified":"2021-01-28T13:50","image":{"@type":"ImageObject","url":"https://ralfw.de/media/posts/125/DraggedImage-11-1.png","height":642,"width":1070},"description":"As you might have guessed if you’ve followed my postings about the Sleepy Hollow Architecture and the Terminus Architecture, I’m on a quest. I want to find a better way to fundamentally structure software for higher evolvability. Not as an end to itself, but because&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><script type="text/javascript">var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/606e06a2f7ce1827093813ae/1f2msm5ed';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();</script><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first Codierung🇩🇪</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design🇩🇪</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">Blogs🇩🇪🇬🇧</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. 🇩🇪🇬🇧</a></li><li><a href="https://blog.ralfw.de/" target="_blank">🌐2007..2015🇩🇪</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">🌐2008..2015🇬🇧</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">🌐2003..2010🇬🇧</a></li><li><span class="is-separator">─────────</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">🌐Zur Soziokratie🇩🇪</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">🌐Gedankliche Umtriebe🇩🇪</a></li><li><a href="https://medium.com/personal-flow" target="_blank">🌐Personal Flow🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.de/media/posts/125/DraggedImage-11-1.png" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="642" width="1070" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-05-16T14:27">16.05.2019</time></div><h1>Food Truck Architecture - It’s all about events</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>As you might have guessed if you’ve followed my postings about the <a href="https://ralfw.de/sleepy-hollow-architecture-no-application-should-be-without-it/">Sleepy Hollow Architecture</a> and the <a href="https://ralfw.de/terminus-architecture/">Terminus Architecture</a>, I’m on a quest. I want to find a better way to fundamentally structure software for higher evolvability. Not as an end to itself, but because higher evolvability means higher longterm productivity – which seems a good thing at least if you want to make money with software not just today but also tomorrow.</p><p></p><p></p><p>Sure, there are quite a few architectural patterns out there already. So, why add more? Because in my experience over the course of decades in software development there’s still something missing. And that is: a fundamental re-orientation towards less functional dependencies and more guidance and higher flexibility.</p><p></p><p></p><p>The patterns from MVC to Clean Architecture have three things in common:</p><p></p><p></p><ul><li>they all rely on functional dependencies</li><li>they all revolve around a domain model</li><li>they all structure software in a technical way</li></ul><p></p><p></p><p>Since I’ve seen enough software system based on those patterns and still being hard to change I came to think, maybe we should give architectural patterns another try.</p><p></p><p></p><p>With the Sleepy Hollow and Terminus Architectures I’m addressing the technical orientation of the traditional patterns:</p><p></p><p></p><ul><li>The Sleepy Hollow Architecture is putting the most important part of a software in the center: the body (which also is called the backend because it’s not directly interacting with any user). Software is neither about the frontend nor persistence or any other resource access. They are just details of the backend which at first should be viewed as a single thing.</li><li>The Terminus Architecture then is structuring the backend into message handlers each focused on just one request from a user. That’s even more of a non-technical decomposition because it’s the messages that count when delivering software. Handling a message is a natural increment for Agile software development. Software gains value one handled message at a time.</li></ul><p></p><p></p><p>So much for less technicalities in a software architecture. But what about the other two aspects? In this posting I’d like to tackle the domain model focus. Or maybe it should even be called <strong>the „domain model fallacy“</strong>?</p><p></p><p></p><h2>One model to rule them all?</h2><p></p><p></p><p>Generations of developers learned to go straight for the one central data structure to hold everything together in a software. Today it might be called the <em>domain model</em>. But you also can call it a <em>business object model</em> or - if it gets larger - the <em>enterprise data model</em>.</p><p></p><p></p><p>The idea behind this is that a software’s purpose is to modify a single data model representing whatever a user needs to deal with. Look at an SQL Server database with 350 closely related tables and you know what I mean. Add to them the 350 closely related classes to represent those tables in memory and I hope you start feeling uneasy. So many dependencies, such a huge claim of one-size-fits-all.</p><p></p><p></p><p>I used to be thinking along the same lines. I didn’t know how to manage and store application data in a different way. (I have to admit I even thought O/R mapping was a good idea… Well, I was young back then. I have to learn to forgive myself…)</p><p></p><p></p><p>But those days are gone. I’ve come to see such thinking, such models more as a hindrance than an enabler. They might seem obvious and natural – but actually they are not. At best they are premature optimizations.</p><p></p><p></p><p>The problem with these central and single comprehensive data structures is the widespread dependence on them. The larger the claim, the more encompassing the data models, the closer the relationship of all sorts of parts of an application on them. That’s the opposite of decoupling and evolvability.</p><p></p><p></p><p>The more central a part is, the more other parts depend on it, the more stable the central part needs to be. And that’s contrary to what customer require; they require flexibility.</p><p></p><p></p><p>MVC is suggesting there should be one (data) model; it’s right there in the acronym. Clean Architecture is putting the domain in the center which also suggests that there is a single domain model. And in DDD there is so much talk about Entities and Aggregates that it would be strange not to strive for a comprehensive domain data model.</p><p></p><p></p><p>Maybe I’m doing this or that pattern wrong here. Maybe their intention is different. I’d be glad to hear about that. Nevertheless the simple code reality in so many projects is like described. So, at least some massive misunderstandig must be at work.</p><p></p><p></p><p>But what can be done about it? How can the „one domain model fallacy“ be overcome?</p><p></p><p></p><p>Well, for one thing, following the Terminus Architecture there could be several domain models: one for each message handling slice of the backend.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2547"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-26.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-26-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-26-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-26-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-26-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-26-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-26-2xl.png 1600w" alt="" width="632" height="257"></figure></figure></div><p></p><p></p><p>At least in principle there could be many such domain models. Because in reality the question immediately arising is: How to store all those domain models? In the same database? Or how to sync the domain models? Or rather share them? And wouldn’t that lead to one big domain model again?</p><p></p><p></p><p>I think a premise needs to be questioned. That’s the idea of storing in a static structure at all.</p><p></p><p></p><h2>Event Sourcing to the rescue</h2><p></p><p></p><p>To switch from one domain model to several requires a more fundamental change, I guess. We’ve to give up thinking in big schemas for single data models. Instead of putting static data at the center of our applications we should record its evolution change by change, or to be more precise: change event by change event.</p><p></p><p></p><p><strong>If we want to get rid of the one domain model we need to create a stream of changes over time as the source for all the individual models fitting the changing needs of different parts of a software system.</strong></p><p></p><p></p><p><strong>Data models needed should be seen as projections of recorded events in an never ending stream.</strong> That’s called <a href="https://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="noopener">Event Sourcing</a>.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2544"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-1-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-1-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-1-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-1-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-1-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-1-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-1-2-2xl.png 1600w" alt="" width="622" height="349"></figure></figure></div><p></p><p></p><p>When requirements change for one part of an application just one projection has to be adapted. The impact is local by definition instead of global, because different parts depend only on local data models.</p><p></p><p></p><p>The <a href="https://www.martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">CQRS pattern</a> has recognized this by introducing a so called <em>read model</em>. That’s an individual data model to satisfy queries. See the right side of the following image by <a href="https://pablocastilla.wordpress.com/2014/09/22/cqrs-with-event-sourcing-using-nservicebus-event-store-elastic-search-angularjs-and-asp-net-mvc/" target="_blank" rel="noopener">Pablo Castilla</a>:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2550"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-2-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-2-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-2-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-2-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-2-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-2-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-2-2-2xl.png 1600w" alt="" width="642" height="583"></figure></figure></div><p></p><p></p><p>On the left there still is a domain model to support command handling. But queries just rely on read models stored in the „data“ drum.</p><p></p><p></p><p>That’s a step in the right direction, I think. Firstly the demands on data models for changing/writing and querying/reading are very different; this is acknowledge by dividing the „data model space“ into the left and right side. Secondly the one-size-fits-all thinking is given up by allowing any number of small and large read models to exist in parallel.</p><p></p><p></p><p>Event Sourcing and CQRS to me thus are a missing link in the traditional chain of architectural patterns. I believe it should be the default for any application. Yes, even for simple CRUD applications.</p><p></p><p></p><p>Most proponents of CQRS don’t view CRUD applications worthy of so much effort, it seems, though. To be honest, I don’t get why. Because if there’s one thing sure in software development then that’s constant change. In my experience today’s simple, local CRUD application is tomorrow’s enterprise wide tool growing every day. To be prepared for this surprise I’d say it’s prudent to default to CQRS and Event Sourcing.</p><p></p><p></p><p>Except… for my taste there is an inconsistency in this pattern.</p><p></p><p></p><h2>Beyond CQRS: Event-Orientation</h2><p></p><p></p><p>CQRS does not mandate Event Sourcing but benefits from it, I’d say. What I don’t understand, however, is why there is this distinction between a domain model on the left of the above image and read models on the right?</p><p></p><p></p><p>In <a href="https://www.martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">Martin Fowler’s depiction</a> it’s similar: a command model, and even a single query model.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2546"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-3-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-3-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-3-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-3-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-3-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-3-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-3-2-2xl.png 1600w" alt="" width="652" height="476"></figure></figure></div><p></p><p></p><p>He even blurs the distinction by saying:</p><p></p><p></p><blockquote class="wp-block-quote"><p>The two models might not be separate object models, it could be that the same objects have different interfaces for their command side and their query side…</p></blockquote><p></p><p></p><p>With that I very much disagree! The potential of Event Sourcing will not be fully tapped until the default is a share-nothing approach. All models are different, individual, local to a single message handler - until this proves to be cumbersome and some optimization seems worthwhile.</p><p></p><p></p><p><strong>The evolutionary demands on software are so huge that I think the first and foremost requirement to fulfill is changeability, malleability. Flexibility first – that’s what Event Sourcing is about to me.</strong></p><p></p><p></p><p>There was a slogan in the 1980s when user interfaces moved into the graphical realm: „Don’t mode me in!“ I even remember t-shirts with this printed on. It was a rallying cry to build different user interface, user interfaces with more flexibility for users.</p><p></p><p></p><p><strong>Today I’m tempted to change this slogan into „Don’t model me in!“ Don’t create just one or few models to try serving very different and changing needs in a software.</strong></p><p></p><p></p><p>In my view – and that of <a href="http://www.sia-consulting.eu" target="_blank" rel="noopener">Sia Ghassemi</a> who I’ve talked with a lot about this over asian lunches – the shift needs to be more fundamental than with CQRS. What’s needed is full <strong>Event-Orientation (EO)</strong>. To Sia and me that means two things:</p><p></p><p></p><h3>1. All messages are created equal</h3><p></p><p></p><p>Why should there be just two sides to an application: a command handling side and a query handling side? Sure, this is already some kind of slicing (incremental architecture). But why stop there?</p><p></p><p></p><p>Why not treat each and every incoming message the same, i.e. with its own message handler? That’s what the Terminus Architecture is about.</p><p></p><p></p><p>And then: Why distinguish between commands and queries at all? Sure, there is a fundamental difference and I think it’s important – but not in a way to set up message handlers differently. In both images above the command handling and query handling sides are looking quite different. Why? Why is a domain model treated differently than a read model?</p><p></p><p></p><p>We think this is an unnecessary asymmetry. To us all messages deserve individual handling and the same basic treatment. Each message thus is assigned its own message handling pipeline:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2526"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-4-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-4-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-4-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-4-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-4-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-4-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-4-2-2xl.png 1600w" alt="" width="657" height="475"></figure></figure></div><p></p><p></p><h3>2. All messages deserve their own model</h3><p></p><p></p><p>All message handlers should get their own data model by default. We call that the <em>message context model</em>. It’s an extreme form of what Martin Fowler describes as „<a href="https://martinfowler.com/bliki/MultipleCanonicalModels.html" target="_blank" rel="noopener">multiple canonical models</a>“. For EO every message represents a bounded context, you could say, albeit a small one.</p><p></p><p></p><p>A <em>message context</em> consist of all the events in the event stream relevant to handling a message. In sum they describe the current pertinent state of the application.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2530"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-5-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-5-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-5-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-5-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-5-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-5-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-5-2-2xl.png 1600w" alt="" width="627" height="301"></figure></figure></div><p></p><p></p><p>Message processing could work directly on the context, i.e. on raw events, but more conveniently it will work on a projection, i.e. some data model built from the context, the <em>context model</em>.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2537"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-6-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-6-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-6-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-6-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-6-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-6-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-6-2-2xl.png 1600w" alt="" width="626" height="340"></figure></figure></div><p></p><p></p><p><strong>Every command, every query, every notification has its own context and context model. There is no fundamental distinction between them in content or form.</strong></p><p></p><p></p><p>Commands and queries still differ in their purpose: commands change/write state, queries just read state. Only commands create events.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2532"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-7-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-7-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-7-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-7-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-7-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-7-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-7-2-2xl.png 1600w" alt="" width="621" height="377"></figure></figure></div><p></p><p></p><p>But both commands and queries base their message processing on a message specific context. The context or context model is a second input to command processing.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2538"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-8-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-8-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-8-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-8-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-8-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-8-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-8-2-2xl.png 1600w" alt="" width="630" height="405"></figure></figure></div><p></p><p></p><p>There is asymmetry in purpose, but there is symmetry in how commands and queries use the event stream to do their job.</p><p></p><p></p><h3>Process messages like a food truck</h3><p></p><p></p><p>The image I have in my head for this is that of a food truck:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2543"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-9-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-9-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-9-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-9-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-9-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-9-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-9-2-2xl.png 1600w" alt="" width="855" height="478"></figure></figure></div><p></p><p></p><p>(image source: <a href="http://eatdrinkplay.com/sydney/12-best-sydney-food-trucks/" target="_blank" rel="noopener">eat dring play</a>)</p><p></p><p></p><p>Think of a restaurant as a comprehensive backend in a Sleepy Hollow Architecture. Then think of a food truck a a single message handler in a Terminus Architecture.</p><p></p><p></p><p>While an Italian restaurant offers dishes ranging from primavera bruschetta to pepperoni pizza, seafood linguine, aubergine parmigiana, and zuccotto di panettone, a food truck is focused on just one (or very few) dishes, e.g. pizza.</p><p></p><p></p><p>But more importantly in a food truck the order handling is transparent and following a simple process. Everything is happening right before your eyes:</p><p></p><p></p><ul><li>ingredients are prepared</li><li>the pizza is made from them and baked</li><li>the pizza is prepared for serving and excess ingredients are „stored“ for the next order</li></ul><p></p><p></p><p>You can see the „order processing pipeline“ at work. Step by step your dish is prepared.</p><p></p><p></p><p>That’s how Sia and I are thinking of EO message handling: a pipeline of sequential steps through which every message gets pumped. The basic message handling stages are:</p><p></p><p></p><ol><li>Load the context model for a message</li><li>Process the message in the light of the context model</li><li>Update the context model</li></ol><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2533"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-10-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-10-2-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-10-2-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-10-2-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-10-2-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-10-2-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-10-2-2xl.png 1600w" alt="" width="646" height="380"></figure></figure></div><p></p><p></p><p>All processing steps are message specific by default. Only if patterns appear across message pipelines, abstractions should be introduced to extract common structures/stages.</p><p></p><p></p><p>This three stage pipeline is the same for commands, queries, and notifications. But the different purposes of these message types require a closer look:</p><p></p><p></p><ul><li>Only commands generate events to document application state changes; that means context models only really get updated after command processing.</li><li>Notifications don’t create events directly, but commands which in turn create events. (This should also make clear that events are just internal data to record what’s happened. If something happened in the environment of a software system then that’s received as notifications. And since notifications by their very nature are no requests and don’t try to elicit a response, handling them can only mean producing commands.)</li><li>All contexts and context models are read-only. If changes are made to them during the message processing stage, they will be discarded afterwards. Changes to the application state beyond processing a message have to be encoded in events written to the event stream. <strong>The event stream is holding the ever changing state truth of an application.</strong></li><li>Loading and updating context models is working only with events as data source. No other resources are used.</li></ul><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2528"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-11-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-11-1-2xl.png 1600w" alt="" width="697" height="418"></figure></figure></div><p></p><p></p><p>A Food Truck Architecture is about specific message handling like the Terminus Architecture. But this time the handling is more differentiated and based on a pattern. Each message handling pipeline is working the same.</p><p></p><p></p><p>That might look boring to you. But we find it fascinatingly relieving. We feel relieved because our thinking is guided. For each message we are asked the same questions:</p><p></p><p></p><ol><li>What’s the context?<ul><li>Which events are relevant?</li><li>What does the context model look like? How little data is sufficient?</li><li>How to build the context model? How do the events affect it?</li><li>How to load the context model? How to query the context model with regard to a particular message?</li></ul></li><li>How to process a message in light of its context model?</li></ol><p></p><p></p><p>We find this extremely focussing, extremely guiding. The SRP is embodied on several levels:</p><p></p><p></p><ul><li>Sleepy Hollow Architecture: Separate frontend and backend as two fundamentally different responsibilities.</li><li>Terminus Architecture: Separate the different responsibilities of handling each message (representing distinct interactions with the software system).</li><li>Food Truck Architecture: Within a message handler separate the responsibilities of representing the context model, loading the context model, updating the context model, and processing the message.</li></ul><p></p><p></p><p>The result is a basic software anatomy made up of not only slices, but also dices:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2540"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-12-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-12-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-12-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-12-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-12-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-12-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-12-1-2xl.png 1600w" alt="" width="634" height="396"></figure></figure></div><p></p><p></p><p>The one domain model, the few models (command+read) get dissolved into a growing stream of small events. What once was coarse grained and static now is fine grained and non-static. And all of a sudden time is very naturally manifested in the data!</p><p></p><p></p><p>To us message models – be it command models, query models, notification models – are just optimizations. They are no longer the default or what you think about first.</p><p></p><p></p><p><strong>You don’t go hunting for data structures when you are faced with requirements. Instead you try to find the interactions with a software system, from that you derive messages, from commands you glean events, and from events you abstract contexts, from which you finally might distill models.</strong></p><p></p><p></p><p><strong>Event-Orientation is about all the benefits of Event Sourcing (which I don’t want to describe, but you can read about them for example <a href="https://dev.to/barryosull/event-sourcing-what-it-is-and-why-its-awesome" target="_blank" rel="noopener">here</a>) plus the benefits of a very symmetric and consistent fine grained message handling.</strong></p><p></p><p></p><p>This is not to say there is no domain model anymore. No, the domain model becomes even more important! So important that there are many, as many as there are messages to handle. You could call them „personalized domain models“. And since they are so message specific they look very different from your usual domain model.</p><p></p><p></p><p>The dependency between message handlers thus is fundamentally reduced. What a boon for evolvability! You can make changes to one message handler’s model without affecting others. You can add new message handlers with completely different context models without affecting existing ones.</p><p></p><p></p><p><strong>Event-Orientation is about YAGNI and KISS for data models. Don’t do more than what’s absolutely necessary in the context of a message.</strong></p><p></p><p></p><p>To be honest, in our experience that means, the need for treasured building blocks of tactical DDD like Aggregate and Entity diminishes. At least if you think of them as rich domain objects finely chiseled to match real world concepts. More so if you’re used to persisting them with a tool like Entity Framework or Hibernate.</p><p></p><p></p><p>If you don’t feel easy about that, we understand. But dissolving the one domain model pretty much is the point of Event-Orientation. A monolith is the quick thing to do at the beginning – but soon you find yourself painted into a corner barely able to move. „Thinking in events“ might be comparatively new, and we all certainly still have to learn a lot about it, but it’s too promising to dismiss.</p><p></p><p></p><p>Would you rather do a sculpture of a shape you’re not yet certain about from a block of marble or with clay? Maybe in the end marble is more durable. But until you know exactly how the sculpture should look, clay is much more malleable.</p><p></p><p></p><p>The difference between marble and clay? Marble is one piece, a solid monolith. Clay is millions of pieces and more like a fluid.</p><p></p><p></p><p>Our believe is that in the face of uncertainty it’s prudent to start data modelling not with a RDBMS as the default data store, and probably not even with a NoSql store like MongoDB. Don’t think „schema“, don’t even think „document“. The „clay particles“ of data modelling need to be smaller: events. From them you can build whatever you like on demand and more or less just in time.</p><p></p><p></p><h2>An example application</h2><p></p><p></p><p>This all might sound a bit abstract to you. So let me show you what Event-Orientation means by refactoring the stock portfolio management application from the Sleepy Hollow Architecture article to it.</p><p></p><p></p><p>Do you remember? I was able to include stocks in my portfolio (simulating a buy), update the current price of the stocks in the portfolio (by querying an online service), and eventually remove (sell) stocks from the portfolio. It’s pretty much a CRUD application with some additional online resource access.</p><p></p><p></p><p>The messages to flow between head and body, I mean frontend and backend, are as follows:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2535"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-13-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-13-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-13-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-13-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-13-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-13-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-13-1-2xl.png 1600w" alt="" width="354" height="391"></figure></figure></div><p></p><p></p><p>I defined them in a contract library shared by both „software body parts“. This does not change for the Food Truck Architecture.</p><p></p><p></p><p>What does change, though, is the definition of the backend interface. It’s gone from the contract. There is no single application specific<code>IMessageHandling</code> interface anymore like in the Sleep Hollow Architecture; there are not even message individual interfaces anymore like <code>IBuyStockCommandHandling</code> as in the Terminus Architecture. Instead all message handling is done by a generic infrastructure. I call it the <em>message pump</em> because it takes care of passing a message through its handling pipeline.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2548"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-14-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-14-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-14-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-14-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-14-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-14-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-14-1-2xl.png 1600w" alt="" width="741" height="244"></figure></figure></div><p></p><p></p><p>All messages are handled by the same message pump which selects the right pipeline of context model loader, context model updater and message processor from those registered.</p><p></p><p></p><p>Those pipelines are defined in the backend:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2541"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-15-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-15-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-15-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-15-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-15-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-15-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-15-1-2xl.png 1600w" alt="" width="423" height="457"></figure></figure></div><p></p><p></p><p>For each message there are three classes:</p><p></p><p></p><ul><li>the message context model</li><li>the message context model manager responsible for loading and updating</li><li>the message processor</li></ul><p></p><p></p><p>Yes, that’s a lot of classes now. But that’s not a bug, it’s a feature. Because more classes mean more guidance and more focus. Look at the pipeline for the <code>BuyStockCommand</code> for example:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2527"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-16-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-16-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-16-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-16-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-16-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-16-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-16-1-2xl.png 1600w" alt="" width="701" height="543"></figure></figure></div><p></p><p></p><p>While working on handling this command I just needed to focus on the needs of its pipeline.</p><p></p><p></p><ul><li>What data does this command need to do its job? Commands can succeed or fail depending on the current state of the application. In this case my decision was: the command does not need any data at all. No context needed. It will always succeed. (Well, I could have come up with some validation logic (check for the quantity bought to be larger than zero, for example). But that still does not need any context.) Hence the context model class is empty and the context manager’s methods do nothing.</li><li>How to process the message in light of its context? In this case just a simple mapping from message data to events is needed.</li><li>Which events should be generated? I decided to record buying a stock with the <code>StockBought</code> event plus a <code>StockPriceChanged</code> event. Why two events? Because actually two things are happening: One is, that a stock was bought. That’s obviously what the command is about. All pertinent data gets recorded with the <code>StockBought</code> event. But then the command carries an information which could also have been acquired another way: a stock price. Usually stock prices get updated by querying an online service while processing the <code>UpdatePortfolioCommand</code>. But for whatever reason a <code>BuyStockCommand</code> might carry a more current price; then that should be recorded appropriately. But why then not remove the stock price property from the <code>StockBought</code> event? Isn’t that redundant? Yes, in principle. But I keep it in there to make both events independent of each other. Another example of decoupling.</li></ul><p></p><p></p><p>Speaking of events: they are a matter of the backend only. Nobody is gonna see them so they are defined in the backend project:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2549"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-17-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-17-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-17-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-17-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-17-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-17-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-17-1-2xl.png 1600w" alt="" width="251" height="168"></figure></figure></div><p></p><p></p><p>The event store, which is part of the EO infrastructure like the message pump, defines an <code>Event</code> base class to derive all concrete events from:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2534"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-18-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-18-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-18-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-18-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-18-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-18-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-18-1-2xl.png 1600w" alt="" width="626" height="390"></figure></figure></div><p></p><p></p><p>Which events there should be is a matter by itself I don’t want to dive into here. For a CRUD application like this they sure are few and simple. But to me that’s not a sign for a domain or use cases unworthy of EO. Right to the contrary! Let’s start simple to get used to the overall paradigm of EO and the Food Truck Architecture. If the application shows itself to be useful it sure will grow and soon move beyond simple CRUD. And then I’ll thank myself for betting on EO from the beginning.</p><p></p><p></p><h3>Sharing a context model</h3><p></p><p></p><p>The command for buying is trivial: no context model, just a mapping to events. Now for a command which actually needs a context model: the command for selling stock.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2529"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-19-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-19-1-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-19-1-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-19-1-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-19-1-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-19-1-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-19-1-2xl.png 1600w" alt="" width="738" height="273"></figure></figure></div><p></p><p></p><p>As you see the processor checks if the stock supposed to be sold actually is in the portfolio: <code>if (cmdModel.Values.Contains(cmd.StockSymbol))</code> Only if that’s the case a <code>StockSold</code> event is recorded. (Remember: there is no change to persistent data models in EO! Changes are recorded „over time“ in the event stream by appending new events. This was different in the architectures before.)</p><p></p><p></p><p>Try to feel the beauty of this: While focussing on message processing I did not have to worry about where the model came from. It’s just there and has exactly the form and content as needed. Nothing more, nothing less.</p><p></p><p></p><p>And what’s the form and content of the message context model? That’s a matter of a different class: its context data class and its context manager class.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2542"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-20.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-20-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-20-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-20-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-20-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-20-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-20-2xl.png 1600w" alt="" width="700" height="134"></figure></figure></div><p></p><p></p><p>Interestingly they are „empty“. That’s because the <code>SellStockCommand</code> is sharing its context model and context model manager with the <code>UpdatePortfolioCommand</code>. Both need just the symbols (e.g. „MSFT“) of the stocks in the portfolio.</p><p></p><p></p><p>Yes, just the symbols! No special IDs, no price, no quantity, no „real“ domain data model. The context model is stripped down just the data needed in the very limited context of one message to handle. If a list of symbols is enough, then that’s what the context model contains. If more is needed like for processing the <code>PortfolioQuery</code>, then more is included. Contexts can encompass any number of events from the event stream: 0, 1, many. Contexts models can have any form: they can be empty, consist of just a single number, a list of strings, or intricate object graphs.</p><p></p><p></p><p>When I migrated the application from Terminus to Food Truck Architecture I first made the context model with the stock symbols specific to the <code>SellStockCommand</code>. Only when I started my work on the <code>UpdatePortfolioCommand</code> I realized its context model needs where the same and I move it and its manager to a base class. (Base classes and derived message specific classes are not needed. I just could have registered the same message context manager object for two messages with the message pump. But I found it more regular/consistent to have specific context model and manager classes.)</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2539"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-21.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-21-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-21-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-21-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-21-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-21-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-21-2xl.png 1600w" alt="" width="778" height="520"></figure></figure></div><p></p><p></p><p>The context model is mainly managed in the <code>Update()</code> method. Whenever there are new events it gets changed. (And upon application start it’s initially „inflated“ from all past relevant events in the stream.) The context consist of all <code>StockBought</code> and <code>StockSold</code> events. And the model distilled from that is just a collection of symbols.</p><p></p><p></p><p>Loading the context model thus means just delivering the current list to the processor. It does not need to be further narrowed down.</p><p></p><p></p><p>What’s done with the context model in the command processors differs, however. When selling a stock the processor checks a symbol for existence in the list. When updating stocks the processor takes all the symbols in the list and for each retrieves the current stock price from an online service.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2525"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-22.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-22-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-22-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-22-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-22-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-22-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-22-2xl.png 1600w" alt="" width="683" height="432"></figure></figure></div><p></p><p></p><h3>The message pump</h3><p></p><p></p><p>Messages flow through their pipelines by virtue of a generic <em>message pump</em>.</p><p></p><p></p><p>On the outside the message pump only produces an <code>IMessage</code> as a response. It’s either a command status or a query result. That’s what a client (the triggering environment) wants to receive.</p><p></p><p></p><p>But inside the message pump the message processor returns an <code>Output</code> tuple. It’s a structure matching the needs of all message processors, be they command or query or notification processors.</p><p></p><p></p><ul><li>A command returns a status plus a list of events.</li><li>A query just returns a result.</li><li>A notification returns just a list of commands.</li></ul><p></p><p></p><p>Using a structure like this makes downstream handling in the pipeline straightforward:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2536"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-23.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-23-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-23-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-23-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-23-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-23-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-23-2xl.png 1600w" alt=""></figure></figure></div><p></p><p></p><ol><li>A message gets handled by selecting the appropriate pipeline consisting of loading/updating the context and a processor.</li><li>The message pump lets the message flow through the selected pipeline: first the context (model) is loaded, then the message gets processed with the context (model), finally the output produced gets „dispatched“…</li><li>… which means it gets treated according to what it is:<ul><li>from a query output the query result is retrieved and returned</li><li>from a notification output the commands are retrieved and handled individually by calling the message pump’s <code>Handle()</code> recursively</li><li>from a command output the events are retrieved and recorded, and the status is returned</li></ul></li><li>Also the events produced by a command are used to update context models…</li><li>… by calling all registered context updaters and offering them the events for assimilation. Some will be interested, some not.</li></ol><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2531"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-24.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-24-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-24-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-24-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-24-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-24-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-24-2xl.png 1600w" alt="" width="672" height="396"></figure></figure></div><p></p><p></p><h3>All together now</h3><p></p><p></p><p>It seems there are many moving parts in the Food Truck Architecture. But as I said: that’s a feature. Many moving parts means small parts, dedicated parts. And it’s not difficult to keep them in your head, since there is clearly visible cohesion between the pipeline stages and obvious boundaries between pipelines.</p><p></p><p></p><p>So what needs to be done to get an application going is to register the pipelines with the message pump (1): create message processor and context managers and associate them with a message.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2545"><img loading="lazy" src="https://ralfw.de/media/posts/125/DraggedImage-25.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/DraggedImage-25-xs.png 300w, https://ralfw.de/media/posts/125/responsive/DraggedImage-25-sm.png 480w, https://ralfw.de/media/posts/125/responsive/DraggedImage-25-md.png 768w, https://ralfw.de/media/posts/125/responsive/DraggedImage-25-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/DraggedImage-25-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/DraggedImage-25-2xl.png 1600w" alt=""></figure></figure></div><p></p><p></p><p>Once that’s done the actual message handling (2) does not differ much from the Terminus Architecture. It’s just that instead of different message handlers there is one, the universal message pump.</p><p></p><p></p><h2>Summary</h2><p></p><p></p><p>That’s a first basic implementation of the Event-Orientation concept. It sure can be improved. As can be the event store which is very, very simple and homegrown. But that would not change the overall approach which is, that software structure first and foremost is focused on message handling and that all messages are processed within a context of events which embody the incremental change of application state.</p><p></p><p></p><p>Refactoring the sample code to the Food Truck Architecture was a great experience. I really felt guided and focused; there were easy to follow steps.</p><p></p><p></p><ol><li>Find the messages to be processed by an application (Sleepy Hollow Architecture).<ol><li>Derive the events to be generated by the commands</li></ol></li><li>Select a message to focus on and a create a „compartment“ in the codebase for it (Terminus Architecture)</li><li>Define the message handling pipeline for the message inside the „compartment“ (Food Truck Architecture):<ul><li>Define the message context model</li><li>Implement the message context manager with its loader and updater</li><li>Implement the message processor</li></ul></li><li>Go back to 2. until all messages are covered.</li></ol><p></p><p></p><p>Sure, some challenges remain: you need to decide how to store any context models, and most importantly you need to implement message processing. But with the Food Truck Architecture this is presented to you on a silver platter. You don’t need to come up with that yourself again and again.</p><p></p><p></p><p>Software development is broken down for you. And what’s most important is delivered to your doorstep wrapped in a neat interface:</p><p></p><p></p><p><code>Output Process(IMessage message, IMessageContext context)</code></p><p></p><p></p><p><em>That</em> is what every application revolves around. That’s the beating heart at its center. From that all else is derived by asking:</p><p></p><p></p><ul><li>What messages are there?</li><li>What’s their message contexts?</li><li>What events are there in the first place?</li><li>What should the message context models look like?</li><li>What events to generate from commands?</li><li>What commands to generate from notifications?</li><li>What results to generate from queries?</li></ul><p></p><p></p><p>What messages there are is driven from the outside. It’s a matter of interaction with the application. What are the use cases? How should the UI look like?</p><p></p><p></p><p>The rest grows from them motivated by the core function signature of Event-Orientation for message processing.</p><p></p><p></p><p>Give it a try!</p><p></p><p></p><figure class="alignnone wp-image-2520"><img loading="lazy" src="https://ralfw.de/media/posts/125/githublogo-150x150.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/githublogo-150x150-xs.png 300w, https://ralfw.de/media/posts/125/responsive/githublogo-150x150-sm.png 480w, https://ralfw.de/media/posts/125/responsive/githublogo-150x150-md.png 768w, https://ralfw.de/media/posts/125/responsive/githublogo-150x150-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/githublogo-150x150-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/githublogo-150x150-2xl.png 1600w" alt="" width="30" height="30"></figure> <a href="https://github.com/ralfw/architecture-variations/tree/master/03%20food%20truck%20architecture" target="_blank" rel="noopener">[Sample code in GitHub repo]</a><p></p><p></p><p></p><figure class="alignnone wp-image-2521"><img loading="lazy" src="https://ralfw.de/media/posts/125/redditlogo-150x150.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/125/responsive/redditlogo-150x150-xs.png 300w, https://ralfw.de/media/posts/125/responsive/redditlogo-150x150-sm.png 480w, https://ralfw.de/media/posts/125/responsive/redditlogo-150x150-md.png 768w, https://ralfw.de/media/posts/125/responsive/redditlogo-150x150-lg.png 1024w, https://ralfw.de/media/posts/125/responsive/redditlogo-150x150-xl.png 1360w, https://ralfw.de/media/posts/125/responsive/redditlogo-150x150-2xl.png 1600w" alt="" width="30" height="30"></figure> <a href="https://www.reddit.com/r/softwarearchitecture/comments/bpc12d/eventorientation_as_the_new_default_for/" target="_blank" rel="noopener">[Let's discuss this, if you like, on reddit...]</a><p></p><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 28.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/event-orientation/">Event-Orientation</a></li><li><a href="https://ralfw.de/tags/software-architecture/">Software architecture</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/terminus-architecture/" class="invert post__nav-link" rel="prev"><span>Previous</span> Terminus Architecture</a></div><div class="post__nav-next"><a href="https://ralfw.de/eventual-consistency-for-mere-mortals/" class="invert post__nav-link" rel="next"><span>Next</span> Eventual Consistency for Mere Mortals </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>