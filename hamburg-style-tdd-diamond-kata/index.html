<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Hamburg Style TDD - Diamond Kata - ralfw-de</title><meta name="description" content="In a previous article I tried to explain why I’m not satisfied with the existing schools of TDD: They are not really tapping the developers’ capability to think. At least for my taste. Or to say it more bluntly: They are dumbing down developers. Sure,&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/hamburg-style-tdd-diamond-kata/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Hamburg Style TDD - Diamond Kata"><meta property="og:image" content="https://ralfw.de/media/website/logo-smaller.png"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="In a previous article I tried to explain why I’m not satisfied with the existing schools of TDD: They are not really tapping the developers’ capability to think. At least for my taste. Or to say it more bluntly: They are dumbing down developers. Sure,&hellip;"><meta property="og:url" content="https://ralfw.de/hamburg-style-tdd-diamond-kata/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Hamburg Style TDD - Diamond Kata"><meta name="twitter:description" content="In a previous article I tried to explain why I’m not satisfied with the existing schools of TDD: They are not really tapping the developers’ capability to think. At least for my taste. Or to say it more bluntly: They are dumbing down developers. Sure,&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/website/logo-smaller.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/hamburg-style-tdd-diamond-kata/"},"headline":"Hamburg Style TDD - Diamond Kata","datePublished":"2019-07-23T14:58","dateModified":"2021-01-28T11:45","image":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250},"description":"In a previous article I tried to explain why I’m not satisfied with the existing schools of TDD: They are not really tapping the developers’ capability to think. At least for my taste. Or to say it more bluntly: They are dumbing down developers. Sure,&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first Codierung🇩🇪</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design🇩🇪</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">Blogs🇩🇪🇬🇧</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. 🇩🇪🇬🇧</a></li><li><a href="https://blog.ralfw.de/" target="_blank">🌐2007..2015🇩🇪</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">🌐2008..2015🇬🇧</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">🌐2003..2010🇬🇧</a></li><li><span class="is-separator">─────────</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">🌐Zur Soziokratie🇩🇪</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">🌐Gedankliche Umtriebe🇩🇪</a></li><li><a href="https://medium.com/personal-flow" target="_blank">🌐Personal Flow🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-07-23T14:58">23.07.2019</time></div><h1>Hamburg Style TDD - Diamond Kata</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>In a <a href="https://ralfw.de/hamburg-style-tdd/">previous article</a> I tried to explain why I’m not satisfied with the existing schools of TDD: They are not really tapping the developers’ capability to think. At least for my taste. Or to say it more bluntly: They are dumbing down developers.</p><p></p><p></p><p>Sure, their motivation behind that is honorable. And they all assure us of still, no, hence getting to the best possible code result. Nevertheless I think this is doing productivity a disservice.</p><p></p><p></p><p>Mileage always varies with different approaches, but for me the mileage so far has been too low with the established TDD styles. That’s why I came up with yet another one. I call it eclectic because it’s drawing from all sorts of approaches. And I might even not call it a programming style but a problem solving style.</p><p></p><p></p><p>In my previous article I explained why I think TBC (Thinking Before Coding) and ADC (Analyse, Design, Code) are so important. But what does that mean when applied to concrete problems?</p><p></p><p></p><p>Here’s a first problem I tackled to demonstrate this. I chose the Diamond kata because the originator of the Munich style TDD, David Völkel, was mentioned <a href="https://twitter.com/DataDuke/status/1151989878499897344" target="_blank" rel="noopener noreferrer">in a recent tweet</a> teaching his style using this kata.</p><p></p><p></p><p>Let’s start…</p><p></p><p></p><h2>Problem description</h2><p></p><p></p><p>First a problem description as I found it on the web:</p><p></p><p></p><pre class="wp-block-code"><code>Given a letter, print a diamond starting with ‘A’ with the supplied letter at the widest point.

For example: print-diamond ‘C’ prints

..A
.B.B
C...C
.B.B
..A

(The dots '.' are just placeholders for spaces ' ' to make the result more clear.)
</code></pre><p></p><p></p><p> </p><h2>1. Analysis</h2><p></p><p></p><p>The first thing I do when faced with a programming problem is… I’m trying to understand it. Sure that’s also advocated by other TDD styles. But exactly does that mean? What’s the result of analysis?</p><p></p><p></p><p>Analysis is the activity which in my view is supposed to produce understanding. But how to document my understanding?</p><p></p><p></p><p>In the end there is no unambiguous understanding except when I’m able to solve the problem (or very similar problems in the same problem class). That means any software I produce needs to be able to do the same. Otherwise I might have understood, but wasn’t able to encode my understanding.</p><p></p><p></p><p>Translated into code that means analysis results in two things:</p><p></p><p></p><ul><li>examples of successful problem solving (aka test cases)</li><li>functions that actually show the behavior as described in the examples.</li></ul><p></p><p></p><p>I usually document my understanding in a file next to the code. In this case I used a <code>.md</code> file:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2679"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-16.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-16-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-16-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-16-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-16-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-16-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-16-2xl.png 1600w" alt="" width="691" height="545"></figure></figure></div><p></p><p></p><p>You see, first there is some text explaining what I gleaned from the problem description. An important aspect of that are terms of the domain language.</p><p></p><p></p><p>But then there is a function and test cases. They are the real expressions of my understanding.</p><p></p><p></p><p>The sample problem is so easy, however, I did not come up with my own test case. But if it’s more complicated I will go beyond whatever has been presented by the client.</p><p></p><p></p><p>My analysis is complete once I really get my insights encoded as <em>acceptance tests</em> and the signatures of behavior delivering functions:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2667"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-1-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-1-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-1-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-1-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-1-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-1-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-1-2-2xl.png 1600w" alt="" width="805" height="302"></figure></figure></div><p></p><p></p><p>I don’t need to know how to create the results. Just the surface of my „system under development“ needs to be clearly specified.</p><p></p><p></p><p>That’s easy in this case of course. But what if I had a hard time to come up with an interface? Isn’t TDD supposed to help with that?</p><p></p><p></p><p>Well, my view is: As long as you don’t know which functions should provide the requested services, you should not touch your production code. You’re not even in a situation to write tests.</p><p></p><p></p><p>Lack of clarity of the interface is a clear sign of „chaos“ (in your head or the client’s head). <a href="https://en.wikipedia.org/wiki/Cynefin_framework" target="_blank" rel="noopener noreferrer">And when in chaos the first thing to do is: act!</a></p><p></p><p></p><p>In the case of programming that means whipping up a REPL or some other scratchpad and start „drawing“, start experimenting. Play around with interfaces all you want. Write a whole prototype, even.</p><p></p><p></p><p>But don’t touch your production code! Not even backed by a test. Otherwise you’ll later on be sorry because you have to go through much refactoring. And that’s always putting strain on your codebase.</p><p></p><p></p><p>The remedy to cluelessness is not refactoring! As long as you don’t have a clue how a system under development’s surface should look like, you’re clueless. You can’t even come up with clear cut test cases.</p><p></p><p></p><p>It’s time for a different mode. Not the test-first mode, but an experimentation mode outside production code.</p><p></p><p></p><p>Luckily that’s not the case for the Diamond kata, though. That means my analysis is complete.</p><p></p><p></p><p>Bottom line: For me TDD always means ATDD (Acceptance Test-Driven Development). Don’t start work on production code before there is an acceptance test, i.e. a comprehensive test describing the required behavior.</p><p></p><p></p><p>An acceptance test to me is a guiding light or a north start. Once the acceptance tests are going green I know my job is done. I don’t mind them staying red for a longer while. I simply don’t execute them all the time ;-)</p><p></p><p></p><h2>2. Design</h2><p></p><p></p><p>With the acceptance tests implemented I continue by TBC. I ask myself:</p><p></p><p></p><ol><li>Can I partition the overall problem into smaller, complementary problems which I then solve independently?</li><li>Are there simpler problems nested inside the overall difficult one? Can I find a list of incremental tests?</li></ol><p></p><p></p><p>The second step is what TDD originally was about, I think. In my view, though, this only works well for very simple problems. It’s a not to be neglected question, but in my approach is not the first one to ask.</p><p></p><p></p><p>My first step is to look for more or less obvious sub-problems which I can solve more or less independently - hoping that the solutions to the sub-problems later can be integrated into a solution for the overall problem. Each sub-problem again will be represented by a function responsible for some partial behavior.</p><p></p><p></p><p>I’m using the good old „stepwise refinement“ approach, you could say. I’m recursively descending a problem tree.</p><p></p><p></p><p>And why not? Just because it’s an old approach doesn’t mean it’s not fit for the modern world.</p><p></p><p></p><p>But I’m using it with a twist! And that’s quite important for the clean code goal. My function hierarchies are free of functional dependencies. I’m not distributing logic vertically all over the hierarchy, but lump it together in the leaf functions, called <em>operations</em> according to the IOSP (Integration Operation Segregation Principle). That’s making a huge difference for understandability and testability!</p><p></p><p></p><p>Here’s what I came up with as a design for the Diamond kata:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2670"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-2-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-2-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-2-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-2-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-2-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-2-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-2-2-2xl.png 1600w" alt="" width="750" height="254"></figure></figure></div><p></p><p></p><p>It’s more precisely documenting my understanding of the problem and delivering a <em>model</em> for the implementation.</p><p></p><p></p><p>The model consists of yet more functions, but in addition to that also relations between those functions.</p><p></p><p></p><ul><li>There is a hierarchical relation: The original user facing function, the root function of the function tree depends on the other functions.</li><li>There are before-after or sequence relations: The partial functions will need to be called in a certain order.</li><li>There is an implicit aggregation relation: All functions will belong to the same module (class).</li></ul><p></p><p></p><p>Noteworthy of this kind of design is the absence of loops! To declarative and on a high level of abstraction a model needs to be free of imperative loops. Looping will occur in the end, but in the model it’s hidden.</p><p></p><p></p><p>This design process maybe takes me 10 minutes. The most effort goes into actually writing the results down for the purpose of this article.</p><p></p><p></p><p>Why should I not invest this short time up-front for design? It’s easy, and it delivers starting points for further tests. I don’t need to drive the implementation through the root function. That, to me, would feel artificial, and not simpler. And I would have to refactor more.</p><p></p><p></p><p>My design will produce clean code, I’m confident. Because the implementation will follow the IOSP.</p><p></p><p></p><p>Growing logic by applying tests primarily to the root function (and later refactor) is like <a href="https://de.wikipedia.org/wiki/Williams_Christ" target="_blank" rel="noopener noreferrer">growing a Bartlett inside a bottle</a>. I call that <em>pear programming</em>.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2669"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-1.tiff" alt=""></figure><figure class="alignnone size-medium wp-image-2684"><img loading="lazy" src="https://ralfw.de/media/posts/133/Williams_Christ_Obstbrand-172x300.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/Williams_Christ_Obstbrand-172x300-xs.jpg 300w, https://ralfw.de/media/posts/133/responsive/Williams_Christ_Obstbrand-172x300-sm.jpg 480w, https://ralfw.de/media/posts/133/responsive/Williams_Christ_Obstbrand-172x300-md.jpg 768w, https://ralfw.de/media/posts/133/responsive/Williams_Christ_Obstbrand-172x300-lg.jpg 1024w, https://ralfw.de/media/posts/133/responsive/Williams_Christ_Obstbrand-172x300-xl.jpg 1360w, https://ralfw.de/media/posts/133/responsive/Williams_Christ_Obstbrand-172x300-2xl.jpg 1600w" alt="" width="172" height="300"></figure></figure></div><p></p><p></p><p>Source: <a href="https://de.wikipedia.org/wiki/Williams_Christ" target="_blank" rel="noopener">Wikipedia</a></p><p></p><p></p><p>It can be done. It’s a piece of art, maybe. But I find that hard. The harder the more logic this way should be developed. Because that way it’s impossible to target pieces of logic with tests. All logic is always under test - unless you swap it out with <a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">substitutes</a>.</p><p></p><p></p><p>Substitutes, though, to me are additional complexity I want to avoid! I’m not saying they should not be used. But to base a programming approach on them is not my cup of tea.</p><p></p><p></p><h3>A KISS for design</h3><p></p><p></p><p>One argument against my approach, I hear, is that I’m not doing the simplest thing possible. Starting with a trivial test (even a degenerate test case) and then answering that with maybe only a singe line of production code would be much, much simpler. And it would immediately deliver a (small) value. And it would guarantee that no production code gets written without being covered by a test.</p><p></p><p></p><p>By now you can imagine: I beg to differ.</p><p></p><p></p><p>In fact I think my kind of design is the simplest thing you can do. I’m following the KISS principle to the letter.</p><p></p><p></p><p>Why? Because I don’t even implement a single line of code (at first). What’s simpler than writing code? Not writing code! That’s faster, that does not produce waste which later needs to be refactored.</p><p></p><p></p><p>Designing by stepwise refinement, by dissecting large problems into smaller ones is so simple because it „assumes“ that certain „services“ will be available. It does not care how they are going to be implemented. That’s details to wreck your brain about some other time.</p><p></p><p></p><p>The above list of functions is a wish list. I’m wishing for help: „How nice it would be to have a function that does X…“ or „What a relieve it would be to not worry about problem Y anymore because a function is taking care of that…“</p><p></p><p></p><p>If I cannot simplify a big problem by at least coming up with two partial problems which are smaller I guess I don’t really have a clue about what’s going on in the first place. Either I can solve a problem by writing the logic – or I can solve it by dissecting it into smaller, complementary problems.</p><p></p><p></p><p>With regard to the Diamond kata wishing for help could run like this:</p><p></p><p></p><ul><li>„Oh, there is a single input letter, but the diamond consists of multiple letters up until the input letter. I wish there was a function taking care of getting me this list. The rest then can be accomplished by another function.</li><li>„Hm… given a list of letters I need to generate the layers of the diamond. Half of them are unique. It would be nice to have a function doing that. Another one could then take care of building a full diamond from them.“</li><li>„Now that I have a list of letters the hard part is to generate a single layer with the right spacing. I wish there was a function for that. Generating layers for all letters then is simple based on that.“</li><li>„The most difficult thing about a layer is to get the number of leading spaces and separating spaces right. There should be a function calculating that for each layer. Arranging the letter in a layer based on that info then would be easy.“</li></ul><p></p><p></p><p>I find this most simple. And if it’s not then I need to double down on thinking the problem through or maybe go back to analysis. Not being able to come up with a „functional design“ to me is the first sign of cluelessness. I would not recommend to touch production code in such a state of mind.</p><p></p><p></p><h2>3. Implementation</h2><p></p><p></p><p>After design all’s prepared. At least that’s true in this simple case. I know all the functions that will be needed. I’ve a good feeling about this. If the problem was larger I would not have refined the whole function tree down to the last operation. Remember: I’m all for iterative and incremental progress. TBC with ADC is not about a resurrection of the waterfall.</p><p></p><p></p><p>Backed by the acceptance tests I now implement the functions I „uncovered“ during design in any order. I could start with the seemingly simplest or simply with the first one. It pretty much does not matter.</p><p></p><p></p><h3>Determine the layers</h3><p></p><p></p><p>The partial problem of determining the number of layers with their respective letters (layer names) I attack using… incremental tests. Inside my approach I’m using pretty much Chicago style TDD. You see why I’m calling it eclectic?</p><p></p><p></p><p>I come up with two tests growing in difficulty and implement the production code by going red-green-red-green.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2668"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-3-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-3-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-3-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-3-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-3-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-3-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-3-2-2xl.png 1600w" alt="" width="815" height="274"></figure></figure></div><p></p><p></p><p>There is nothing to refactor after the first test and not even after the second test. The function is so focused, so small.</p><p></p><p></p><p>You might find that the code to get the second red test to green does not seem simple. If so I say: To hell with simplicity! At that point I had a clear idea of how to solve the problem once and for all. Why not just write it down?</p><p></p><p></p><p>I could have used another test to drive out some pattern and refactor… but with this kind of small problem that seemed too much effort.</p><p></p><p></p><p>Or if you find the implementation lacking with regard to null boundary checks let me say: To hell with defensive programming! It’s not the responsibility of this function to check if the seed is in a certain range. If so, it just fails. There is not even a requirement to behave in a certain way in such a case. Why should I implement a solution to a non-existing requirement?</p><p></p><p></p><p>Defensive programming, I have to say, often is a form of procrastination. It’s applied to postpone solving the hard problems. It’s applied to ward off „friendly fire“ from code other team members might write. It thus is a substitute for the right thing to do: Doing real thinking about the real problem and drawing explicit trust boundaries during joint design sessions with other team members.</p><p></p><p></p><h3>Calculate layer whitespaces</h3><p></p><p></p><p>My approach again changes with the second function I implement: I go for a „one shot kill“: first a red test on an acceptance test level (for a partial problem), then all the necessary production code.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2672"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-4-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-4-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-4-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-4-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-4-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-4-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-4-2-2xl.png 1600w" alt="" width="797" height="215"></figure></figure></div><p></p><p></p><p>I’m not trying to crawl my way to a full solution with incremental tests because the solution is sitting right in front of me in the design. I’ve done „my math“ in the design document already; it was part of understanding the problem. Why shouldn’t I use that now?</p><p></p><p></p><p>And again: the operation is so small. The loop is following a pattern, the calculations are trivial. If the one test would fail it would be easy to detect the cause.</p><p></p><p></p><p>Of course the production code is benefiting from language features like <code>yield return</code>. No need to allocate a data structure to compile the results in. Also no need to define a data structure to carry both values for each layer. C# tuples as „ad hoc records“ are perfect for that.</p><p></p><p></p><p>Please note how only the number of layers is passed to the function. No need to let it know about the layer letters. That’s decoupling in the small. It’s made easier by designing the functions before implementation. Refactoring to this kind of decoupling later on would be harder.</p><p></p><p></p><h3>Generate the unique diamond layers</h3><p></p><p></p><p>The third partial problem again is different from the previous ones. I now realize it’s too difficult to solve right away or with incremental tests. So I revert to stepwise refinement once again.</p><p></p><p></p><p>The overall problem of generating the unique layers consists of the partial problem generating of generating just a single layer - and a remaining problem of doing that for all layer letters.</p><p></p><p></p><p>It’s a typical „N:1 problem“. Or you could call it a mapping problem: the same thing is done for each item in a collection. However here it’s two collections of the same length. The layer letters have to be „merged“ with the layer whitespace calculations.</p><p></p><p></p><p>What I do in this case I use a bottom up approach: first I implement the nested function for generating a single layer. I do that again with two incremental tests, red-green-red-green.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2674"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-5-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-5-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-5-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-5-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-5-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-5-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-5-2-2xl.png 1600w" alt="" width="1034" height="245"></figure></figure></div><p></p><p></p><p>The first version of the production code might seem not really according to KISS. Why include the <code>if</code>? For the first test this condition was not necessary.</p><p></p><p></p><p>Well… I guess my attention slipped a bit. I indulged in some look ahead. I knew a second test was coming which would need the conditional statement.</p><p></p><p></p><p>(While I was writing it I actually stopped for a second and mused about it… but I did not draw the right conclusion: not necessary right now, throw away.)</p><p></p><p></p><p>Please note the strange letter passed into the function: Why a <code>*</code> which is not a valid layer letter? This is my way of making obvious that this function does not care about „correct“ diamond characters. It’s focused on the layout of whatever it gets.</p><p></p><p></p><p>After I got the generation of a single layer working I move a one level up the function hierarchy. Doing one layer is integrated by a function for generating all unique layers:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2678"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-6-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-6-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-6-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-6-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-6-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-6-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-6-2-2xl.png 1600w" alt="" width="1059" height="178"></figure></figure></div><p></p><p></p><p>This one again is so easy, I just use a single test to drive its production code. I dare to do that because C# is offering powerful abstractions like Linq; there are no more loops to get right.</p><p></p><p></p><h3>Build diamond</h3><p></p><p></p><p>Finally I get to the function building the diamond from the layers. This again is so simple I just need one test:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2675"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-7-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-7-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-7-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-7-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-7-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-7-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-7-2-2xl.png 1600w" alt="" width="882" height="129"></figure></figure></div><p></p><p></p><p>As you can see the function consists of two parts. The levels of abstraction of its logic are not even: line 50 is slightly more abstract than line 51f. I need a bit more mental effort to understand what 51+52 are doing than what 50 does.</p><p></p><p></p><p>But in the end it’s such a small function I don’t think more structure is needed. Or maybe this is a case where comments would help?</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2680"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-8-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-8-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-8-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-8-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-8-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-8-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-8-2-2xl.png 1600w" alt="" width="398" height="167"></figure></figure></div><p></p><p></p><h3>Crossing the finish line</h3><p></p><p></p><p>That’s it. All functions from the design have been implemented. They are doing their partial jobs. That means all „musicians“ are ready, the instruments are tuned. It’s time for them to come together as a band and play a concert.</p><p></p><p></p><p>I do this by calling the partial functions from the root function:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2666"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-9-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-9-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-9-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-9-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-9-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-9-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-9-2-2xl.png 1600w" alt="" width="550" height="133"></figure></figure></div><p></p><p></p><p>Calling functions is the root function’s only responsibility. I call that <em>integration</em> (or composition) as opposed to <em>operation</em>. Operation is what the other functions are doing. They contain logic, they are the real workhorses of the solution.</p><p></p><p></p><p>(With the exception of <code>GenerateUniqueLayers</code> which I also view as an integration due to its shortness and usage of Linq, even though it’s not just calling another function but wrapping that.)</p><p></p><p></p><p>Coding the integration is easy by definition. It’s so easy in fact, that intermediate integrations in an IOSP-based function hierarchy hardly need testing at all. It’s the same as if you extracted a method during refactoring: you don’t put that under test immediately.</p><p></p><p></p><p>With the root function, the function which the user/customer is interested in, filled out I check the acceptance test cases from the beginning… And lo and behold they are both green!</p><p></p><p></p><p>I’m done with solving the original problem.</p><p></p><p></p><h3>Refactoring</h3><p></p><p></p><p>So far no refactoring seemed necessary. Due to TBC the code already is very clean, I’d say: all functions are small, the integration gives a good overview of how the problem is solved, the SRP reigns.</p><p></p><p></p><p>Now that I’m finished, though, I step back and try to imagine how a future reader of the code (possibly myself) would experience it.</p><p></p><p></p><p>The first thing I notice is that <code>Print</code> still is kind of fraught with details. I decide to extract another function:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2677"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-10-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-10-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-10-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-10-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-10-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-10-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-10-2-2xl.png 1600w" alt="" width="648" height="256"></figure></figure></div><p></p><p></p><p>Now <code>Print</code> tells the story what a diamond production looks like in three easy „sentences“: <em>First calculate the size of the diamond by determining the layers it should consist of. Then actually generate those layers, but only the unique ones. Finally build the diamond from the layers.</em></p><p></p><p></p><p>While reading this story no details of the processing steps are necessary to know. At first that’s what some developers cannot really accept; they tend to read the code depth-first. However, my approach favors breadth-first reasoning.</p><p></p><p></p><p>And <code>GenerateUniqueLayers</code> is yet another integration which is focused on layer generation. It’s hiding the details of that so <code>Print</code> can be shorter and more conforming to the SLA principle.</p><p></p><p></p><p>Although IOSP-based code is easy to understand due to many small methods and clearly visible processes, code sometimes cannot tell the full story. Why are things how they are, what do certain terms mean?</p><p></p><p></p><p>Even with this small example I felt that was the case. So I also added an introductory comment:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2671"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-11-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-11-2-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-11-2-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-11-2-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-11-2-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-11-2-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-11-2-2xl.png 1600w" alt="" width="695" height="399"></figure></figure></div><p></p><p></p><p>To me comments are not a code small per se. It’s what the comments are used for that is important. Background information, documentation of decisions, some kind of glossary… all that and more can be valuable in code.</p><p></p><p></p><h3>Deleting tests</h3><p></p><p></p><p>Finally, now that I’m satisfied with my solution, a fundamental act of refactoring. It’s almost unheard of, I’d say, but I’m doing it on a regular basis as part of my approach: I delete tests.</p><p></p><p></p><p>Yes, that’s true. I delete tests which would make future refactorings harder.</p><p></p><p></p><p>To see which tests are of no longterm use I simply set the accessibility of all methods to <code>private</code> which haven’t explicitly been ordered by the customer. Methods not used in acceptance tests are obviously not used and should be hidden as structural details.</p><p></p><p></p><p>All methods of the single class of my solution except for <code>Print</code> thus go <code>private</code>. And all tests exercising these methods go red and are deleted. That’s seven test functions.</p><p></p><p></p><p>The only remaining, stable, long term tests are the <em>acceptance tests</em>. Or more generally tests of methods which need to remain public on other classes I might have designed (or which were created during refactoring). Tests of methods on such classes which also haven’t been requested by the customer and might vanish at any time I call <em>module tests</em>.</p><p></p><p></p><p>And the tests which just got deleted to me are <em>scaffolding tests</em>. Like a scaffold on a building they were useful while building up the logic. But once the logic is complete they are torn down like a scaffold on a building. Otherwise they would impede future changes of the overall structure.</p><p></p><p></p><p>But isn’t it a waste of time to write those tests in the first place if they get thrown away? I don’t think so. They were of great help to develop logic function by function. They were like finely honed probes measuring some quality of my code at precise points. Also they can guide later decisions with regard to modularity: If I very much hesitate to delete a scaffolding test that might be a signal to extract a module on which the function under test is <code>public</code>.</p><p></p><p></p><p>I would not have been able to drive my logic test-first at such detail and in such isolation only with tests going through the root function. „Pear programming“ to me is too inflexible, too cumbersome. I like fine grained control over my logic and tests. I like to build my ship outside the bottle before I shove it in and erect the masts.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2676"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-12-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-12-1-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-12-1-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-12-1-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-12-1-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-12-1-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-12-1-2xl.png 1600w" alt="" width="389" height="259"></figure></figure></div><p></p><p></p><p>Source: <a href="https://www.wikihow.com/Build-a-Ship-in-a-Bottle" target="_blank" rel="noopener">wikiHow: How to Build a Ship in a Bottle</a></p><p></p><p></p><p>What I hear from developers trying one of the other TDD styles often is they feel trapped by all their tests. Refactoring becomes impossible without turning many tests red which then requires them to correct them.</p><p></p><p></p><p>I’m suffering much less from such effects. Because I keep less tests around.</p><p></p><p></p><p>The most important and long living tests are the acceptance tests. They exercise the logic in a solid way.</p><p></p><p></p><p>Module tests complement acceptance tests; they knit the safety net more finely. But if they turn red due to refactoring I’m very willing to throw them away instead of repairing them.</p><p></p><p></p><h2>Summary</h2><p></p><p></p><p>Hamburg style TDD is about thinking before coding, the absence of functional dependencies (substitutes are comparatively rarely used), and also about the „art of letting go“. Don’t attach yourself too much to your tests.</p><p></p><p></p><p>It’s an outside-in approach to problem solving and programming.</p><p></p><p></p><hr><p>PS: You might be wondering if all this leads to overengineering. So many functions… isn’t that much overhead?</p><p></p><p></p><p>Well… this is the alternative: The same logic sitting in just a single function.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2673"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-13-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-13-1-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-13-1-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-13-1-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-13-1-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-13-1-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-13-1-2xl.png 1600w" alt="" width="605" height="349"></figure></figure></div><p></p><p></p><p>Is that, what you like to see when asked to fix a bug? Multiply the number of lines by 2, 5, 10, 50 because that’s how long functions in „real code bases“ usually are; even methods with 5000 lines of code and more are not unheard of.</p><p></p><p></p><p>Functions not following the IOSP tend to grow indefinitely. There are no boundaries to growth. And the general recommendation „keep your functions small“ is pretty fuzzy. What does „small“ exactly mean? And where to stop, what else to do?</p><p></p><p></p><p>The IOSP is a great guideline towards codebases with all small functions.</p><p></p><p></p><p>But the above function still is small. Why have more than one function? Reason no. 1: Because this is an exercise. Reason no. 2: Even small functions can contain logic that is hard to get right. Wouldn’t you want to be able to check that easily?</p><p></p><p></p><p>But the above function is not what a classic TDD approach – aka „pear programming“ – would have led to. Fewer functions would have been extracted from the growing logic in the single function under test.</p><p></p><p></p><p>That’s true. But firstly refactoring is hard and easy to avoid. Secondly the result probably would have been a root function not conforming to the SLA: there would be a mixture of logic and function calls in it. That would not be easy to understand.</p><p></p><p></p><p>Finally I find code refactored from functions with functional dependencies and driven by TDD often not easy to read because it’s hard to extract responsibilities cleanly once they were entwined. Sure, not to refactor is no solution. But not having to refactor due to a clean design before coding leads to better results in my experience.</p><p></p><p></p><p> </p><p>PPS: It’s never over! Today’s clean code is tomorrows dirty code.</p><p></p><p></p><p>Cleanliness of code is subjective and relative to your understanding/knowledge. If you gain new insights clean code you wrote yesterday will turn into somewhat dirty code.</p><p></p><p></p><p>A case in point the <code>BuildDiamond</code> function. I expressed some concern regarding it and even suggested comments to improve it. But just know I had another idea:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2681"><img loading="lazy" src="https://ralfw.de/media/posts/133/DraggedImage-14-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/133/responsive/DraggedImage-14-1-xs.png 300w, https://ralfw.de/media/posts/133/responsive/DraggedImage-14-1-sm.png 480w, https://ralfw.de/media/posts/133/responsive/DraggedImage-14-1-md.png 768w, https://ralfw.de/media/posts/133/responsive/DraggedImage-14-1-lg.png 1024w, https://ralfw.de/media/posts/133/responsive/DraggedImage-14-1-xl.png 1360w, https://ralfw.de/media/posts/133/responsive/DraggedImage-14-1-2xl.png 1600w" alt="" width="425" height="111"></figure></figure></div><p></p><p></p><p>This to me is cleaner. It’s the same functionality, hence I call it a refactoring. But instead of extracting structures I redesign the approach to solving this partial problem and implemented it using more of the power of Linq. Now the function shows better SLA; no comments are needed.</p><p></p><p></p><p>I changed the logic even without the scaffolding tests being present anymore. I was confident the acceptance tests would catch any regression.</p><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 28.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/tdd/">TDD</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/hamburg-style-tdd/" class="invert post__nav-link" rel="prev"><span>Previous</span> Hamburg Style TDD</a></div><div class="post__nav-next"><a href="https://ralfw.de/co-creation-at-work/" class="invert post__nav-link" rel="next"><span>Next</span> Co-creation at work </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>