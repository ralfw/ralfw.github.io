<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sleepy Hollow Architecture - No application should be without it - ralfw-de</title><meta name="description" content="There is a basic structure of software systems I’m drifting towards more and more. To me it’s more fundamental than MVC or Layered Architecture or Clean Architecture. I call it the Sleepy Hollow Architecture because it’s about dissecting code into two parts: a body and&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/sleepy-hollow-architecture-no-application-should-be-without-it/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Sleepy Hollow Architecture - No application should be without it"><meta property="og:image" content="https://ralfw.de/media/posts/123/DraggedImage-5.png"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="There is a basic structure of software systems I’m drifting towards more and more. To me it’s more fundamental than MVC or Layered Architecture or Clean Architecture. I call it the Sleepy Hollow Architecture because it’s about dissecting code into two parts: a body and&hellip;"><meta property="og:url" content="https://ralfw.de/sleepy-hollow-architecture-no-application-should-be-without-it/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Sleepy Hollow Architecture - No application should be without it"><meta name="twitter:description" content="There is a basic structure of software systems I’m drifting towards more and more. To me it’s more fundamental than MVC or Layered Architecture or Clean Architecture. I call it the Sleepy Hollow Architecture because it’s about dissecting code into two parts: a body and&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/posts/123/DraggedImage-5.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/sleepy-hollow-architecture-no-application-should-be-without-it/"},"headline":"Sleepy Hollow Architecture - No application should be without it","datePublished":"2019-05-05T19:30","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.de/media/posts/123/DraggedImage-5.png","height":452,"width":746},"description":"There is a basic structure of software systems I’m drifting towards more and more. To me it’s more fundamental than MVC or Layered Architecture or Clean Architecture. I call it the Sleepy Hollow Architecture because it’s about dissecting code into two parts: a body and&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><script type="text/javascript">var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/606e06a2f7ce1827093813ae/1f2msm5ed';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();</script><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first Codierung🇩🇪</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design🇩🇪</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">Blogs🇩🇪🇬🇧</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. 🇩🇪🇬🇧</a></li><li><a href="https://blog.ralfw.de/" target="_blank">🌐2007..2015🇩🇪</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">🌐2008..2015🇬🇧</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">🌐2003..2010🇬🇧</a></li><li><span class="is-separator">─────────</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">🌐Zur Soziokratie🇩🇪</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">🌐Gedankliche Umtriebe🇩🇪</a></li><li><a href="https://medium.com/personal-flow" target="_blank">🌐Personal Flow🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.de/media/posts/123/DraggedImage-5.png" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-5-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="452" width="746" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-05-05T19:30">05.05.2019</time></div><h1>Sleepy Hollow Architecture - No application should be without it</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>There is a basic structure of software systems I’m drifting towards more and more. To me it’s more fundamental than MVC or Layered Architecture or Clean Architecture. I call it the <em>Sleepy Hollow Architecture</em> because it’s about dissecting code into two parts: a body and a head.</p><p></p><p></p><p>Do you remember the movie <a href="https://www.imdb.com/title/tt0162661/">Sleepy Hollow</a> by Tim Burton? Starring Johnny Depp and Christina Ricci among other well-known actors. It’s revolving around a headless horseman terrorizing the town of Sleepy Hollow.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2485"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-2xl.png 1600w" alt="" width="651" height="397"></figure></figure></div><p></p><p></p><p>I’d call the headless horseman one of the main characters, even though it’s just a body without a head.</p><p></p><p></p><p>But the movie also tells the story of how he lost his head. So the head also plays a role in the movie, albeit a small(er) one, even though Christopher Walken is the actor in those scenes.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2471"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-1-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-1-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-1-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-1-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-1-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-1-2xl.png 1600w" alt="" width="649" height="344"></figure></figure></div><p></p><p></p><p>In <em>Sleepy Hollow</em> what usually is seen as a single unit – or a monolith, I could say – is fundamentally split into two sub-units of unequal importance.</p><p></p><p></p><p>And that’s what I think should be done with software, too. Let me even be so bold as to say: with every software.</p><p></p><p></p><h2>A fundamental distribution of code</h2><p></p><p></p><p>In my view software should consist of a body and a head, too. And the really important part then is the body. It can even be used without a head. Or it can be given different heads.</p><p></p><p></p><p>Usually a software is seen as „one thing“ with a basic anatomy working in an environment:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2474"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-2-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-2-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-2-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-2-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-2-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-2-2xl.png 1600w" alt="" width="499" height="251"></figure></figure></div><p></p><p></p><p>There is a user interacting with it (left side), there are resources used by it (right side).</p><p></p><p></p><p>The code inside is partly dedicated to the interaction with the user, it’s (G)UI code and maybe some validations; let’s call that the frontend (yellow area in above image). But mostly it’s domain logic and resource access; let’s call that the backend (brown area).</p><p></p><p></p><p>Unfortunately both aspects of the code are often quite entangled. And even if they weren’t it would be hard to test the bulk of the code, the backend. Testing frontend code or testing the backend through the frontend is technically possible, but usually not much fun and brittle.</p><p></p><p></p><p>That’s why I suggest a fundamental separation of both aspects! Frontend and backend should be physically very distinct, if not not even two processes. We should pull out the frontend from the software. We should unstick it from the backend.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2472"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-3.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-3-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-3-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-3-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-3-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-3-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-3-2xl.png 1600w" alt="" width="501" height="269"></figure></figure></div><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2476"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-4.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-4-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-4-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-4-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-4-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-4-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-4-2xl.png 1600w" alt="" width="500" height="223"></figure></figure></div><p></p><p></p><p>Until it’s a free standing aspect - and why not in it’s own process. Head and body separated. The backend now being headless domain and resource logic.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2479"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-5.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-5-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-5-2xl.png 1600w" alt="" width="494" height="299"></figure></figure></div><p></p><p></p><p>The minimal version of this would be frontend and backend being two components with a distinct contract. But even two processes running on the same machine would not hurt much in most cases, I guess. The frontend process could host the backend process; no additional infrastructure required.</p><p></p><p></p><p>That would mean distribution, but on a small scale. This kind of distribution would be not for scalability or security, but for increased testability and adaptability/flexibility.</p><p></p><p></p><p>Communication would happen in a message oriented manner:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2484"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-6.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-6-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-6-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-6-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-6-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-6-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-6-2xl.png 1600w" alt=""></figure></figure></div><p></p><p></p><p>That way even different heads „could be screwed on“ the backend.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2481"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-7.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-7-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-7-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-7-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-7-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-7-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-7-2xl.png 1600w" alt="" width="493" height="326"></figure></figure></div><p></p><p></p><p>Again, this is not about the usual client-server distribution for scalability purposes. It’s more fundamental!</p><p></p><p></p><p>I strongly believe that one of the most common fallacies in software development is that the frontend should be „welded to“ the backend. Up to the point of SQL statements in button click event handlers. (Yes, I have seen horrible stuff like that.)</p><p></p><p></p><p>There are two problems with this: aspects get scattered all over the codebase and testability is low.</p><p></p><p></p><p>With the Sleepy Hollow Architecture it’s different. Two fundamental aspects are clearly separated with a distinct contract between them.</p><p></p><p></p><p>The head is where users interact with the software: they trigger behavior by pressing buttons or clicking a menu item or just hitting ENTER. Behavior is an observable change of state. Software reacts to input data with output data.</p><p></p><p></p><p>How the input data is gathered from the user is a matter of the frontend. How the output data is presented to the user is a matter of the frontend.</p><p></p><p></p><p>The backend is only concerned with transforming input data into output data while using resources. It’s oblivious to how the arriving data structures got built or how leaving data structures are used.</p><p></p><p></p><h2>Head-body communication</h2><p></p><p></p><p>The contract between head and body is a set of messages. I’ve come to like the following classification. It’s based on the <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">CQS principle</a>.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2486"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-8.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-8-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-8-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-8-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-8-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-8-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-8-2xl.png 1600w" alt="" width="650" height="591"></figure></figure></div><p></p><p></p><p>Incoming messages at the backend are either commands or queries. They both are requests.</p><p></p><p></p><p><strong>Commands</strong> trigger some kind of state change in the backend (or connected resources) and return a status information about how that went.</p><p></p><p></p><p><strong>Queries</strong> just work on the state as it is. They cause the delivery of a result as an outgoing message.</p><p></p><p></p><p><strong>Status</strong> and <strong>result</strong> both as responses to requests.</p><p></p><p></p><p><strong>Notifications</strong> are events received from the environment (i.e. other software systems). They are not issued by a user with the intention of „hearing back“ from the receiving system.</p><p></p><p></p><p>But notifications don’t just flow into a backend. Backends might also send out notifications with the intention to inform other interested parties (of which they don’t know) about what’s going on.</p><p></p><p></p><p>Notifications are usually not created by visual frontends, I’d say.</p><p></p><p></p><p>The purpose of the backend now is very focused: message handling. Whether messages arrive through an in-proc call or through HTTP or a named pipe is of no concern to the Sleepy Hollow Architecture. It’s the mindset that counts. It’s the will to a clear separation of frontend and backend while connecting both with an explicit message contract.</p><p></p><p></p><p>So much for theory and concepts. But how does that look in code?</p><p></p><p></p><h2>An example application</h2><p></p><p></p><p>Here’s a scenario:</p><p></p><p></p><blockquote class="wp-block-quote"><p>I’d like a software to help me observe the stock market. I can create a portfolio of stocks and check how the portfolio is doing. Adding a stock is like simulating a buy.</p></blockquote><p></p><p></p><p>From that I derive a simple UI:</p><p></p><p></p><pre class="wp-block-code"><code>$ portfoliomanager
1. Microsoft (MSFT), bought: 3x99.00=297.00, current: 3x115.00=345.00 - +48.00 / +48,5%
2. Apple (AAPL), bought: 5x156.00=780.00, current: 5x179.00=895.00 - +115.00 / +14.7%
Portfolio value: 1240.00 / +15.1%

::: B(uy, S(ell, D(isplay, U(pdate, eX(it?: B

Identification?: Thermo fisher
1. Thermo Fisher Scientific Inc
2. Thermo-electric power station Maritza 3 JSC
3. Vikram Thermo (India) Ltd Dematerialised
...
Choose no.?: 1

Name: Thermo Fisher Scientific Inc
Symbol: TMO
Current: 243.90
Qty?: 4

Total paid: 975.60

::: B(uy, S(ell, D(isplay, U(pdate, eX(it?: S

Identification?: apple

1. Apple (AAPL)

Index of stock to sell?: 1

Sold 'Apple (AAPL)'!

::: B(uy, S(ell, D(isplay, U(pdate, eX(it?: D

1. Microsoft (MSFT), bought: 3x99.00=297.00, current: 3x115.00=345.00 - +48.00 / +48.5%
2. Thermo Fisher (TMO), bought: 4x243,90.00=975.90, current: 4x244.10=976.40 - +0.50 / +0.00%
Portfolio value: 1321.40 / +3.8%

::: B(uy, S(ell, U(pdate, eX(it: X
$
</code></pre><p></p><p></p><p>(Sorry, it’s no fancy GUI. But I’m not into WPF/WinForms anymore since I’m only using a Mac.)</p><p></p><p></p><h3>Messages needed</h3><p></p><p></p><p>What messages would flow between frontend and backend for this?</p><p></p><p></p><ul><li>A command to update the portfolio with current stock prices. A call to some online service will be necessary, e.g. <a href="https://www.alphavantage.co/documentation/">Alpha Vantage</a>.</li><li>A query to get the current portfolio.</li><li>A command to buy.</li><li>A query to list candidate stocks matching the identification provided. A call to some online service will be necessary.</li><li>A command to sell.</li><li>A query to find the stock in the portfolio best matching a search pattern.</li></ul><p></p><p></p><p>With these incoming messages in hand I can now start building the application incrementally message by message. And I can even start building it starting from the backend. Or I could outsource the frontend to be worked on in parallel.</p><p></p><p></p><p>Admittedly some more details are needed for the incoming (and respective outgoing) messages. But that’s not the point here. I want to show you how I think this could look in code with a Sleepy Hollow Architecture.</p><p></p><p></p><h3>Code structure</h3><p></p><p></p><p>The Sleep Hollow Architecture is a „poor man’s Layered Architecture“, you could say: it consists of just two layers instead of three or four. This is mirrored in the basic code structure. I created 2+1 C# assemblies (libraries) to represent head and body, frontend and backend:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2470"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-9.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-9-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-9-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-9-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-9-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-9-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-9-2xl.png 1600w" alt="" width="265" height="74"></figure></figure></div><p></p><p></p><p>And both libraries depend on a third: the contract. It’s there that the backend’s main interface is defined plus all the messages.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2483"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-10.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-10-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-10-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-10-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-10-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-10-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-10-2xl.png 1600w" alt=""></figure></figure></div><p></p><p></p><p>In addition it contains some more interfaces and data types, but that’s not really of concern here. It’s a detail of the backend implementation.</p><p></p><p></p><p>Although head and body don’t know of each other due to the Dependency Inversion Principle (DIP) – the body implements the common contract, the head uses the common contract –, at runtime there still exists a dependency: the head is calling the body because the head alone is pretty useless. Its sole purpose is to make interaction of the user with the body easier.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2475"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-11.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-11-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-11-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-11-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-11-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-11-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-11-2xl.png 1600w" alt="" width="489" height="264"></figure></figure></div><p></p><p></p><p>Over the past years I’ve developed this strange view that user interfaces are data structure editors and data structure projectors. Human users only need them because they don’t want to or cannot (due to complexity and time constraints) edit and interpret JSON data structures. In principle only backends are needed to create desired output data from input data. In principle humans could feed the input data as JSON text and receive output data as JSON text (or XML or any other data format you like). It’s just that it would be more tedious and error prone. That’s why (graphical) user interfaces were invented: they are tools which allow mere mortals to create data structures and view data structures without even realizing it. No more, no less.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2482"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-12.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-12-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-12-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-12-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-12-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-12-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-12-2xl.png 1600w" alt="" width="687" height="162"></figure></figure></div><p></p><p></p><p>That’s not to say user interface are not important. Right to the contrary! Without them most backends would be useless. It’s an art to design a truly helpful user interface! We need more people being good at that.</p><p></p><p></p><p>However that should not mean user interfaces need to be „close to“ their backends in any way. Also right to the contrary! User interfaces – heads – and backends – bodies – are so different as two sides of the software medal they should be very, very clearly separated. That’s what the Sleepy Hollow Architecture is about.</p><p></p><p></p><p>If you don’t have much of a clue as to how to architecture your software, do yourself at least the favour of chopping the head off! You’ll be rewarded with</p><p></p><p></p><ul><li>better testability</li><li>easier incremental development</li><li>more options for further decomposition</li><li>a starting point for division of labor</li></ul><p></p><p></p><p>But now on with the code…</p><p></p><p></p><p>The head needs the body at runtime. How is the body attached to it? That’s the responsibility of an „integrating code unit“ I put into yet another assembly:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2477"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-13.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-13-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-13-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-13-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-13-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-13-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-13-2xl.png 1600w" alt="" width="464" height="142"></figure></figure></div><p></p><p></p><p>And there you have it: that’s how the Sleepy Hollow Architecture can be implemented.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2487"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-14.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-14-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-14-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-14-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-14-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-14-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-14-2xl.png 1600w" alt="" width="348" height="356"></figure></figure></div><p></p><p></p><p>But that’s only the start! With a clean contract between head and body you can do more:</p><p></p><p></p><h3>Distribution</h3><p></p><p></p><p>Do frontend and backend need to be implemented with the same programming language/platform? I’m using C# for both, but that’s not really necessary. Since head and body are based on a common contract which defines messages flowing back and forth it’s easy to separate them even further.</p><p></p><p></p><p>Yes, that’s the secret of the Sleepy Hollow Architecture, I’d say: a shared message contract instead of a shared stateful data model. Whatever state is needed is a private matter of head and/or backend. No state is „leaked“ to the other code body part.</p><p></p><p></p><p>I’m not against state in any way. In-memory state in the frontend is just fine for me. Likewise I’m not offended by in-memory state in the backend. Maybe things would be better without it, but that’s not a matter of the Sleepy Hollow Architecture. Use in-memory state or just persistent state to share information across incoming messages or between different message handlers. The really important thing is:</p><p></p><p></p><blockquote class="wp-block-quote"><p>There is no state shared between head and body!</p></blockquote><p></p><p></p><p>If you manage to do that, then head and body can be pulled further apart into different processes.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2473"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-15.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-15-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-15-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-15-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-15-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-15-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-15-2xl.png 1600w" alt="" width="633" height="355"></figure></figure></div><p></p><p></p><p>Technically this is a client-server or 2-tier architecture. But how far apart head and body are located is not a matter of the Sleepy Hollow Architecture. They could reside on different devices or on the same. Yes, even on the same device would make sense to me: a frontend process could start its own backend process. Why not? Google Chrome is doing that for every page you open.</p><p></p><p></p><p>The benefits would be stability, productivity, flexibility or just independence in general because now you’d be free to use whatever programming platform you like to implement them. Use C# with WinForms for the frontend and Rust for the backend. Or use JavaScript and Java? Or Java and F#? Whatever suites you best. (If you ever wondered whether micro services are for you here’s a scenario to get you feet wet with. To me head and body processes are micro service because the purpose behind them is evolvability, not runtime efficiency.)</p><p></p><p></p><p>Also you can start with either body part. I, for example, started with the backend. Only after the backend was finished and covered by acceptance tests exercising the message handler I started working on the frontend.</p><p></p><p></p><p>Since I used C# for head and body I hosted both in the same process at first. A monolithic, yet component oriented application still is easiest to build. Once that was working, though, I separated the body from the head.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2480"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-16.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-16-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-16-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-16-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-16-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-16-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-16-2xl.png 1600w" alt="" width="314" height="279"></figure></figure></div><p></p><p></p><p>I built a backend server to host just the backend and make it accessible through a HTTP controller.</p><p></p><p></p><p>And I built an integrating server to host the frontend – and also start the backend server.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2478"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-17.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-17-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-17-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-17-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-17-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-17-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-17-2xl.png 1600w" alt=""></figure></figure></div><p></p><p></p><p>The user interface does not realize it’s now talking to a backend in another process. The proxy injected into it is looking like „the real thing“.</p><p></p><p></p><p>To be able to do this trick with head and body – almost like a magician sawing a woman in half – I like to use dedicated types for the messages flowing to and from the backend. Here’s an example:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2488"><img loading="lazy" src="https://ralfw.de/media/posts/123/DraggedImage-18.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/DraggedImage-18-xs.png 300w, https://ralfw.de/media/posts/123/responsive/DraggedImage-18-sm.png 480w, https://ralfw.de/media/posts/123/responsive/DraggedImage-18-md.png 768w, https://ralfw.de/media/posts/123/responsive/DraggedImage-18-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/DraggedImage-18-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/DraggedImage-18-2xl.png 1600w" alt=""></figure></figure></div><p></p><p></p><p>This seems to be an overhead at first. Wouldn’t a method do with a more specific signature, e.g. <code>Portfolio Load()</code>? Sure that would do the trick, too. But it’s less versatile/flexible and requires me to think more.</p><p></p><p></p><ul><li>With individual method signatures I’d need to think more because I’d immediately need to decide which name and parameters to give the method. To follow the CQS and define two messages is much less of a mental burden. With message types I just have to define two classes with a pretty obvious name following a simple convention.</li><li>And I find methods with a variable number of parameters harder to use in different scenarios. If backend message handlers follow the rule of always being functions with exactly one parameter lot’s of things become easier (tooling, distribution). Also messages packed into data structures are easier to route or cache if need be.</li></ul><p></p><p></p><p>The Sleepy Hollow Architecture does not require such message types. But whenever I started without them, trying to optimize for some crude notion of productivity, I came to regret it sooner than later. Maybe, just maybe, such a contract with explicit message types makes you somewhat slower in the beginning. In the long run, though, I’ve come to realize it was always worth it – and should be done right from the start.</p><p></p><p></p><h2>Summary</h2><p></p><p></p><p>To me the Sleepy Hollow Architecture is the default architecture for any software. Less structure, less separation of concerns don’t work for me. I’d almost say, it’s the first architectural pattern to teach newbie programmers.</p><p></p><p></p><p>Distribution of head and body is not necessary. But „near-tier“ isn’t that difficult, either. Maybe it’s even a motivation to introduce simple cross-process communication in the first place, since the efficiency demands are not high in this relationship between client and server.</p><p></p><p></p><p>In any case the Sleep Hollow Architecture is an easy means to make the different responsibilities of frontend and backend clear. And not the least it’s an excellent foundation for test-first development and putting much of an application under automatic test. The real workhorse, the real warrior is the body, the backend. That needs to be tightly monitored, there’s lots of refactoring about to happen. The head, the UI, might look horrible, but in the end it’s useless without a solid body. And I’d even say it’s easier to focus on if a body does not „dangle“ beneath it all the time.</p><figure class="alignnone wp-image-2520"><img loading="lazy" src="https://ralfw.de/media/posts/123/githublogo-150x150.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/githublogo-150x150-xs.png 300w, https://ralfw.de/media/posts/123/responsive/githublogo-150x150-sm.png 480w, https://ralfw.de/media/posts/123/responsive/githublogo-150x150-md.png 768w, https://ralfw.de/media/posts/123/responsive/githublogo-150x150-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/githublogo-150x150-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/githublogo-150x150-2xl.png 1600w" alt="" width="30" height="30"></figure> <a href="https://github.com/ralfw/architecture-variations/tree/master/01%20sleepy%20hollow%20architecture" target="_blank" rel="noopener">[GitHub Repository with sample code]</a><p></p><figure class="alignnone wp-image-2521"><img loading="lazy" src="https://ralfw.de/media/posts/123/redditlogo-150x150.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/123/responsive/redditlogo-150x150-xs.png 300w, https://ralfw.de/media/posts/123/responsive/redditlogo-150x150-sm.png 480w, https://ralfw.de/media/posts/123/responsive/redditlogo-150x150-md.png 768w, https://ralfw.de/media/posts/123/responsive/redditlogo-150x150-lg.png 1024w, https://ralfw.de/media/posts/123/responsive/redditlogo-150x150-xl.png 1360w, https://ralfw.de/media/posts/123/responsive/redditlogo-150x150-2xl.png 1600w" alt="" width="30" height="30"></figure> <a href="https://www.reddit.com/r/softwarearchitecture/comments/bn967r/sleepy_hollow_architecture_separate_head_from/" target="_blank" rel="noopener">[Use reddit to discuss the Sleepy Hollow Architecture if you like.]</a><p></p><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/software-architecture/">Software architecture</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/the-srp-is-not-about-extract-till-you-drop/" class="invert post__nav-link" rel="prev"><span>Previous</span> The SRP is not about „extract till you drop!“</a></div><div class="post__nav-next"><a href="https://ralfw.de/terminus-architecture/" class="invert post__nav-link" rel="next"><span>Next</span> Terminus Architecture </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>