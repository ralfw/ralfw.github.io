<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Tests als evolutionÃ¤re Kraft - One Man Think Tank</title><meta name="description" content="Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den KrÃ¤ften, die an ihr wirken, am besten standhalten kann. Dass Software gewÃ¼nschte FunktionalitÃ¤t zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewÃ¼nsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/tests-als-evolutionaere-kraft/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Tests als evolutionÃ¤re Kraft"><meta property="og:image" content="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den KrÃ¤ften, die an ihr wirken, am besten standhalten kann. Dass Software gewÃ¼nschte FunktionalitÃ¤t zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewÃ¼nsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;"><meta property="og:url" content="https://ralfw.de/tests-als-evolutionaere-kraft/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Tests als evolutionÃ¤re Kraft"><meta name="twitter:description" content="Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den KrÃ¤ften, die an ihr wirken, am besten standhalten kann. Dass Software gewÃ¼nschte FunktionalitÃ¤t zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewÃ¼nsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=70c495896d35fb7ee94e0c9d9b4f04e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/tests-als-evolutionaere-kraft/"},"headline":"Tests als evolutionÃ¤re Kraft","datePublished":"2015-11-01T18:58","dateModified":"2021-01-29T15:25","image":{"@type":"ImageObject","url":"https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png","height":684,"width":1190},"description":"Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den KrÃ¤ften, die an ihr wirken, am besten standhalten kann. Dass Software gewÃ¼nschte FunktionalitÃ¤t zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewÃ¼nsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first CodierungğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-DesignğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit SlicingğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">BlogsğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/" target="_self">2015.. ğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a></li><li><a href="https://blog.ralfw.de/" target="_blank">ğŸŒ2007..2015ğŸ‡©ğŸ‡ª</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">ğŸŒ2008..2015ğŸ‡¬ğŸ‡§</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">ğŸŒ2003..2010ğŸ‡¬ğŸ‡§</a></li><li><span class="is-separator">â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">ğŸŒZur SoziokratieğŸ‡©ğŸ‡ª</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">ğŸŒGedankliche UmtriebeğŸ‡©ğŸ‡ª</a></li><li><a href="https://medium.com/personal-flow" target="_blank">ğŸŒPersonal FlowğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png" srcset="https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="684" width="1190" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2015-11-01T18:58">01.11.2015</time></div><h1>Tests als evolutionÃ¤re Kraft</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den KrÃ¤ften, die an ihr wirken, am besten standhalten kann.</p><p>Dass Software gewÃ¼nschte FunktionalitÃ¤t zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewÃ¼nsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in vielen FÃ¤llen auch nichts mit ihrer Struktur zu tun. FÃ¼r FunktionalitÃ¤t wie Effizienzen ist lediglich <a href="https://programming-with-ease.circle.so/c/articles/logic-makes-the-software-turn-around" target="_blank" rel="noopener noreferrer">Logik</a> verantwortlich â€“ und die braucht keine Struktur, um ihren Effekt zu entfalten.</p><p>Das ist leicht zu verstehen, wenn Sie daran denken, dass im finalen Maschinencode all Ihre schÃ¶nen Strukturen ja nicht mehr zu finden sind und die Software trotzdem das gewÃ¼nschte Verhalten zeigt.</p><p>Was verstehe ich unter Struktur? Elemente, die in Beziehung stehen. Also eine gewisse Anordnung von Dingen. Diese "Dinge" in der Software sind zunÃ¤chst einmal Module, d.h. Funktionen, Klassen, Bibliotheken usw. Und die Beziehungen zwischen ihnen sind vor allem Nutzungsbeziehungen: ein Modul kennt ein anderes, um dort eine Dienstleistung zu nutzen.</p><p>(Datenstrukturen lasse ich hier ausdrÃ¼cklich aus. Die arrangieren ja keine Logik, sondern eben Daten.)</p><p>Und was sind die KrÃ¤fte, die auf die Softwarestruktur wirken? VerÃ¤nderungen. Softwarestruktur soll Code wandelbar machen.</p><p>Wandelbar ist Code, wenn er leicht verstÃ¤ndlich ist, wenn sich VerÃ¤nderungen zur Herstellung neuer FunktionalitÃ¤t oder Effizienz leicht anbringen lassen und wenn man leicht feststellen kann, ob das Neue schon korrekt implementiert ist wie auch das Alte immer noch korrekt arbeitet. Testbarkeit ist mithin ein Kriterium fÃ¼r Wandelbarkeit. Tests sind ein Teil der Kraft, die auf Softwarestrukturen einwirken.</p><p>In Bezug auf Tests habe ich mich nun gefragt, wie sich Strukturen dadurch verÃ¤ndern? Wie setzt Software Tests mÃ¶glichst wenig Widerstand entgegen?</p><p>Mir scheint es da eine natÃ¼rliche Entwicklung zu geben, quasi eine Evolution:</p><h2>Ohne Prinzipien</h2><p>Alles beginnt mit ein bisschen Produktionscode und einem Test:</p><figure class="alignnone wp-image-402"><a href="https://ralfw.de/media/posts/17/img_5633692eb7a45.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_5633692eb7a45.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-2xl.png 1600w" alt="" width="119" height="189"></a></figure><p></p><p>Produktionscode und Test enthalten Logik. Die Logik des Produktionscodes stellt das vom Kunden gewÃ¼nschte Verhalten her. Hoffentlich jedenfalls ;-) Und die Logik des Tests prÃ¼ft das.</p><p>Beide Logiken sind getrennt in verschiedene Module, zumindest unterschiedliche Funktionen. Es entsteht also schon eine minimale Struktur.</p><p>Ein Test reicht natÃ¼rlich nicht aus. Der Produktionscode hat verschiedene Aspekte, die jede fÃ¼r sich Ã¼berprÃ¼ft werden wollen. Also sieht die Struktur zumindest so aus:</p><figure class="alignnone wp-image-403"><a href="https://ralfw.de/media/posts/17/img_56336cc142b98.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56336cc142b98.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-2xl.png 1600w" alt="" width="234" height="220"></a></figure><p></p><p>Alle Verhaltensaspekte sind in der Funktion des Produktionscodes zusammengemischt; die verhaltensindividuellen Tests setzen daher alle an der einen Funktion an.</p><p>Das kann man schon so machen... aber dann ist es halt kaum mÃ¶glich, wirklich nur einen Aspekt zu testen. Die Logik aller anderen Aspekte wird in der einen Produktionscodefunktion immer mehr oder weniger mit durchlaufen.</p><h2>Mit IoC</h2><p>Um gezielter Aspektlogik testen zu kÃ¶nnen, wird empfohlen, das Prinzip <em>Inversion of Control</em> (IoC) anzuwenden. Dadurch lassen sich im Test gezielt uninteressante Aspekte ausblenden, indem man sie mit einem <a href="http://stackoverflow.com/questions/346372/whats-the-difference-between-faking-mocking-and-stubbing" target="_blank" rel="noopener">Mock/Stub/Fake</a> ersetzt.</p><figure class="alignnone wp-image-404"><a href="https://ralfw.de/media/posts/17/img_56337154d8546.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56337154d8546.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56337154d8546-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-2xl.png 1600w" alt="" width="558" height="431"></a></figure><p></p><p>Der Produktionscodeaspekt wird ausgelagert in eine eigene Funktion und dort fÃ¼r sich getestet.</p><p>Eingebunden wird er zwischen den verbleibenden Aspekten in der ursprÃ¼nglichen Funktion jedoch nicht durch direkten Aufruf, sondern Ã¼ber eine Indirektion. Die ursprÃ¼ngliche Funktion kennt nur noch eine Abstraktion des ausgelagerten Aspekts, z.B. ein Interface, auf dem er eine Methode darstellt. Dieses Interface implementiert die Klasse, in die der Aspekte ausgelagert wurde.</p><p>Ebenso implementiert dieses Interface ein Mock/Stub/Fake, den andere Tests nutzen, um fÃ¼r sich den ausgelagerten Aspekt auszublenden.</p><p>Jetzt ist die ursprÃ¼ngliche <em>function under test</em> (FUT) nicht mehr nur BehÃ¤lter fÃ¼r Logik, sondern auch noch funktional abhÃ¤ngig von einer anderen Funktion. Die kennt sie zwar zunÃ¤chst nur als Abstraktion; doch zur Laufzeit steht dann eine konkrete Implementation zur VerfÃ¼gung (<em>dependency injection</em>).</p><p>Das kann man schon so machen... aber wie Sie sehen, wird das schnell recht unÃ¼bersichtlich.</p><p>Die FUT enthÃ¤lt ja eine Mischung aus verschiedenen Logikaspekten. Um jeden davon isoliert testen zu kÃ¶nnen â€“ eine Voraussetzung fÃ¼r feingranulare Fehlersuche und Weiterentwicklung â€“, mÃ¼ssten alle anderen ausblendbar sein.</p><p>Eigentlich. Das macht aber niemand. Man behilft sich mit einem Gemisch. Manche werden Ã¼ber IoC ausblendbar gemacht, andere verlagert man nur in eigene Funktionen, ohne sie ausblenden zu kÃ¶nnen, wieder andere bleiben vermischt in der FUT. Am Ende sieht die Struktur von Software so aus:</p><figure class="alignnone wp-image-407"><a href="https://ralfw.de/media/posts/17/img_56362f872e2e5.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56362f872e2e5.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-2xl.png 1600w" alt="" width="450" height="517"></a></figure><p></p><p>In tiefen BÃ¤umen von Funktionsaufrufen sind auf jeder (!) Ebene Logik und (!) funktionale AbhÃ¤ngigkeiten zu finden. Manchmal sind die funktionalen AbhÃ¤ngigkeiten durch IoC/DI entschÃ¤rft, manchmal aber auch nicht. Es ist eine bunte Mischung. Aber nicht unbedingt eine durchweg gut verstÃ¤ndliche. Und auch die Testbarkeit ist nicht durchweg gut. Denn konsequente Entkopplung mittels IoC/DI wÃ¤re schlicht zu umstÃ¤ndlich.</p><p>So hat man sich also in den letzten Jahren beholfen. Ist damit aber das Ende der Evolution von Codestrukturen erreicht? Ich glaube, nicht.</p><h2>Mit IOSP</h2><p>Prinzipien wie IoC und Praktiken wie dependency injection sind kein Selbstzweck. Man kann sogar sagen, sie fÃ¼hren zu Verschwendung. Denn mehr Indirektion ist ja nicht per se wÃ¼nschenswert. Deshalb darf man den kritischen Blick auch auf ehrwÃ¼rdige Prinzipien nicht verlieren.</p><p>IoC ist ein Mittel, um ein Problem zu lÃ¶sen. Einerseits ist das eine gute Sache. Andererseits ist bei jeder ProblemlÃ¶sung zu fragen, wie hoch in der Problemhierarchie sie ansetzt. Ist sie eine Symptomkur oder geht sie das Wurzelproblem an?</p><p>Ich wende einfach mal die <a href="https://de.wikipedia.org/wiki/5-Why-Methode" target="_blank" rel="noopener">Five-Why-Methode</a> an, um die Problemhierarchie zu beleuchten:</p><ol><li>Warum ist IoC ein so prominentes Prinzip? Weil es hilft, bei Tests Funktionen auszukoppeln.</li><li>Warum ist es wichtig, in Tests Funktionen auskoppeln zu kÃ¶nnen? Weil nur so Logik getrennt testbar ist.</li><li>Warum ist denn aber Logik Ã¼berhaupt getrennt testbar zu machen? Weil sie auf jeder Ebene der tiefen FunktionsbÃ¤ume vorhanden ist und dabei ganz unterschiedliche Aspekte (Verantwortlichkeiten) in Funktionen zusammengefasst werden.</li><li>Warum wird Logik unterschiedlicher Aspekte in Funktionen zusammengefasst?</li></ol><p>Ja, was ist die Antwort auf die vierte Frage? FÃ¼r mich lautet sie: Weil man es kann und es so einfach ist und man nicht recht weiÃŸ, wie Logik sonst hierarchisch strukturiert werden sollte. So war es halt immer schon.</p><p>Das finde ich zwar einerseits verstÃ¤ndlich, doch andererseits sollte das doch nicht dauerhaft die Antwort bleiben, oder? Das wÃ¤re ein bisschen bequem. Die Testbarkeit von FunktionsbÃ¤umen ist schlecht, also verschreibt man IoC. Doch das ist nur eine Symptomkur. Das Wurzelproblem, nÃ¤mlich das Vorhandensein von Logik auf jeder Hierarchieebene wird damit nicht angegangen. Warum nicht?</p><p>Ich glaube, weil man es nicht gesehen hat. Man hat nicht erkannt, dass die Ã¼blichen Funktionshierarchien auch mit IoC immer noch das <em>Single Responsibility Principle (SRP)</em> verletzen.</p><p>Eine Methode, die einerseits Logik enthÃ¤lt und andererseits Logik in anderen Funktionen aufruft, also funktional abhÃ¤ngig ist, hat zwei (!) Verantwortlichkeiten. Die eine Verantwortlichkeit steckt in ihrer eigenen Logik. Die andere Verantwortlichkeit jedoch besteht darin, andere Funktionen geeignet mit der eigenen Logik zu einem Ganzen zu integrieren.</p><p>Ja, das sind fÃ¼r mich zwei deutlich eigenstÃ¤ndige Verantwortlichkeiten. Die eine stellt Verhalten her, sie operiert auf Daten (Logik), die andere verbindet Verhaltensteile zu einem Gesamtverhalten (Integration).</p><p>Beide Verantwortlichkeiten getrennt zu sehen und auch im Code zu trennen, halte ich fÃ¼r so wichtig, dass dem ein eigenes Prinzip gewidmet sein sollte. Ich nenne es das <em>Integration Operation Segregation Principle (IOSP)</em>.</p><p>Und wie wÃ¼rde so eine Funktionshierarchie nach dem IOSP aussehen? Hier die Refaktorisierung des obigen Funktionsbaums:</p><figure class="alignnone wp-image-409"><a href="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-2xl.png 1600w" alt="" width="656" height="377"></a></figure><p></p><p>Sie sehen hier alle Farben der Logik wieder â€“ nur steckt sie dieses Mal ausschlieÃŸlich in den BlÃ¤ttern des Baumes, den Operationen. Die darÃ¼ber liegenden Knoten sind "ausgeblutet". Es gibt keine Logik-"PizzastÃ¼cke" mehr, sondern nur noch leere Rechtecke. Deren Aufgabe ist ausschlieÃŸlich die Integration von "ausgelagerter" Logik und anderen Integrationen.</p><p>Die Verantwortlichkeiten Integration und Operation sind konsequent getrennt. Entweder integriert eine Funktion oder sie operiert, d.h. enthÃ¤lt Logik.</p><p>Damit sind funktionale AbhÃ¤ngigkeiten verschwunden!</p><p>Operationen rufen keine anderen Funktionen auf. Dort kann es also keine funktionalen AbhÃ¤ngigkeiten mehr geben.</p><p>Integrationen hingegen rufen andere Funktionen auf. Allerdings enthalten sie selbst keine Logik mehr. Nichts in ihnen ist also abhÃ¤ngig von der Logik, die in aufgerufenen Funktionen stecken mag.</p><p>Und was hat das fÃ¼r einen Effekt fÃ¼r das Testen?</p><p>Operationen sind ganz einfach zu testen. Es muss dabei nichts mehr durch Mock/Stub/Fake ersetzt werden.</p><p>Integrationen wÃ¤ren immer noch schwer zu testen. Aber im Grunde mÃ¼ssen sie nicht getestet werden. Denn darin steckt ja keine Logik. Was wÃ¤re also zu testen? Die reine Integrationsleistung. Die jedoch ist so simpel, dass in den meisten FÃ¤llen eine visuelle ÃœberprÃ¼fung (code review) genÃ¼gt.</p><p>Ultimativ muss aber natÃ¼rlich doch das Ganze Ã¼berprÃ¼ft werden. Es ist also mindesten ein Test an der Wurzel nÃ¶tig. Doch der testet ja ebenfalls nur die Integrationsleistung, nicht die Korrektheit der Operationen.</p><figure class="alignnone wp-image-411"><a href="https://ralfw.de/media/posts/17/img_563641c27189d.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_563641c27189d.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_563641c27189d-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-2xl.png 1600w" alt="" width="443" height="548"></a></figure><p></p><p>Sieht das einfacher aus als der Testverhau mit IoC? Das will ich wohl meinen.</p><p>IoC hat seinen Wert. Auch in einer nach IOSP strukturierten Codebasis wird es hier und da Operationen oder Integrationen geben, die man von Aufrufern mittels IoC entkoppeln will. Aber der Bedarf dafÃ¼r sinkt drastisch.</p><p>Dadurch steigt mit IOSP die Ãœbersichtlichkeit des Codes. Das Rauschen der Indirektionen nimmt ab. Und die VerstÃ¤ndlichkeit von Funktionen, die sich auf die Integration konzentrieren ist sehr hoch.</p><h2>Software strukturieren fÃ¼r Tests</h2><p>Ich sehe die Evolution der Grundstruktur von Code als nicht abgeschlossen an. Er muss sich dem wachsenden Druck automatisierter Tests anpassen, es muss noch leichter testbar werden.</p><p>Mit IoC war ein Schritt in diese Richtung getan. Doch auch wenn der Code dadurch testbarer wurde, verlor er andererseits dadurch eine Eigenschaft: Ãœbersichtlichkeit. Indirektionen lediglich zum Zweck des Testbarkeit einzuziehen, war nur eine Symptomkur.</p><p>Mit IOSP kann nun ein zweiter Schritt getan werden. Raus aus den verrauschenden Indirektionen, weg von den Diskussionen um Mock-Frameworks hin zu Code, der ohne weitere Hilfsmittel einfach zu testen ist. Weil das Wurzelproblem der schlechten Testbarkeit gelÃ¶st ist: die Vermischung von Verantwortlichkeiten - und zwar der Verantwortlichkeit "Verhalten herstellen" und "Integration von Verhalten zu etwas GrÃ¶ÃŸerem".</p><p>Ich halte das fÃ¼r eine natÃ¼rliche Entwicklung der grundsÃ¤tzlichen Codestruktur. Wenn gute Abdeckung mit automatisierten Tests alternativlos ist, um zÃ¼gig durch VerÃ¤nderungen voranschreiten zu kÃ¶nnen, ohne Angste vor Regressionen zu haben, dann ist die Strukturierung nach IOSP eine konsequente Anpassung.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 29.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/iosp/">IOSP</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/who-do-you-want-to-kiss-about-simplicity-in-coding/" class="invert post__nav-link" rel="prev"><span>Previous</span> Who do you want to KISS? - About simplicity in coding</a></div><div class="post__nav-next"><a href="https://ralfw.de/bereiche-der-schaetzbarkeit/" class="invert post__nav-link" rel="next"><span>Next</span> Bereiche der SchÃ¤tzbarkeit </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>