<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Tests als evolutionäre Kraft - ralfw-de</title><meta name="description" content="Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den Kräften, die an ihr wirken, am besten standhalten kann. Dass Software gewünschte Funktionalität zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewünsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/tests-als-evolutionaere-kraft/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Tests als evolutionäre Kraft"><meta property="og:image" content="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den Kräften, die an ihr wirken, am besten standhalten kann. Dass Software gewünschte Funktionalität zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewünsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;"><meta property="og:url" content="https://ralfw.de/tests-als-evolutionaere-kraft/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Tests als evolutionäre Kraft"><meta name="twitter:description" content="Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den Kräften, die an ihr wirken, am besten standhalten kann. Dass Software gewünschte Funktionalität zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewünsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/tests-als-evolutionaere-kraft/"},"headline":"Tests als evolutionäre Kraft","datePublished":"2015-11-01T18:58","dateModified":"2021-01-29T15:25","image":{"@type":"ImageObject","url":"https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png","height":684,"width":1190},"description":"Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den Kräften, die an ihr wirken, am besten standhalten kann. Dass Software gewünschte Funktionalität zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewünsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first Codierung🇩🇪</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design🇩🇪</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">Blogs🇩🇪🇬🇧</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. 🇩🇪🇬🇧</a></li><li><a href="https://blog.ralfw.de/" target="_blank">🌐2007..2015🇩🇪</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">🌐2008..2015🇬🇧</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">🌐2003..2010🇬🇧</a></li><li><span class="is-separator">─────────</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">🌐Zur Soziokratie🇩🇪</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">🌐Gedankliche Umtriebe🇩🇪</a></li><li><a href="https://medium.com/personal-flow" target="_blank">🌐Personal Flow🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png" srcset="https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="684" width="1190" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2015-11-01T18:58">01.11.2015</time></div><h1>Tests als evolutionäre Kraft</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Warum sollte Software eigentlich eine bestimmte Struktur haben? Weil sie mit dieser Struktur den Kräften, die an ihr wirken, am besten standhalten kann.</p><p>Dass Software gewünschte Funktionalität zeigt, hat nichts mit ihrer Struktur zu tun. Dass Software gewünsche Effizienzen zeigt (z.B. Performance, Sicherheit), hat in vielen Fällen auch nichts mit ihrer Struktur zu tun. Für Funktionalität wie Effizienzen ist lediglich <a href="https://programming-with-ease.circle.so/c/articles/logic-makes-the-software-turn-around" target="_blank" rel="noopener noreferrer">Logik</a> verantwortlich – und die braucht keine Struktur, um ihren Effekt zu entfalten.</p><p>Das ist leicht zu verstehen, wenn Sie daran denken, dass im finalen Maschinencode all Ihre schönen Strukturen ja nicht mehr zu finden sind und die Software trotzdem das gewünschte Verhalten zeigt.</p><p>Was verstehe ich unter Struktur? Elemente, die in Beziehung stehen. Also eine gewisse Anordnung von Dingen. Diese "Dinge" in der Software sind zunächst einmal Module, d.h. Funktionen, Klassen, Bibliotheken usw. Und die Beziehungen zwischen ihnen sind vor allem Nutzungsbeziehungen: ein Modul kennt ein anderes, um dort eine Dienstleistung zu nutzen.</p><p>(Datenstrukturen lasse ich hier ausdrücklich aus. Die arrangieren ja keine Logik, sondern eben Daten.)</p><p>Und was sind die Kräfte, die auf die Softwarestruktur wirken? Veränderungen. Softwarestruktur soll Code wandelbar machen.</p><p>Wandelbar ist Code, wenn er leicht verständlich ist, wenn sich Veränderungen zur Herstellung neuer Funktionalität oder Effizienz leicht anbringen lassen und wenn man leicht feststellen kann, ob das Neue schon korrekt implementiert ist wie auch das Alte immer noch korrekt arbeitet. Testbarkeit ist mithin ein Kriterium für Wandelbarkeit. Tests sind ein Teil der Kraft, die auf Softwarestrukturen einwirken.</p><p>In Bezug auf Tests habe ich mich nun gefragt, wie sich Strukturen dadurch verändern? Wie setzt Software Tests möglichst wenig Widerstand entgegen?</p><p>Mir scheint es da eine natürliche Entwicklung zu geben, quasi eine Evolution:</p><h2>Ohne Prinzipien</h2><p>Alles beginnt mit ein bisschen Produktionscode und einem Test:</p><figure class="alignnone wp-image-402"><a href="https://ralfw.de/media/posts/17/img_5633692eb7a45.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_5633692eb7a45.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_5633692eb7a45-2xl.png 1600w" alt="" width="119" height="189"></a></figure><p></p><p>Produktionscode und Test enthalten Logik. Die Logik des Produktionscodes stellt das vom Kunden gewünschte Verhalten her. Hoffentlich jedenfalls ;-) Und die Logik des Tests prüft das.</p><p>Beide Logiken sind getrennt in verschiedene Module, zumindest unterschiedliche Funktionen. Es entsteht also schon eine minimale Struktur.</p><p>Ein Test reicht natürlich nicht aus. Der Produktionscode hat verschiedene Aspekte, die jede für sich überprüft werden wollen. Also sieht die Struktur zumindest so aus:</p><figure class="alignnone wp-image-403"><a href="https://ralfw.de/media/posts/17/img_56336cc142b98.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56336cc142b98.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56336cc142b98-2xl.png 1600w" alt="" width="234" height="220"></a></figure><p></p><p>Alle Verhaltensaspekte sind in der Funktion des Produktionscodes zusammengemischt; die verhaltensindividuellen Tests setzen daher alle an der einen Funktion an.</p><p>Das kann man schon so machen... aber dann ist es halt kaum möglich, wirklich nur einen Aspekt zu testen. Die Logik aller anderen Aspekte wird in der einen Produktionscodefunktion immer mehr oder weniger mit durchlaufen.</p><h2>Mit IoC</h2><p>Um gezielter Aspektlogik testen zu können, wird empfohlen, das Prinzip <em>Inversion of Control</em> (IoC) anzuwenden. Dadurch lassen sich im Test gezielt uninteressante Aspekte ausblenden, indem man sie mit einem <a href="http://stackoverflow.com/questions/346372/whats-the-difference-between-faking-mocking-and-stubbing" target="_blank" rel="noopener">Mock/Stub/Fake</a> ersetzt.</p><figure class="alignnone wp-image-404"><a href="https://ralfw.de/media/posts/17/img_56337154d8546.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56337154d8546.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56337154d8546-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56337154d8546-2xl.png 1600w" alt="" width="558" height="431"></a></figure><p></p><p>Der Produktionscodeaspekt wird ausgelagert in eine eigene Funktion und dort für sich getestet.</p><p>Eingebunden wird er zwischen den verbleibenden Aspekten in der ursprünglichen Funktion jedoch nicht durch direkten Aufruf, sondern über eine Indirektion. Die ursprüngliche Funktion kennt nur noch eine Abstraktion des ausgelagerten Aspekts, z.B. ein Interface, auf dem er eine Methode darstellt. Dieses Interface implementiert die Klasse, in die der Aspekte ausgelagert wurde.</p><p>Ebenso implementiert dieses Interface ein Mock/Stub/Fake, den andere Tests nutzen, um für sich den ausgelagerten Aspekt auszublenden.</p><p>Jetzt ist die ursprüngliche <em>function under test</em> (FUT) nicht mehr nur Behälter für Logik, sondern auch noch funktional abhängig von einer anderen Funktion. Die kennt sie zwar zunächst nur als Abstraktion; doch zur Laufzeit steht dann eine konkrete Implementation zur Verfügung (<em>dependency injection</em>).</p><p>Das kann man schon so machen... aber wie Sie sehen, wird das schnell recht unübersichtlich.</p><p>Die FUT enthält ja eine Mischung aus verschiedenen Logikaspekten. Um jeden davon isoliert testen zu können – eine Voraussetzung für feingranulare Fehlersuche und Weiterentwicklung –, müssten alle anderen ausblendbar sein.</p><p>Eigentlich. Das macht aber niemand. Man behilft sich mit einem Gemisch. Manche werden über IoC ausblendbar gemacht, andere verlagert man nur in eigene Funktionen, ohne sie ausblenden zu können, wieder andere bleiben vermischt in der FUT. Am Ende sieht die Struktur von Software so aus:</p><figure class="alignnone wp-image-407"><a href="https://ralfw.de/media/posts/17/img_56362f872e2e5.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56362f872e2e5.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56362f872e2e5-2xl.png 1600w" alt="" width="450" height="517"></a></figure><p></p><p>In tiefen Bäumen von Funktionsaufrufen sind auf jeder (!) Ebene Logik und (!) funktionale Abhängigkeiten zu finden. Manchmal sind die funktionalen Abhängigkeiten durch IoC/DI entschärft, manchmal aber auch nicht. Es ist eine bunte Mischung. Aber nicht unbedingt eine durchweg gut verständliche. Und auch die Testbarkeit ist nicht durchweg gut. Denn konsequente Entkopplung mittels IoC/DI wäre schlicht zu umständlich.</p><p>So hat man sich also in den letzten Jahren beholfen. Ist damit aber das Ende der Evolution von Codestrukturen erreicht? Ich glaube, nicht.</p><h2>Mit IOSP</h2><p>Prinzipien wie IoC und Praktiken wie dependency injection sind kein Selbstzweck. Man kann sogar sagen, sie führen zu Verschwendung. Denn mehr Indirektion ist ja nicht per se wünschenswert. Deshalb darf man den kritischen Blick auch auf ehrwürdige Prinzipien nicht verlieren.</p><p>IoC ist ein Mittel, um ein Problem zu lösen. Einerseits ist das eine gute Sache. Andererseits ist bei jeder Problemlösung zu fragen, wie hoch in der Problemhierarchie sie ansetzt. Ist sie eine Symptomkur oder geht sie das Wurzelproblem an?</p><p>Ich wende einfach mal die <a href="https://de.wikipedia.org/wiki/5-Why-Methode" target="_blank" rel="noopener">Five-Why-Methode</a> an, um die Problemhierarchie zu beleuchten:</p><ol><li>Warum ist IoC ein so prominentes Prinzip? Weil es hilft, bei Tests Funktionen auszukoppeln.</li><li>Warum ist es wichtig, in Tests Funktionen auskoppeln zu können? Weil nur so Logik getrennt testbar ist.</li><li>Warum ist denn aber Logik überhaupt getrennt testbar zu machen? Weil sie auf jeder Ebene der tiefen Funktionsbäume vorhanden ist und dabei ganz unterschiedliche Aspekte (Verantwortlichkeiten) in Funktionen zusammengefasst werden.</li><li>Warum wird Logik unterschiedlicher Aspekte in Funktionen zusammengefasst?</li></ol><p>Ja, was ist die Antwort auf die vierte Frage? Für mich lautet sie: Weil man es kann und es so einfach ist und man nicht recht weiß, wie Logik sonst hierarchisch strukturiert werden sollte. So war es halt immer schon.</p><p>Das finde ich zwar einerseits verständlich, doch andererseits sollte das doch nicht dauerhaft die Antwort bleiben, oder? Das wäre ein bisschen bequem. Die Testbarkeit von Funktionsbäumen ist schlecht, also verschreibt man IoC. Doch das ist nur eine Symptomkur. Das Wurzelproblem, nämlich das Vorhandensein von Logik auf jeder Hierarchieebene wird damit nicht angegangen. Warum nicht?</p><p>Ich glaube, weil man es nicht gesehen hat. Man hat nicht erkannt, dass die üblichen Funktionshierarchien auch mit IoC immer noch das <em>Single Responsibility Principle (SRP)</em> verletzen.</p><p>Eine Methode, die einerseits Logik enthält und andererseits Logik in anderen Funktionen aufruft, also funktional abhängig ist, hat zwei (!) Verantwortlichkeiten. Die eine Verantwortlichkeit steckt in ihrer eigenen Logik. Die andere Verantwortlichkeit jedoch besteht darin, andere Funktionen geeignet mit der eigenen Logik zu einem Ganzen zu integrieren.</p><p>Ja, das sind für mich zwei deutlich eigenständige Verantwortlichkeiten. Die eine stellt Verhalten her, sie operiert auf Daten (Logik), die andere verbindet Verhaltensteile zu einem Gesamtverhalten (Integration).</p><p>Beide Verantwortlichkeiten getrennt zu sehen und auch im Code zu trennen, halte ich für so wichtig, dass dem ein eigenes Prinzip gewidmet sein sollte. Ich nenne es das <em>Integration Operation Segregation Principle (IOSP)</em>.</p><p>Und wie würde so eine Funktionshierarchie nach dem IOSP aussehen? Hier die Refaktorisierung des obigen Funktionsbaums:</p><figure class="alignnone wp-image-409"><a href="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_56363e9ad8fc7.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_56363e9ad8fc7-2xl.png 1600w" alt="" width="656" height="377"></a></figure><p></p><p>Sie sehen hier alle Farben der Logik wieder – nur steckt sie dieses Mal ausschließlich in den Blättern des Baumes, den Operationen. Die darüber liegenden Knoten sind "ausgeblutet". Es gibt keine Logik-"Pizzastücke" mehr, sondern nur noch leere Rechtecke. Deren Aufgabe ist ausschließlich die Integration von "ausgelagerter" Logik und anderen Integrationen.</p><p>Die Verantwortlichkeiten Integration und Operation sind konsequent getrennt. Entweder integriert eine Funktion oder sie operiert, d.h. enthält Logik.</p><p>Damit sind funktionale Abhängigkeiten verschwunden!</p><p>Operationen rufen keine anderen Funktionen auf. Dort kann es also keine funktionalen Abhängigkeiten mehr geben.</p><p>Integrationen hingegen rufen andere Funktionen auf. Allerdings enthalten sie selbst keine Logik mehr. Nichts in ihnen ist also abhängig von der Logik, die in aufgerufenen Funktionen stecken mag.</p><p>Und was hat das für einen Effekt für das Testen?</p><p>Operationen sind ganz einfach zu testen. Es muss dabei nichts mehr durch Mock/Stub/Fake ersetzt werden.</p><p>Integrationen wären immer noch schwer zu testen. Aber im Grunde müssen sie nicht getestet werden. Denn darin steckt ja keine Logik. Was wäre also zu testen? Die reine Integrationsleistung. Die jedoch ist so simpel, dass in den meisten Fällen eine visuelle Überprüfung (code review) genügt.</p><p>Ultimativ muss aber natürlich doch das Ganze überprüft werden. Es ist also mindesten ein Test an der Wurzel nötig. Doch der testet ja ebenfalls nur die Integrationsleistung, nicht die Korrektheit der Operationen.</p><figure class="alignnone wp-image-411"><a href="https://ralfw.de/media/posts/17/img_563641c27189d.png"><img loading="lazy" src="https://ralfw.de/media/posts/17/img_563641c27189d.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/17/responsive/img_563641c27189d-xs.png 300w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-sm.png 480w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-md.png 768w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-lg.png 1024w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-xl.png 1360w, https://ralfw.de/media/posts/17/responsive/img_563641c27189d-2xl.png 1600w" alt="" width="443" height="548"></a></figure><p></p><p>Sieht das einfacher aus als der Testverhau mit IoC? Das will ich wohl meinen.</p><p>IoC hat seinen Wert. Auch in einer nach IOSP strukturierten Codebasis wird es hier und da Operationen oder Integrationen geben, die man von Aufrufern mittels IoC entkoppeln will. Aber der Bedarf dafür sinkt drastisch.</p><p>Dadurch steigt mit IOSP die Übersichtlichkeit des Codes. Das Rauschen der Indirektionen nimmt ab. Und die Verständlichkeit von Funktionen, die sich auf die Integration konzentrieren ist sehr hoch.</p><h2>Software strukturieren für Tests</h2><p>Ich sehe die Evolution der Grundstruktur von Code als nicht abgeschlossen an. Er muss sich dem wachsenden Druck automatisierter Tests anpassen, es muss noch leichter testbar werden.</p><p>Mit IoC war ein Schritt in diese Richtung getan. Doch auch wenn der Code dadurch testbarer wurde, verlor er andererseits dadurch eine Eigenschaft: Übersichtlichkeit. Indirektionen lediglich zum Zweck des Testbarkeit einzuziehen, war nur eine Symptomkur.</p><p>Mit IOSP kann nun ein zweiter Schritt getan werden. Raus aus den verrauschenden Indirektionen, weg von den Diskussionen um Mock-Frameworks hin zu Code, der ohne weitere Hilfsmittel einfach zu testen ist. Weil das Wurzelproblem der schlechten Testbarkeit gelöst ist: die Vermischung von Verantwortlichkeiten - und zwar der Verantwortlichkeit "Verhalten herstellen" und "Integration von Verhalten zu etwas Größerem".</p><p>Ich halte das für eine natürliche Entwicklung der grundsätzlichen Codestruktur. Wenn gute Abdeckung mit automatisierten Tests alternativlos ist, um zügig durch Veränderungen voranschreiten zu können, ohne Angste vor Regressionen zu haben, dann ist die Strukturierung nach IOSP eine konsequente Anpassung.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 29.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/iosp/">IOSP</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/who-do-you-want-to-kiss-about-simplicity-in-coding/" class="invert post__nav-link" rel="prev"><span>Previous</span> Who do you want to KISS? - About simplicity in coding</a></div><div class="post__nav-next"><a href="https://ralfw.de/bereiche-der-schaetzbarkeit/" class="invert post__nav-link" rel="next"><span>Next</span> Bereiche der Schätzbarkeit </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>