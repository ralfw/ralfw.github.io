<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Two Problem Solving Approaches - One Man Think Tank</title><meta name="description" content="Solving a problem can be hard at times. What I’ve found helpful then is to distinguish between two different approaches to tackle the problem. Without distinguishing them I’m prone to use an unsuitable approach and make things harder than they actually are. Here’s a sample&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.github.io/homepage-ralfw-de/two-problem-solving-approaches/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.github.io/homepage-ralfw-de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.github.io/homepage-ralfw-de/feed.json"><meta property="og:title" content="Two Problem Solving Approaches"><meta property="og:image" content="https://ralfw.github.io/homepage-ralfw-de/media/posts/118/problem-3303396_1920.png"><meta property="og:site_name" content="One Man Think Tank"><meta property="og:description" content="Solving a problem can be hard at times. What I’ve found helpful then is to distinguish between two different approaches to tackle the problem. Without distinguishing them I’m prone to use an unsuitable approach and make things harder than they actually are. Here’s a sample&hellip;"><meta property="og:url" content="https://ralfw.github.io/homepage-ralfw-de/two-problem-solving-approaches/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://ralfw.github.io/homepage-ralfw-de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.github.io/homepage-ralfw-de/assets/css/style.css?v=990e7ab6bf398e730fe544646c09fe50"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.github.io/homepage-ralfw-de/two-problem-solving-approaches/"},"headline":"Two Problem Solving Approaches","datePublished":"2018-09-07T14:30","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/posts/118/problem-3303396_1920.png","height":1280,"width":1920},"description":"Solving a problem can be hard at times. What I’ve found helpful then is to distinguish between two different approaches to tackle the problem. Without distinguishing them I’m prone to use an unsuitable approach and make things harder than they actually are. Here’s a sample&hellip;","author":{"@type":"Person","name":"Ralf Westphal"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.github.io/homepage-ralfw-de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.github.io/homepage-ralfw-de/"><img src="https://ralfw.github.io/homepage-ralfw-de/media/website/logo-smaller.png" alt="One Man Think Tank"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.github.io/homepage-ralfw-de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.github.io/homepage-ralfw-de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/homepage-ralfw-de/test-first-codierung/" target="_self">Test-first Codierung</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing</a></li></ul></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/testimonials/" target="_self">Testimonials</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/" target="_self">Blog</a></li><li class="has-submenu"><a href="https://ralfw.github.io/homepage-ralfw-de/about/" target="_self" aria-haspopup="true">About</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.github.io/homepage-ralfw-de/imprint/" target="_self">Imprint</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/data-privacy-policy-2/" target="_self">Privacy Policy</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://ralfw.github.io/homepage-ralfw-de/media/posts/118/problem-3303396_1920.png" srcset="https://ralfw.github.io/homepage-ralfw-de/media/posts/118/responsive/problem-3303396_1920-xs.png 300w, https://ralfw.github.io/homepage-ralfw-de/media/posts/118/responsive/problem-3303396_1920-sm.png 480w, https://ralfw.github.io/homepage-ralfw-de/media/posts/118/responsive/problem-3303396_1920-md.png 768w, https://ralfw.github.io/homepage-ralfw-de/media/posts/118/responsive/problem-3303396_1920-lg.png 1024w, https://ralfw.github.io/homepage-ralfw-de/media/posts/118/responsive/problem-3303396_1920-xl.png 1360w, https://ralfw.github.io/homepage-ralfw-de/media/posts/118/responsive/problem-3303396_1920-2xl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="1280" width="1920" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2018-09-07T14:30">07.09.2018</time></div><h1>Two Problem Solving Approaches</h1><div class="post__meta post__meta--author"><a href="https://ralfw.github.io/homepage-ralfw-de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p>Solving a problem can be hard at times. What I’ve found helpful then is to distinguish between two different approaches to tackle the problem. Without distinguishing them I’m prone to use an unsuitable approach and make things harder than they actually are.</p><p>Here’s a sample problem:</p><blockquote><p>Write a bash/console program to convert roman numbers entered by the user into decimal numbers. The user can enter one or more roman numbers separated by commas. After a conversion is done the user is prompted for more numbers. The user can exit the program by entering an empty string.</p></blockquote><p>To implement a solution might take you from 20 minutes up to 1 or two hours. So I’d say this is not a trivial problem. It’s worth a systematic approach.</p><p>How can you attack this problem? How to make it easier for you? Considerable logic has to be written to create the required behaviour. You won’t be able to just write it down from the top of your head. At least most developers I know won’t be able to pull off such a feat.</p><h2>Problem decomposition I: Partition</h2><p>The first approach I usually take is to partition the problem. A problem partition is a problem within the original problem in the form of a puzzle piece or a processing step. Partial problems are complementary.</p><p>A definition that works well for me is:</p><blockquote><p>If you decompose a problem into n partial problems the user will not be satisfied before all n partial problems have been solved.</p></blockquote><p>With regard to the sample problems I’d identify the following very quickly as partial problems:</p><ul><li>P1. Ask the user for the next batch of roman numbers.</li><li>P2. Parse the string of roman numbers into individual numbers.</li><li>P3. Convert each individual roman number into a decimal number.</li><li>P4. Convert all roman numbers into decimal numbers</li><li>P5. Display all decimal numbers.</li></ul><p>Implementing just a solution for even partial problem no. S3 - which seems to be at the domain heart of the overall problem - would not make the customer very happy. Provided he could check the correctness of your implementation he/she would be able to provide feedback and maybe even pay you some money. But the partial solution would be useless to him/her. No way to put it into the hand of users.</p><p>The same is true for implementing a solution to partial problem no. 1. Great, the user can enter some text - but nothing would be done with it. Again, feedback could be given, but the partial solution would be of no use.</p><p>Partial problems are by definition smaller, easier to solve then the whole problem. Hence looking for them is very helpful.</p><p>You can even repeat the decomposition into partial problems. Partial problems mostly form a hierarchy. For example partial problem no. 3 could be decomposed into:</p><ul><li>P3. Convert each individual roman number into a decimal number.<ul><li>P3.1. Map the roman digits in a roman number to their decimal values, e.g. „XVI“ -&gt; [10, 5, 1].</li><li>P3.2 Add those values up to produce a result, e.g. [10, 5, 1] -&gt; 16.</li><li>P3.3 If needed apply the subtraction rule to the values before they get added, e.g. [10, 1, 5] -&gt; [10, -1, 5].</li></ul></li></ul><p>You see: partial problems can get very small, which means easy to implement. Once you found the above partial problems for the parent problem no. 3 roman to decimal conversion should be a piece of cake.</p><h2>Problem decomposition II: Simplify</h2><p>The other approach to breaking up a large problem into smaller ones is to identify simplifications. Simple problems are sub-problems. They are, so to speak, embedded in the large problem.</p><blockquote><p>If you decompose a problem into n sub-problems the user might be satisfied with less than n solved sub-problems.</p></blockquote><p>Sub-problems are real increments. You can serve sub-problem solutions to the customer until he/she says stop. And each solution will increase his/her satisfaction. Even with the first sub-problem he/she might start putting it at the fingertips of users to make their life easier. That’s markedly different from partial problems!</p><p>Here’s a list of sub-problems I’d identify in the example problem:</p><ul><li>S1. Convert one roman number only once.</li><li>S2. Convert several roman numbers only once.</li><li>S3. Convert several roman numbers multiple times.</li><li>S4. Convert roman numbers with just one roman digit (e.g. „I“, „V“).</li><li>S5. Convert roman numbers with multiple roman digits with just decreasing/equal value (e.g. „III“, „XVI“).</li><li>S6. Convert roman numbers with multiple roman digits even if a smaller value precedes a larger (e.g. „IV“, „MCMLXXXIV“).</li></ul><p>Even if just a single roman number with a single digit could be converted that would provide some value to some users.</p><p>You see how sub-problem no. S4 is not only smaller than no. S6, but also a part of it. No. S6 is based on no. S4 to be solved. Sub-problems form a hierarchy of nested problems with upper ones building on lower ones:</p><ul><li>S3(S2(S1))</li><li>S6(S5(S4))</li></ul><p>In this case please also note how both hierarchies are orthogonal. They span a problem space where you could, for example, pick to solve (S1,S4) or (S3,S1) etc.</p><h2>Mixing problem decomposition approaches</h2><p>If you detect multiple dimensions in your sub-problems that’s a symptom of mixed decomposition approaches. The two hierarchies of subproblems belong to the partial problems (P1,P2,P4,P5) and P3 respectively. Deciding to go for (S1,S4) would lead to a solution which also attacks ((P1,P5), P3). No need to implement a solution to P2 or P4 since there are just single roman numbers to process.</p><p>My experience is that both decomposition approaches are needed all the time in software development. In fact, I guess, you’re already applying them intuitively. Doing it more consciously will make difficult things easier for you, though, I hope.</p><p>What I have found useful is to start with 1) partitioning a problem and then 2) simplifying the partitions. And then: 3) rinse and repeat. I constantly mix the approaches. If I don’t make progress one way I try the other.</p><p>And here’s an insight I gained since I’ve started to distinguish these approaches: TDD seems to be geared towards solving problems by simplification. Look at the TDD examples out there and check how they progress incrementally by solving sub-problems. TDD works its way up the sub-problem hierarchy.</p><p>This has an implication, I think: TDD works best with problems you are able to decompose into sub-problems in the first place. Code katas like „From Roman“ or „FizzBuzz“ or „Bowling Kata“ are examples of that.</p><p>But how do you know what kind of problem you are facing? What to do when in doubt? For me it’s simple: As I said, I always (at least mostly) start by looking for partial problems. The risk of blocking myself by underestimating the difficulty of decomposing into sub-problems is too big.</p><p>And this shows in my code. Both approaches differ in how I implement the solutions to the decompositions:</p><ul><li>Solutions to sub-problems manifest themselves as <a href="http://flow-design.org/logic" target="_blank" rel="noopener">logic</a>.</li><li>Solutions to partial-problems manifest themselves as functions and <a href="http://flow-design.org/modulehierarchy" target="_blank" rel="noopener">modules</a>.</li></ul><p>I’m happy to report that this also leads to cleaner code right from the start. Ever since I started to look closer how to solve a problem best and use different implementation approaches, the need for refactoring dropped dramatically.</p><p>Image source: <a href="https://pixabay.com/de/problem-lösung-hilfe-support-3303396/" target="_blank" rel="noopener">pixaby</a></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/clean-code/">Clean Code</a></li><li><a href="https://ralfw.github.io/homepage-ralfw-de/tags/tdd/">TDD</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.github.io/homepage-ralfw-de/tdd-how-it-can-be-done-right/" class="invert post__nav-link" rel="prev"><span>Previous</span> TDD - How It Can Be Done Right</a></div><div class="post__nav-next"><a href="https://ralfw.github.io/homepage-ralfw-de/magically-predictable-software-production/" class="invert post__nav-link" rel="next"><span>Next</span> Magically Predictable Software Production </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank EOOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.github.io/homepage-ralfw-de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.github.io/homepage-ralfw-de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>