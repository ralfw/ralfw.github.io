<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Functional Dependencies Considered Harmful - ralfw-de</title><meta name="description" content="You’ve probably heard of the seminal paper „Go To Statement Considered Harmful“ by Edsger Dijkstra from 1968. It paved the way for broad adoption of then modern programming languages with their control flow statements like if-then, for, or while. With Pascal and C probably being&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/functional-dependencies-considered-harmful/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="Functional Dependencies Considered Harmful"><meta property="og:image" content="https://ralfw.de/media/website/logo-smaller.png"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="You’ve probably heard of the seminal paper „Go To Statement Considered Harmful“ by Edsger Dijkstra from 1968. It paved the way for broad adoption of then modern programming languages with their control flow statements like if-then, for, or while. With Pascal and C probably being&hellip;"><meta property="og:url" content="https://ralfw.de/functional-dependencies-considered-harmful/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="Functional Dependencies Considered Harmful"><meta name="twitter:description" content="You’ve probably heard of the seminal paper „Go To Statement Considered Harmful“ by Edsger Dijkstra from 1968. It paved the way for broad adoption of then modern programming languages with their control flow statements like if-then, for, or while. With Pascal and C probably being&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/website/logo-smaller.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/functional-dependencies-considered-harmful/"},"headline":"Functional Dependencies Considered Harmful","datePublished":"2019-07-11T10:37","dateModified":"2021-01-28T14:01","image":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250},"description":"You’ve probably heard of the seminal paper „Go To Statement Considered Harmful“ by Edsger Dijkstra from 1968. It paved the way for broad adoption of then modern programming languages with their control flow statements like if-then, for, or while. With Pascal and C probably being&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><script type="text/javascript">var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/606e06a2f7ce1827093813ae/1f2msm5ed';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();</script><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first Codierung🇩🇪</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-Design🇩🇪</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit Slicing🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">Blogs🇩🇪🇬🇧</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. 🇩🇪🇬🇧</a></li><li><a href="https://blog.ralfw.de/" target="_blank">🌐2007..2015🇩🇪</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">🌐2008..2015🇬🇧</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">🌐2003..2010🇬🇧</a></li><li><span class="is-separator">─────────</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">🌐Zur Soziokratie🇩🇪</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">🌐Gedankliche Umtriebe🇩🇪</a></li><li><a href="https://medium.com/personal-flow" target="_blank">🌐Personal Flow🇩🇪</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-07-11T10:37">11.07.2019</time></div><h1>Functional Dependencies Considered Harmful</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>You’ve probably heard of the seminal paper <a href="chrome-extension://oemmndcbldboiebfnladdacbdfmadadm/https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf" target="_blank" rel="noopener">„Go To Statement Considered Harmful“ by Edsger Dijkstra</a> from 1968. It paved the way for broad adoption of then modern programming languages with their control flow statements like <code>if-then</code>, <code>for</code>, or <code>while</code>. With Pascal and C probably being the first broadly popular languages in this vein.</p><p></p><p></p><p>You don’t ever question the usefulness of this language construct for example:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2630"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-2xl.png 1600w" alt="" width="249" height="64"></figure></figure></div><p></p><p></p><p>But some 50 years ago such an attitude would not have been the norm yet. You were most likely to encounter something like this in code instead:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2619"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-1-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-1-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-1-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-1-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-1-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-1-2xl.png 1600w" alt="" width="248" height="99"></figure></figure></div><p></p><p></p><p>Both code snippets show code valid in C# in 2019, but only the first of course is deemed proper or clean (in all but the most rare circumstances).</p><p></p><p></p><p>So called <em>Structured Programming</em> today goes without saying. It’s the de facto standard of programming. In <a href="https://ralfw.de/trainings/">my Clean Code trainings</a> I never ever meet anyone who’s struggling with letting go of the <code>goto</code> statement.</p><p></p><p></p><h2>The secret of Structured Programming</h2><p></p><p></p><p>The world of programming has become a better one with „goto-less programming“ or Structured Programming. But why? What’s the lesson we can learn from not using <code>goto</code> anymore?</p><p></p><p></p><p>To me it’s that <em>voluntary restraint can be empowering. Doing less of something that’s possible is actually enabling to get done more.</em></p><p></p><p></p><p>Arbitrarily jumping around in code was possible. It was used extensively. It got the job done. Programmers were working very hard. And they were meaning no harm.</p><p></p><p></p><p>Tragically, though, this common practice of well meaning hard working programmers was causing harm nevertheless. It was causing other hard working programmers to break out in sweat and work even harder. Because reasoning about code was made very, very difficult by casually using <code>goto</code> on the spur of the moment. Programmers were trying to shoot problems down they were under attack from – but also caused a lot of collateral damage. Software development was suffering from a growing amount of friendly fire, so to speak. Shots went into problems, sure. But they also went into programmers’ feet. A lot.</p><p></p><p></p><p>The common attitude back then was: Programmers are entitled to fight off problems by using <code>goto</code>. It was like an IGA, an International Goto Association😉 of language vendors offering <code>goto</code> and other weapons to programmers.</p><p></p><p></p><p>But then it dawned on some that maybe this <code>goto</code> weapon was causing more harm than good. And slowly, slowly things started to change.</p><p></p><p></p><p>The key was to understand, that not all that was possible should also be „allowed“. <code>goto</code> was a dangerous weapon. It was able to „kill“ problems, but it also was able to „kill“ understanding. Unbridled use was not sustainable.</p><p></p><p></p><p>First then there were admonishments to be careful when using it. Then came patterns of how to use it best. And finally… came languages with abstractions that made its explicit use unnecessary (or even impossible). Under the hood program control was still jumping around at runtime, but in high level languages this was carefully hidden by control statements.</p><p></p><p></p><p><code>goto</code> still was possible technically, but through a mixture of abstractions and a growing consciousness regarding its dangers it vanished from everyday use.</p><p></p><p></p><p>In my view this was a step in the direction of „ecological programming“, i.e. programming not just thinking of today, but keeping in mind its effects on tomorrow. Some form of over-exploitation of code was stopped. Software development became a bit more sustainable - and thereby also scalable.</p><p></p><p></p><p>Voluntarily abandoning the capability of <code>goto</code>, voluntarily restraining oneself opened the possibility of actually writing larger programs and still being able to reason about them. With unbridled use of <code>goto</code> we would not be able to write the programs we write today.</p><p></p><p></p><h2>More letting go</h2><p></p><p></p><p>The other day I saw a presentation by <a href="https://twitter.com/wkinkeldei?lang=en" target="_blank" rel="noopener">Wolfang Kinkeldei</a> in which he listed more self-imposed restraints in programming. If I remember his list correctly it went like this:</p><p></p><p></p><ul><li>Structured Programming (SP): getting rid of <code>goto</code></li><li>Object-Oriented Programming (OOP): getting rid of function pointers</li><li>Functional Programming (FP): getting rid of assignments</li><li>Reactive Programming (Rx): getting rid of <code>return</code></li><li>Actor Programming (AP): getting rid of threads</li></ul><p></p><p></p><p>In the tradition of „Go To Statement Considered Harmful“ this to me means: software development has (also) evolved by restraining itself. Not all that can be done, that is technical possible, should be done. Even if that means letting go of fine grained control - because that’s something many developers struggle with. They like to be in control, to tweak whatever can be tweaked in case of some missing efficiency (mostly runtime performance and memory usage).</p><p></p><p></p><p>But even if in some very rare cases it might be necessary to take (back) control over minute details of program execution, it’s mostly a „control mania“, I’d say. Especially for the past 10-15 years large areas of software development haven’t been lacking hardware resources anymore. Memory, hard disks, processor power, number of processors are not the constraint anymore impeding the creation of valuable software. The constraint has shifted: developers are the constraint now, I believe. But that’s a topic for another article.</p><p></p><p></p><p>Let me explain what I see is behind those programming approaches:</p><p></p><p></p><h3>Structured Programming</h3><p></p><p></p><p>Letting go of <code>goto</code> while introducing control statements as abstractions of <code>goto</code> patterns led to easier to understand code. Evolvability increased, higher longterm programmer productivity was reached, programs could grow larger. Great!</p><p></p><p></p><h3>Functional Programming I</h3><p></p><p></p><p>I would define the self-restraint different from „getting rid of assignments“. „Getting rid of mutability“ is more fitting, I’d say. Changing data through assignments is for data what jumping around the code with <code>goto</code> is for behavior: it makes code hard to understand. More attention, more mental state, a more complex mental model is needed to be able to change code for the better. Without mutable state (or more generally: side effects) evolvability increases; code becomes easier to reason about, especially in times of a growing need for concurrent programming.</p><p></p><p></p><h3>Functional Programming II</h3><p></p><p></p><p>Even though it wasn’t on Wolfgang’s list I’d like to add another relinquishment of FP. FP is also about „getting rid of loops“, I think. You’ll find much less loops like <code>for</code> or <code>while</code> in FP code than in OOP code. (If a looping construct is all offered by a FP language.) Instead you find streams of data processed in „pipelines“ of map-reduce-filter operations each working on a collection of data, but with the loop carefully hidden beneath a language/library abstraction. First there was the iterator pattern, then a more abstract loop like <code>foreach</code> hiding it, then higher order functions like <code>map</code> (F#) or <code>Select</code> (C#) doing the looping inside and calling a function for each item pulled from an iterator (see code example below). Also responsible for the absence of loops in FP code: recursion; but to me that’s somewhat less of a replacement because many developers struggle with wrapping their head around recursive solutions. But anyway: the benefit of abstaining from loop statements is… evolvability. Again. Because less/no loops means easier to read code. It even means less code. Which means less surface for bugs to attach to.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2621"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-2-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-2-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-2-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-2-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-2-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-2-2xl.png 1600w" alt="" width="712" height="303"></figure></figure></div><p></p><p></p><h3>Reactive Programming</h3><p></p><p></p><p>„Getting rid of <code>return</code>“ is a nice way to describe Rx, I think. Because that’s essentially what it is: don’t return the result of a function through <code>return</code> at the end, but rather „pass each result value on individually“ via a continuation (a function pointer). The effect of that: downstream processing of results does not need to wait for all parts of a result to become available. Maybe there is a huge number of result items which should not all be loaded into memory or items become available only sporadically. In both cases it can help to process them as a stream of single items instead of as a collection of many items. FP is hiding <code>return</code> in pipeline functions and with iterators, Rx is getting rid of it. And what’s the benefit of that? Primarily more efficiency, I’d argue. Data can get processed earlier (async) and more independently (in parallel). Also one could say that it’s more natural in certain cases, i.e. easier to reason about.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2620"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-3.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-3-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-3-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-3-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-3-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-3-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-3-2xl.png 1600w" alt="" width="663" height="316"></figure></figure></div><p></p><p></p><h3>Actor Programming</h3><p></p><p></p><p>With actors programming gets rid of threads. Threads are of no more concern to the programmer; they get allocated and assigned in the background. And with threads gone also synchronization is gone. No more semaphores or locks. Because actors are guaranteed their own resources and to run on a single thread. Data is passed to them via a queue (mailbox) and passed on to others via their queues. No waiting, no synchronous request/response. Less detailed control - but more peace of mind. Abandoning threads with all the ensuing complexity to manage shared resource access is clearly a means to make it easier to reason about code. Evolvability is increased and larger concurrent code bases can be written.</p><p></p><p></p><h3>Object-Oriented Programming</h3><p></p><p></p><p>I have to admit I don’t really understand what was meant by „getting rid of function pointers“. I can only imagine that it alluded to the lack of polymorphism of static function calls. In the next code example the calls to all functions are fixed, they are baked into the <code>Client</code> function. No way to change them at runtime to alternatively call some other function. That’s the opposite of flexibility.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2623"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-4.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-4-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-4-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-4-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-4-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-4-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-4-2xl.png 1600w" alt="" width="451" height="219"></figure></figure></div><p></p><p></p><p>Compare that to an OOP variant:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2625"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-5.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-5-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-5-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-5-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-5-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-5-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-5-2xl.png 1600w" alt="" width="598" height="447"></figure></figure></div><p></p><p></p><p>Sure there now is more complexity – but what is gained is flexibility. By indirectly calling a service’s <code>Process</code> function through an object (<code>_s</code>) a variation point is created. The <code>Client</code>does not care any longer which function provides the service to process the text read from the file. The <code>Client</code> is not dependent on a concrete service, but just on an abstraction (interface <code>IService</code>). That’s an application of the <em>Dependency Inversion Principle (DIP)</em>.</p><p></p><p></p><p>This interface can be implemented by different concrete services as is done by <code>Service</code> and <code>AnotherService</code>. Where a <code>Client</code> is created it can be configured to use any service conforming to the interface. A service implementation is instantiated and injected into a <code>Client</code> object. That’s an application of <em>Inversion of Control (IoC)</em>.</p><p></p><p></p><p>Great, isn’t it? OOP based on DIP + IoC increases the flexibility of code. That’s useful to make it adaptable for future requirements. That’s also useful for making it more testable.</p><p></p><p></p><p>Sounds like OOP was helping evolvability, doesn’t it? Because evolvability benefits from flexibility and testability (due to its potential to increase correctness).</p><p></p><p></p><h2>Object-Oriented Programming is different</h2><p></p><p></p><p>At first I thought, Wolfgang’s list was just great and to the point. But then I noticed it was mixing two categories of programming paradigms.</p><p></p><p></p><p>All had one thing in common: letting go of something that was possible, but somehow had a detrimental effect if used unbridled.</p><p></p><p></p><p>However the detrimental effect was concerning different aspects of software. With SP and FP and AP it clearly is the understandability of code. By using <code>goto</code>, mutability, and threads explicitly, by trying to control behavior on such a detailed level, code becomes hard to reason about.</p><p></p><p></p><p>To some extend that’s also true for using <code>return</code>. But the effect is much smaller. The situations where <code>return</code> stands in the way of easy to design/unterstand code, are comparatively rare, I’d say. FP is doing more good by hiding loops, than Rx is doing by avoiding <code>return</code> in favor of continuations. I’d even argue that Rx is adding complexity (i.e. decreasing understandability) in order to gain some other benefits. Compare the above FP code sample to the Rx code sample; you’ll find the latter „less easy on your eyes“.</p><p></p><p></p><p>But still, of course, Rx is useful. It just excels in another area as for example SP does. That’s my point.</p><p></p><p></p><p>With SP and FP and AP the point of letting go, of voluntary self-restraint very clearly is increasing understandability of code. Not so with Rx. Its focus, to me, is more in the realm of efficiency, i.e. some runtime characteristic (e.g. responsiveness).</p><p></p><p></p><p>And now OOP. With OOP the mismatch with SP etc. is even more pronounced.</p><p></p><p></p><p>OOP, at least mainstream OOP from the 1990s on, in my view was not supposed to increase understandability. Rather it was supposed to increase short term productivity. Bluntly put its message was: Quickly whip up abstractions and reuse them all over the place.</p><p></p><p></p><p>Sure, this also was supposed to help in the long run. But, alas, it did not really deliver on that. And my guess is, because it’s <em>not</em> really about letting go; there is no real self-restraint in OOP. That’s why it’s not fitting in the above list.</p><p></p><p></p><p>Look at the OOP code sample again. Does that look simpler than the previous one with the static functions? No! For the purpose of flexibility (through interface polymorphism) OOP is creating complexity.</p><p></p><p></p><p>SP, FP, AP are effectively hiding details for the benefit of understandability. However, OOP (and also Rx) are creating additional details.</p><p></p><p></p><p>OOP is not in the venerable tradition of SP, FP, AP! It’s not really getting rid of a complexity problem. It’s creating one.</p><p></p><p></p><p>That does not mean OOP is bad. I like the features of OOP languages like C#. I would not want to do without them. They are useful. But where they are useful for higher understandability of code that does come from „getting rid of function pointers“.</p><p></p><p></p><p>But what are OOP’s achievements? Where does its features abstract from details to increase understandability? How does it really let go?</p><p></p><p></p><h3>Getting rid of visibility</h3><p></p><p></p><p>The first feature of OOP it brought to the masses was modularization. Modularization was deemed important since the early 1970s. See another seminal paper as a testimony to that: <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf" target="_blank" rel="noopener">„On the Criteria To Be Used in Decomposing Systems into Modules“ by D.L. Parnas</a>.</p><p></p><p></p><p>Nevertheless features for effective modularization were lacking for a long time: C accomplished this half-heartedly in my view through .h files. Pascal was missing modules altogether. Modula was never broadly accepted, even less Oberon. And Ada was too heavy weight. Dialects of Pascal like USCD featured modules, lacked acceptance. Only when C++ made it into the mainstream, and then Delphi, and then Java became modules a feature at the fingertips of many programmers.</p><p></p><p></p><p>But what do I mean by „module“? You sure have an intuition about that which will overlap with my idea. Nevertheless let me state mine here to avoid misunderstandings:</p><p></p><p></p><p>A module to me is an aggregation of functions and possibly data. In that it’s resembling a namespace. But in addition to a namespace a module offers to selectively make its elements visible to the outside. The distinctive feature of a module is its interface, i.e. the collection of public/accessible elements which is a subset of all its elements.</p><p></p><p></p><p>The interface of the following <code>Stack</code> module consists of just two methods: <code>Push</code> and <code>Pop</code>. But <code>Stack</code> aggregates more than that: some data plus another function. These details, though, it hides as <code>private</code>.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2629"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-6.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-6-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-6-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-6-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-6-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-6-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-6-2xl.png 1600w" alt="" width="641" height="308"></figure></figure></div><p></p><p></p><p>Modules are aggregations of functions and data with a reduced surface. That’s so great about them. The possibility to distinguish between public and private elements enables encapsulation. Like with functions: how a function accomplishes its task is hidden behind its signature. Modules take that to the next level for several functions plus shared data.</p><p></p><p></p><p>It’s possible (and the default) to make all functions and all data visible to all parts of the code – but you should not do it. Restrain yourself! Modules do for structure what SP does for behavior: short term freedom is limited for long term understandability.</p><p></p><p></p><p>However, modules differ from control statements. With SP it’s (almost) not possible to do the wrong thing anymore (meaning to use <code>goto</code>). Control statements take the programmer by her hand. Modules, though, are just making an offer. You still have to make hard decisions yourself: What to include in this module vs that module, what to make visible vs what to hide.</p><p></p><p></p><p>That, I guess, is the reason, why modularization in general or OOP in particular until today did not have the same overall beneficial effect as SP. Still too much freedom or uncertainty. Too much you can do wrong.</p><p></p><p></p><p>Modules are helping to increase the understandability and thus evolvability of code. They allow codebases to grow larger, because an increasing number of details can be hidden behind interfaces. That’s great!</p><p></p><p></p><p>But I see more need for letting go.</p><p></p><p></p><h3>Getting rid of availability</h3><p></p><p></p><p>Modules were available before OOP, but not that widely used, I’d say. With OOP this changed. But the reason was not the increase in understandability to be gained. Rather OOP promised to make software able to more resemble the real world.</p><p></p><p></p><p>The „obvious“ structure of the real world seems to be made up of, well, objects. With objects being „things“ with some state reacting to forces and stimuli of all sorts.</p><p></p><p></p><p>OOP promised software to also consist of a mesh of „things“ with behavior based on hidden state.</p><p></p><p></p><p>The foundation for that of course were modules. They provided the ability to hide details like state - but the state existed only once. What about state for all the different „things“ in the world, i.e. multiple similar state? How to create a multitude of „things“ in the first place?</p><p></p><p></p><p>OOP needed to let go of universal availability (of single data items) to solve that problem.</p><p></p><p></p><p>Here’s what the problems was before OOP even when using modules:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2626"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-7.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-7-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-7-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-7-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-7-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-7-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-7-2xl.png 1600w" alt="" width="610" height="310"></figure></figure></div><p></p><p></p><p>Global data was the default before OOP. All data was available to all functions (to which it was visible). The <code>Queue&lt;T&gt;</code> module is different than the above <code>Stack&lt;T&gt;</code> module: The stack is working on just one, although hidden data structure; there can only be one stack (of a given type) at runtime. But if there are supposed to be many queues, the basic data structure needs to be handed to the <code>Queue&lt;T&gt;</code> module functions. That means the basic data structure is available to everybody because it’s managed outside the <code>Queue&lt;T&gt;</code> module. It’s not hidden and thus is not protected from arbitrary manipulation by other than queue logic.</p><p></p><p></p><p>Enter OOP. OOP’s instantiable modules (classes) made it possible to limit the availability of data. By binding data to functions inside of an object access could be even more limited than with modularization.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2631"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-8.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-8-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-8-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-8-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-8-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-8-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-8-2xl.png 1600w" alt="" width="551" height="356"></figure></figure></div><p></p><p></p><p>Data did not „float around“ anymore, it dit not need to be widely available despite restricted use, but could be tied to the place of its usage.</p><p></p><p></p><p>I think this is a quite helpful feature. It is limiting the ways you can use data in a wrong way. It is limiting the scope of its relevancy even further. That helps understanding code better.</p><p></p><p></p><p>But my feeling is that class modules (as templates from which objects are generated) are less of a boon for evolvability than modularization. As shown above in conjunction with interface types they allow polymorphy, but that comes at a price.</p><p></p><p></p><p>Also like with modularization classes are optional. A programmer has to decide when and how to use them. And for the past 25 years a lot of things have gone wrong with classes. Not so with the control statements of SP.</p><p></p><p></p><p>Whenever a control statement is used instead of <code>goto</code> statements, code will be easier to understand. That cannot be said of all classes defined in a program. Hence my feeling that also this feature of OOP leaves something to be desired. And see above for the complexity which can be easily introduced using classes/objects (despite its usefulness).</p><p></p><p></p><p>So my feelings are a bit mixed with regard to „getting rid of availability“.</p><p></p><p></p><p>More real letting go is needed. That means: Whenever you don’t do something that could be done technically and usually is done, it’s a win for understandability and possibly other aspects supporting high longterm productivity.</p><p></p><p></p><h2>The missing relinquishment</h2><p></p><p></p><p>More letting go is needed. I’m sure of that. We really should do less of what’s possible. Not all that can be done, should be done. But what to let go of in the name of more understandability? How to make code easier to reason about or also more testable?</p><p></p><p></p><p>Candidates for letting go are features of our programming languages (and platforms) which are widely used, which seem unsuspicious of causing harm on the surface, but when looking closely lead to lots of „WTF!“.</p><p></p><p></p><p>The infamous <code>goto</code> fits this description perfectly. Also immutable data (aka „assignments“) and threads fit it. Not so, though, <code>return</code> or static functions (aka „function pointers“), I think.</p><p></p><p></p><p>But what else? What’s causing pain today through unbridled use?</p><p></p><p></p><p>Here are my main two candidates:</p><p></p><p></p><ul><li>overloaded data structures, and</li><li>functional dependencies.</li></ul><p></p><p></p><h3>The problem with overloaded data structures</h3><p></p><p></p><p>Martin Fowler identified the „<a href="https://martinfowler.com/bliki/AnemicDomainModel.html" target="_blank" rel="noopener">aemic domain model</a>“ as an anti-pattern.</p><p></p><p></p><blockquote class="wp-block-quote"><p>„The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing. There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. <strong>The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects,</strong> making them little more than bags of getters and setters.“ (emphasis mine)</p></blockquote><p></p><p></p><p>I agree, sometimes data structures, i.e. OOP classes which represent data, which „are“ data, are not used as platforms for behavior closely related to their data. This smells of <a href="https://www.jamesshore.com/Blog/PrimitiveObsession.html" target="_blank" rel="noopener">primitive obsession</a>, I’d say.</p><p></p><p></p><p>On the other hand, however, I think many OOP code bases are suffering from the opposite: overloaded data structures. To me that’s classes which start with a fuzzy responsibility; their job is neither clearly „being“ data, nor being „a service“. And from that then follows an accumulation of all sorts of functionality.</p><p></p><p></p><p>And this accumulation of functionality around a fuzzy responsibility leads to all sorts of dependencies to other classes which make the code hard to understand.</p><p></p><p></p><p>I think, we need to stop that. We need to get rid of „anything goes“ with regard to classes. DDD tried this with its tactical patterns: value object, entity, aggregate, repository, service.</p><p></p><p></p><p>For a general adoption I find this categorization too complicated or too specific. We can start much simpler by just distinguishing two kinds of classes:</p><p></p><p></p><ul><li>classes whose purpose it is to <em>be</em> data (data classes)</li><li>classes whose purpose it is to provide functionality and which might <em>have</em> (hidden) data (state) (behavior classes)</li></ul><p></p><p></p><p>Behavior classes do not publish data, they don’t have a structure with regard to data. Behavior classes just offer functionality - which of course transforms input data into output data. Data is flowing through behavior classes (be they static or non-static). And if their behavior requires access to some resource or keep a memory of data… then behavior classes can <em>have</em> data hidden inside them. Such data can be an accumulated value or a reference to some service object.</p><p></p><p></p><p>Behavior classes offer functions/methods, no fields, not properties (C#)/getters/setters (or only rarely).</p><p></p><p></p><p>Data classes on the other hand are about, well, data. Their very purpose is to offer fields or properties (C#)/getters/setters. They are supposed to have a data structure consisting of values aggregated under the roof of an object or nested deeply in a richly connected data model.</p><p></p><p></p><p>Data classes should not publish functionality - except very limited one concerning their structure and consistency. Data classes may hide the details of how they keep their data like the above OOP version of a queue does. Then they are <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener">abstract data types (ADT)</a>.</p><p></p><p></p><p>I love OOP languages for their ability to easily define ADTs. It’s great to be able to associate functionality with data in a class.</p><p></p><p></p><p>But therein lies a danger, too! And that’s why I think we need to have strict rules as to what should be done with classes. It should no longer be „anything goes“!</p><p></p><p></p><p>Data classes should be restricted to functionality which just guarantees consistency of the data and allows easy access to it. And all that without resorting to resource access or other „heavy framework use“.</p><p></p><p></p><p>The first reason for that restriction: Access to special 3rd party functionality should be confined to adapters. Only that way it can easily be tested and if need be replaced. Data structures which get created in many places and moved around should neither depend on such details, nor on adapters which would probably need to get injected.</p><p></p><p></p><p>And the second reason: Data structures are meant to be dependable. Lots of code is supposed to use on them. Their dependency fan-in is large by purpose. That means, data structures need to be stable. They should not change too often because that would raise the risk of ripple effects. Hence whatever increases the likelihood of data structures to change should be avoided. Rich behavior based on deeply nested functions possibly across many classes is a danger to stability.</p><p></p><p></p><p>Finally a third reason: Since data structures are so broadly used they need to be present before their clients. Better to be able to develop them quickly. The more behavior they are loaded with, though, the longer it takes to code and test them. Rich functionality on data structure is an impediment to team productivity.</p><p></p><p></p><p>In the end, though, overloaded data structures are the lesser problem, I think. The real problem to get rid of first are functional dependencies.</p><p></p><p></p><h3>The problem with functional dependencies</h3><p></p><p></p><p>Functional dependencies are the bane of programming since the invention of subroutines. At the same time they are one of the most natural aspects of code. They are so natural, so intuitive, so common, that hardly anybody is thinking of them. Everybody is just creating them in any number without hesitation. And why not? Aren’t they even inevitable?</p><p></p><p></p><p>This attitude is the problem! It’s exactly the same as it was with <code>goto</code> back until the 1970s.</p><p></p><p></p><p>Functional dependencies are a fundamental problem while at the same time being the most natural thing to do. That’s why I titled this article with „considered harmful“: to put them next to <code>goto</code> and the damage that was caused by its „intuitive use“.</p><p></p><p></p><p>To avoid a misunderstanding let me quickly explain what I mean by <em>functional dependency</em>. It’s not that I want to get rid of function calls at all. But a certain form of function calls is a dangerous weapon whose use needs regulation, I think.</p><p></p><p></p><p>Here is an example of a functional dependency:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2618"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-9.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-9-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-9-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-9-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-9-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-9-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-9-2xl.png 1600w" alt="" width="397" height="331"></figure></figure></div><p></p><p></p><p>The red code I call <em>logic,</em> i.e. it’s the part of the code directly responsible for creating behavior. The green code are function calls to other parts of the code with more logic.</p><p></p><p></p><p><em>Functional dependency</em> means, that logic depends on other logic <em>through function calls</em>.</p><p></p><p></p><p>Such dependency is inevitable once it comes to third party logic, of course. <code>Console.ReadLine</code> or even <code>&gt;</code> or <code>if</code> are or can be understood as function calls. But they belong to the „substrate“ an application is built on, which is provided by a third party (language vendor, framework manufacturer).</p><p></p><p></p><p>Functional dependencies thus are mixtures of „pure substrate“ use (aka logic) and calls to functions you yourself are responsible for. In the above example that’s <code>Load</code> and <code>Store</code> of some „home grown“ database object.</p><figure class="wp-image-1756 size-medium aligncenter"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-12-300x151.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-12-300x151-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-300x151-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-300x151-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-300x151-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-300x151-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-300x151-2xl.png 1600w" alt="" width="300" height="151"></figure><p></p><p></p><p>This should look all very normal to you. What should be wrong about calling some functions from logic? And it sure is much better than the alternative without any such functions:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2628"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-10.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-10-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-10-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-10-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-10-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-10-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-10-2xl.png 1600w" alt="" width="539" height="473"></figure></figure></div><p></p><p></p><p>Without the database logic extracted into its own functions (even its own class) it’s much harder to understand what’s going on.</p><p></p><p></p><p>True. Just logic without some function calls does not scale with regard to understanding. But even with some logic extracted into other functions not all’s well.</p><p></p><p></p><ul><li>Functional dependencies violate the <em>Single Level of Abstraction (SLA)</em> principle. It’s still hard to understand the first version of <code>Run</code> with the functional dependencies.</li><li>Functional dependencies cause logic to expand indefinitely. You know that’s true, you have seen functions with 100, 500, 1000, maybe even 5000 lines of logic mixed with function calls. They exist, because it’s so easy to push logic down into extracted functions - and then add more. It’s the mixture between logic and function calls - aka functional dependencies -, that encourages such practice. To resist is very hard, especially when facing a deadline.</li><li>Functional dependencies add complexity when you want to get rid of them for testing. And you want to automatically test your logic, don’t you? Logic is very hard to get right. So, how can you test just the logic in the first version of the <code>Run</code> method above? You need to substitute the real database logic with some fixed results. And on top of that you also need to get rid of the user interaction. More extraction of logic is needed. Here’s the resulting code for <code>Run</code> and a test substituting the functional dependencies (thanks to DIP and IoC). That’s quite some hoops to jump through just to get some functionally dependent logic tested.</li></ul><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2622"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-11.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-11-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-11-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-11-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-11-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-11-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-11-2xl.png 1600w" alt="" width="780" height="483"></figure></figure></div><p></p><p></p><ul><li>Functional dependencies distribute the creation of behavior vertically across a code base. In order to understand how some effect is created you have to follow a trail of function calls into the depth of the function call tree. It’s hard to get an overview of what’s happening. The process of behavior creation is nowhere to be seen in its entirety on a certain level of abstraction. That’s why you’re constantly using the debugger when trying to understand code.</li><li>Functional dependencies violate the <em>Single Responsibility Principle (SRP)</em>because they mix two <em>formal</em> responsibilities in a single function: 1) creating behavior (logic), 2) composing behavior from „services“.</li></ul><p></p><p></p><p>In short: <strong>Functional dependencies make code hard to understand and difficult to test. They add complexity and violate wide accepted principles of clean code.</strong></p><p></p><p></p><p>Functional dependencies to me are a core impediment to understanding, testing, and also refactoring code.</p><p></p><p></p><p>We need to strictly restrain the use of functional dependencies or even get rid of them altogether wherever possible.</p><p></p><p></p><p>It’s the same as it was with <code>goto</code>: The unbridled use of functional dependencies is causing a lot of harm. And the sad thing about it is it’s taken as normal or inevitable.</p><p></p><p></p><h2>Functional dependencies: Just dont’t!</h2><p></p><p></p><p>What’s the solution to the functional dependency problem? Don’t mix logic and calls to your own functions! (Calls to 3rd party functions are logic by definition.)</p><p></p><p></p><p>Yes, just don’t!</p><p></p><p></p><p>That means, <strong>all your functions contain either just logic (I call such functions <em>operations</em>) or don’t contain any logic but just calls to other functions (I call such functions <em>integrations</em>).</strong></p><p></p><p></p><p>Here’s the <code>Run</code> function morphed into an integration:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2627"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-12.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-12-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-12-2xl.png 1600w" alt="" width="357" height="170"></figure></figure></div><p></p><p></p><p>All the difficult to get right logic has been extracted into operations (even in other classes).</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2624"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-13.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-13-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-2xl.png 1600w" alt="" width="818" height="386"></figure></figure></div><p></p><p></p><p>Some of it had already been extract, but now it’s all of it. Why extract only part of it anyway?</p><figure class="size-medium wp-image-1757 aligncenter"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-13-300x190.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-13-300x190-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-300x190-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-300x190-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-300x190-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-300x190-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-13-300x190-2xl.png 1600w" alt="" width="300" height="190"></figure><p></p><p></p><p>The result is a <code>Run</code> method with beautiful characteristics:</p><p></p><p></p><ul><li>It’s conforming to the SLA, or at least much more than before. More about that in a minute.</li><li>It’s conforming to the SRP. Its sole responsibility is to integrate.</li><li>It’s very easy to understand because it shows the whole process of how its purpose is achieved at a single glance.</li><li>No need to test it. There is no logic in it, so what can go wrong? Ok, yes, there is a slim chance of getting the integration wrong. But that’s negligible. (I’m not against testing integrations, but the need for that is much reduced. And if you test them, you should not substitute the functions called.) Hence there is no (or at least much less) need to add complexity through interfaces and mocking.</li><li>All functions are short. This is an effect of the strict rule not to mix logic and function calls: 1) Integrations don’t grow large because it’s easy to refactor them once you feel you lose track of what’s going on. 2) Operations don’t grow because pure logic soon becomes unwieldy. Hence you feel the urge to extract some of it. Great, do that! But then the operation needs to be turned into an integration. All logic has to be extracted somehow.</li><li>It’s easy to refactor. If I think the SLA principle could be strengthened by extracting a bit more that’s quickly done, e.g.</li></ul><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2632"><img loading="lazy" src="https://ralfw.de/media/posts/129/DraggedImage-14.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/129/responsive/DraggedImage-14-xs.png 300w, https://ralfw.de/media/posts/129/responsive/DraggedImage-14-sm.png 480w, https://ralfw.de/media/posts/129/responsive/DraggedImage-14-md.png 768w, https://ralfw.de/media/posts/129/responsive/DraggedImage-14-lg.png 1024w, https://ralfw.de/media/posts/129/responsive/DraggedImage-14-xl.png 1360w, https://ralfw.de/media/posts/129/responsive/DraggedImage-14-2xl.png 1600w" alt="" width="508" height="270"></figure></figure></div><p></p><p></p><h2>Summary</h2><p></p><p></p><p><strong>Even after getting rid of <code>goto</code> almost 50 years ago code today is suffering from unrestrained use of language features to the detriment of understandability and testability. This is severely hampering its evolvability and thus longterm team productivity.</strong></p><p></p><p></p><p>Elements of Functional Programming and Actor Programming help. Some of OOP’s features also help. But there’s a fundamental and deeply ingrained problem remaining: functional dependencies.</p><p></p><p></p><p>Fortunately it’s not that hard to get rid of it. A simple rule can be your guide: make your functions either free of logic or full of logic. Either let them only call other functions or none at all.</p><p></p><p></p><p>I could call this <em>Message-Oriented Programming</em> for reasons extensively explained <a href="https://leanpub.com/softwareentwurf-mit-flow-design" target="_blank" rel="noopener noreferrer">here in my current book</a> (or somewhat shorter <a href="http://geekswithblogs.net/theArchitectsNapkin/archive/2013/09/08/oop-as-if-you-meant-it.aspx" target="_blank" rel="noopener noreferrer">here in a series of old blog posts</a>). It’s actually good OO practice to follow this rule. At least if you find value in the original definition of Object-Orientation by Alan Kay.</p><p></p><p></p><p>To push down logic the function dependency tree is easier than you think. You just have to try and cultivate this as an ideal. It’s like growing a new aesthetic sense. I cannot ever do without it anymore. All my code follows this rule. Like it follows the rules of Structured Programming or Actor Programming: no more <code>goto</code>s, no more threads.</p><p></p><p></p><p>One function depending on another won’t go away in the near future. But <em>functional dependency</em> can - and should! Functional dependencies are harmful to your team’s productivity. It’s that simple. Get rid of them.</p><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 28.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/flow-design/">Flow-Design</a></li><li><a href="https://ralfw.de/tags/oop/">OOP</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/revolutions-over-velocity/" class="invert post__nav-link" rel="prev"><span>Previous</span> Revolutions Over Velocity</a></div><div class="post__nav-next"><a href="https://ralfw.de/against-pseudo-wisdom/" class="invert post__nav-link" rel="next"><span>Next</span> Against pseudo-wisdom </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>