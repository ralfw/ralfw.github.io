<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>The SRP is not about â€extract till you drop!â€œ - ralfw-de</title><meta name="description" content="I have been chasing a better definition for the Single Responsibility Principle (SRP) for quite a while. â€A reason to changeâ€œ is too fuzzy for me. And even Robert C. Martinâ€™s latest explanation does not fit the bill, I think, even though I like it&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://ralfw.de/the-srp-is-not-about-extract-till-you-drop/"><link rel="alternate" type="application/atom+xml" href="https://ralfw.de/feed.xml"><link rel="alternate" type="application/json" href="https://ralfw.de/feed.json"><meta property="og:title" content="The SRP is not about â€extract till you drop!â€œ"><meta property="og:image" content="https://ralfw.de/media/website/logo-smaller.png"><meta property="og:site_name" content="ralfw-de"><meta property="og:description" content="I have been chasing a better definition for the Single Responsibility Principle (SRP) for quite a while. â€A reason to changeâ€œ is too fuzzy for me. And even Robert C. Martinâ€™s latest explanation does not fit the bill, I think, even though I like it&hellip;"><meta property="og:url" content="https://ralfw.de/the-srp-is-not-about-extract-till-you-drop/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@ralfw"><meta name="twitter:title" content="The SRP is not about â€extract till you drop!â€œ"><meta name="twitter:description" content="I have been chasing a better definition for the Single Responsibility Principle (SRP) for quite a while. â€A reason to changeâ€œ is too fuzzy for me. And even Robert C. Martinâ€™s latest explanation does not fit the bill, I think, even though I like it&hellip;"><meta name="twitter:image" content="https://ralfw.de/media/website/logo-smaller.png"><link rel="shortcut icon" href="https://ralfw.de/media/website/favicon.png" type="image/x-icon"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://ralfw.de/assets/css/style.css?v=c13570ce2327ee7300beba58cfcdd736"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ralfw.de/the-srp-is-not-about-extract-till-you-drop/"},"headline":"The SRP is not about â€extract till you drop!â€œ","datePublished":"2019-04-28T10:44","dateModified":"2021-01-25T16:26","image":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250},"description":"I have been chasing a better definition for the Single Responsibility Principle (SRP) for quite a while. â€A reason to changeâ€œ is too fuzzy for me. And even Robert C. Martinâ€™s latest explanation does not fit the bill, I think, even though I like it&hellip;","author":{"@type":"Person","name":"Ralf Westphal","url":"https://ralfw.de/authors/ralf-westphal/"},"publisher":{"@type":"Organization","name":"Ralf Westphal","logo":{"@type":"ImageObject","url":"https://ralfw.de/media/website/logo-smaller.png","height":53,"width":250}}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://ralfw.de/"><img src="https://ralfw.de/media/website/logo-smaller.png" alt="ralfw-de"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://ralfw.de/focus/" target="_self">Focus</a></li><li><a href="https://ralfw.de/approach/" target="_self">Approach</a></li><li class="has-submenu"><a href="https://ralfw.de/trainings/" target="_self" aria-haspopup="true">Trainings</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfw.de/test-first-codierung/" target="_self">Test-first CodierungğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.de/softwareentwurf-mit-flow-design/" target="_self">Softwareentwurf mit Flow-DesignğŸ‡©ğŸ‡ª</a></li><li><a href="https://ralfw.de/software-anforderungsanalyse-mit-slicing/" target="_self">Software Anforderungsanalyse mit SlicingğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.de/consulting/" target="_self">Consulting</a></li><li><a href="https://ralfw.de/publications/" target="_self">Publications</a></li><li><a href="https://ralfw.de/testimonials/" target="_self">Testimonials</a></li><li class="has-submenu"><a href="https://ralfw.de/" target="_self" aria-haspopup="true">BlogsğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://ralfwestphal.substack.com/" target="_blank">Newsletter @ substack.com</a></li><li><a href="https://ralfw.de/" target="_self">2015.. ğŸ‡©ğŸ‡ªğŸ‡¬ğŸ‡§</a></li><li><a href="https://blog.ralfw.de/" target="_blank">ğŸŒ2007..2015ğŸ‡©ğŸ‡ª</a></li><li><a href="http://geekswithblogs.net/theArchitectsNapkin/Default.aspx" target="_blank">ğŸŒ2008..2015ğŸ‡¬ğŸ‡§</a></li><li><a href="https://weblogs.asp.net/ralfw" target="_blank">ğŸŒ2003..2010ğŸ‡¬ğŸ‡§</a></li><li><span class="is-separator">â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></li><li><a href="http://soziokratie.ralfw.de/" target="_blank">ğŸŒZur SoziokratieğŸ‡©ğŸ‡ª</a></li><li><a href="https://medium.com/gedankliche-umtriebe" target="_blank">ğŸŒGedankliche UmtriebeğŸ‡©ğŸ‡ª</a></li><li><a href="https://medium.com/personal-flow" target="_blank">ğŸŒPersonal FlowğŸ‡©ğŸ‡ª</a></li></ul></li><li><a href="https://ralfw.de/about/" target="_self">About</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://ralfw.de/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2019-04-28T10:44">28.04.2019</time></div><h1>The SRP is not about â€extract till you drop!â€œ</h1><div class="post__meta post__meta--author"><a href="https://ralfw.de/authors/ralf-westphal/" class="feed__author invert">Ralf Westphal</a></div></div></header></div><div class="wrapper post__entry"><p></p><p>I have been chasing a better definition for the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">Single Responsibility Principle (SRP)</a> for quite a while. â€A reason to changeâ€œ is too fuzzy for me. And even Robert C. Martinâ€™s <a href="https://twitter.com/unclebobmartin/status/1023192440579215360?ref_src=twsrc%5Etfw&amp;ref_url=notion%3A%2F%2Fwww.notion.so%2Fralfw%2FSRP-erkl-rt-942eed98afb343adabb3c9a02bf43422" target="_blank" rel="noopener">latest explanation</a> does not fit the bill, I think, even though I like it more than previous definitions:</p><p></p><p></p><blockquote class="wp-block-quote"><p>In order for a function to do â€œone thingâ€ it must be so small that no meaningful function can be extracted from it. Any function from which another can be extracted clearly does more than â€œone thingâ€.</p></blockquote><p></p><p></p><p>The other day I came across his article <a href="https://sites.google.com/site/unclebobconsultingllc/one-thing-extract-till-you-drop" target="_blank" rel="noopener">â€One Thing: Extract till you Drop.â€œ</a>, which seems to be an early appearance of his above definition. And now I know why I donâ€™t like it as much as I first though.</p><p></p><p></p><p>Let me explain...</p><p></p><p></p><h2>A dirty code example</h2><p></p><p></p><p>Look at the dirty code Robert C. Martin presented:</p><figure class="alignnone size-full wp-image-2458"><img loading="lazy" src="https://ralfw.de/media/posts/122/SymbolReplacerOriginal.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/SymbolReplacerOriginal-xs.png 300w, https://ralfw.de/media/posts/122/responsive/SymbolReplacerOriginal-sm.png 480w, https://ralfw.de/media/posts/122/responsive/SymbolReplacerOriginal-md.png 768w, https://ralfw.de/media/posts/122/responsive/SymbolReplacerOriginal-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/SymbolReplacerOriginal-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/SymbolReplacerOriginal-2xl.png 1600w" alt="" width="672" height="398"></figure><p></p><p></p><p>Whatâ€™s so dirty about it? Itâ€™s mainly some 7 lines of logic in <code>replace()</code>. Do they need refactoring? Does the whole class need refactoring?</p><p></p><p></p><p>What bothered me most when I looked at that code first was not that it violated the SRP in some way. Besides being not so familiar with Java I rather stumbled over:</p><p></p><p></p><ul><li>the lack of at least a single automated test</li><li>the missing function <code>getSymbol()</code></li></ul><p></p><p></p><p>I did not really get what the code was supposed to do for quite a while. The explanation given</p><p></p><p></p><blockquote class="wp-block-quote"><p>Itâ€™s not too hard to understand. The replace() function searches through a string looking for $NAME and replaces each instance with the appropriate translation of NAME. It also makes sure that it doesnâ€™t replace a name more than once.</p></blockquote><p></p><p></p><p>still left me with question marks over my head. And I think a simple test or some other form of application/example would have helped me to get what the overall purpose (responsibility) of the code was.</p><p></p><p></p><p>So what I did before reading on was set up <a href="http://jdoodle.com/a/1avQ" target="_blank" rel="noopener">a JDoodle project</a> and play around with the code. I got it to run with a small <code>main()</code> function and sample data as I imagined it:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2449"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-1-1.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-1-1-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-1-1-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-1-1-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-1-1-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-1-1-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-1-1-2xl.png 1600w" alt="" width="506" height="196"></figure></figure></div><p></p><p></p><p>For that, though, I had to come up with a <code>getSymbol()</code> of my own. What was that method about? And why was <code>translate()</code> just redirecting to it?</p><p></p><p></p><p>In the end I settled for a trivial implementation:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2445"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-2-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-2-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-2-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-2-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-2-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-2-2xl.png 1600w" alt="" width="323" height="58"></figure></figure></div><p></p><p></p><p>I assumed the method to translate a placeholder like â€$Xâ€œ into some other text. For understanding the workings of <code>replace()</code> such a translation would not have to be sophisticated. The resulting string then looked like this:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2447"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-3.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-3-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-3-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-3-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-3-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-3-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-3-2xl.png 1600w" alt="" width="165" height="40"></figure></figure></div><p></p><p></p><p>â€Aha!â€œ I thought, now I understood&#x1f600;</p><p></p><p></p><h2>Garbage analysis</h2><p></p><p></p><p>Only after I had gained understanding could I really assess the level of dirtiness the code represented.</p><p></p><p></p><p>Sure, it was legacy code because it lacked tests. But that was easy to fix now. And Robert C. Martin should have done that before starting to refactor, I guess.</p><p></p><p></p><p>But since Iâ€™m no Java buff I first translated the code to C#, then I added a simple â€acceptance testâ€œ:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2451"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-4.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-4-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-4-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-4-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-4-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-4-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-4-2xl.png 1600w" alt="" width="786" height="881"></figure></figure></div><p></p><p></p><p>At first I did not make any changes beyond the necessary to get it run under C#. But then when it was â€securedâ€œ I looked closer. What was wrong with the class?</p><p></p><p></p><p>Robert C. Martin was hinting at a violation of the SRP:</p><p></p><p></p><blockquote class="wp-block-quote"><p>For years authors and consultants (like me) have been telling us that functions should do one thing. They should do it well. They should do it only. The question is: What the hell does â€œone thingâ€ mean? [â€¦] Of course the words â€œIt alsoâ€¦â€ [in â€šIt also makes sure that it doesnâ€™t replace a name more than once.'] pretty much proves that this function does more than one thing.</p></blockquote><p></p><p></p><p>Unfortunately I still was at a loss. As the tests showed, <code>replace()</code> clearly replaced each placeholder more than once. Both â€$Xâ€œ were replaced by the corresponding symbol.</p><p></p><p></p><p>But upon further analysis of the logic I saw that there was an <code>alreadyReplaced</code> list to record the placeholders already replaced by their respective symbols. Thatâ€™s probably what he meant: there was not just replacing going on but a certain kind of replacing. And also (!) there was finding going on, finding of placeholders.</p><p></p><p></p><p>That the overall replacing actually consisted of two activities - finding and a special kind of replacing - was not obvious. Good point!</p><p></p><p></p><p>But besides this and the lack of automated tests I found something else more severe: the application of object-orientation.</p><p></p><p></p><p>What in all the world was an instance class necessary fore in this case? Why introduce a global variable (<code>stringToReplace</code>)? Why make <code>alreadyReplaced</code> a global variable?</p><p></p><p></p><p>My only explanation for that was, Robert C. Martin must have found the code like this in some legacy code base. I donâ€™t want to think he thought it was a good result of OO principle application.</p><p></p><p></p><p>On the other hand the one thing that might warrant the use of an instance class wasnâ€™t anywhere to be found: <code>getSymbol</code>. Clearly the code depended on it, but it was not part of the code. Why not treat it as a strategy and get it injected?</p><p></p><p></p><h2>Refactor to injection</h2><p></p><p></p><p>Thatâ€™s the first thing I tried: I refactored the code to a more adequate use of OO features - at least in my view:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2446"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-5.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-5-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-5-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-5-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-5-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-5-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-5-2xl.png 1600w" alt="" width="710" height="354"></figure></figure></div><p></p><p></p><p>All the logic is now gathered in <code>replace()</code>. No mysterious <code>translate()</code> anymore, and no more global variables. Instead just a pointer to a function doing the symbol lookup. (Use an interface instead if you donâ€™t like typed function pointers.)</p><p></p><p></p><p>A single <code>SymbolReplacer</code> object now can process several source strings, given that the relevant symbol set is the same.</p><p></p><p></p><p>The single responsibility of the class that way is easier to call upon, Iâ€™d say.</p><p></p><p></p><p>Yes, I think the responsibility of the class is pretty single. The class is conforming to the SRP.</p><p></p><p></p><p>But what about the method <code>replace()</code>?</p><p></p><p></p><h2>Itâ€™s about decisions and insights</h2><p></p><p></p><p>The remaining method is not long. I sympathize with John Ousterhout when he writes</p><p></p><p></p><blockquote class="wp-block-quote"><p>This might be the crux of my disagreement with Uncle Bob. To me, "do one thing" refers to the abstraction visible to callers: the method appears to have a single "tight" function (something that can be described and understood very simply). The original code meets this definition.</p></blockquote><p></p><p></p><p><a href="https://groups.google.com/d/msg/software-design-book/Kb5K3YcjIXw/exFaOi_hCAAJ" target="_blank" rel="noopener">in a Google group</a> focused on his book <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" target="_blank" rel="noopener">â€A Philosophy of Software Designâ€œ</a>.</p><p></p><p></p><p>Does it really need refactoring?</p><p></p><p></p><p>Well, maybe not for practical purposes. Not anymore, at least, if there is at least a test making the purpose tangible and spanning a safety net for changes, might they become necessary.</p><p></p><p></p><p>But since Robert C. Martinâ€™s article was an educational one trying to elucidate his understanding of a principle why not be a bit more sensitive?</p><p></p><p></p><p>So, yes, I too think there is room for improvement. But what are the different â€thingsâ€œ assembled under the roof of <code>replace()</code>?</p><p></p><p></p><p>â€Extract till you dropâ€œ is a very formal recommendation. It sets a form goal, itâ€˜s about code shape. But the SRP is about content, purpose. â€Form follows functionâ€œ is valid here too, I guess.</p><p></p><p></p><p>To me there are two aspects important for clean code:</p><p></p><p></p><ul><li>Is the code understandable (easy to reason about)?</li><li>Is the logic easy to test?</li></ul><p></p><p></p><p><strong>Understandability</strong> and <strong>testability</strong> is what Iâ€™m looking for.</p><p></p><p></p><p>Understandability is high when I can easily understand <em>what</em> the code is trying to achieve and <em>how</em> itâ€™s trying to accomplish that.</p><p></p><p></p><p>Testability is high when I can pick a piece of code, especially logic, and easily can apply a test to it.</p><p></p><p></p><p>In example case I can easily see that some replacement is to be achieved. There is an aptly named method telling me that: <code>replace()</code>. But how is replacement done? To understand I cannot just â€read a storyâ€œ. A name (like a headline) is telling a story. Thatâ€™s why good names are so important. <code>replace()</code> is good enough for me here in conjunction with the class name.</p><p></p><p></p><p>But logic, i.e. the content of the above refactored <code>replace()</code> method, is not telling a story. I need to simulate its execution, I need to interpret it. How easy that is depends on its size, the control structures, the conditions, its levels of abstractions.</p><p></p><p></p><p>The size is small in this case. But there are control structures, and even a regular expression. One manâ€™s relief is another manâ€™s burden: thatâ€™s what I keep seeing when it comes to language features/technologies like regular expressions, lambda functions, Linq expressions in C# (or Streams in Java) etc. Even just 8 lines of logic thus might not be that easy to understand.</p><p></p><p></p><p>But how to improve that? Extracting methods is one way to do it. Thatâ€™s what Robert C. Martin is suggesting. And I agree wholeheartedly! But the question remains: Whatâ€™s to go into a function? How many functions are enough?</p><p></p><p></p><p>â€Extract till you dropâ€œ to me is not sensible advice. It focuses on the form.</p><p></p><p></p><p>Rather the focus should be on content, on function, on a problem/solution aspect which can clearly be distinguished.</p><p></p><p></p><p>But what is an aspect of a problem/solution?</p><p></p><p></p><p>I have found, that good guidance is given by two questions:</p><p></p><p></p><ol><li>Which design decisions are encoded in the logic?</li><li>What insights flashed up in my head when I studied the logic?</li></ol><p></p><p></p><p>Two questions plus a bonus question: Whatâ€™s the basic flow the transformational logic is standing for? What are the processing steps?</p><p></p><p></p><p>Letâ€™s apply these criteria to the example:</p><p></p><p></p><ul><li>A major decision (in relation to this tiny scope) is the use of regular expressions. The purpose: compiling the symbol placeholders in the source text.</li><li>Another decision is to use a certain approach to replacing placeholders, i.e. to use the <code>String.Replace()</code> function.</li><li>And an insight it was (for Robert C. Martin) that replacement is done in a special manner: â€just onceâ€œ.</li><li>And it should not be forgotten, that also the format of a placeholder in the source text is a decision; itâ€™s <code>"$" &lt;Identifier&gt;</code>.</li><li>Also how placeholders are translated into symbols is a matter of its own with several pertaining decisions. But the code already encapsulates all those details in a special method <code>getSymbol()</code>. Or you could say, the decision is to have a translation of symbol names to symbols at all.</li></ul><p></p><p></p><p>In my experience it greatly helps understandability and testability to wrap decisions and insights into distinct functions. That would mean:</p><p></p><p></p><ul><li>A function to compile the placeholders to replace.</li><li>A function to actually replace placeholders with their symbols.</li></ul><p></p><p></p><p>Or to encode them in a data structure. That could mean:</p><p></p><p></p><ul><li>A data structure to represent the â€just onceâ€œ insight.</li></ul><p></p><p></p><p>And what about the placeholder format?</p><p></p><p></p><p>Have a look at the refactoring to decisions and insights Iâ€™m suggesting:</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2450"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-6.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-6-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-6-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-6-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-6-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-6-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-6-2xl.png 1600w" alt="" width="730" height="438"></figure></figure></div><p></p><p></p><p>The first thing to jump out should be the simplicity of <code>replace()</code>: itâ€™s just 2 lines of code telling a story by calling two well named functions. Thatâ€™s the process of how the overall transformation is done.</p><p></p><p></p><p>The single responsibility of <code>replace()</code> now is to just integrate both functions into a larger whole. The partial and complementary functionality is put together to form the overall functionality.</p><p></p><p></p><p>Both functions represent a decision from above. And one can be even static which makes it easier to test, if need be. (Should you not like the use of Linq for replacing, then you could just put in whatever looping construct you find easier to understand. The beauty of the refactoring is, that the decision pro Linq is encapsulated in its own function.)</p><p></p><p></p><p>How about the â€just onceâ€œ insight? Itâ€™s represented by the <code>Dictionary&lt;string,string&gt;</code> (or hash map) data structure. It ensures each placeholder is recorded only once - with its symbol.</p><p></p><p></p><p><code>Compile_symbols()</code> also is the only place where the placeholder syntax is encoded. I did not extract it into a data structure or function of its own but rather limited the knowledge about it to a small(er) scope.</p><p></p><p></p><h3>Do it again, Sam?</h3><p></p><p></p><p>Whatâ€™s a decision or insight? Does it have a structure, i.e. consist of nested decisions and insights?</p><p></p><p></p><p>One manâ€™s atom is another manâ€™s structure. So, yes, maybe after some more contemplation I would feel better by extracting the â€just onceâ€œ insight also into a method and not let that know about the structure of a placeholder.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2444"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-7.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-7-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-7-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-7-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-7-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-7-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-7-2xl.png 1600w" alt="" width="782" height="336"></figure></figure></div><p></p><p></p><p>In this case Iâ€™m using (C#â€™s) local functions, though, to make clear that to me this is not that a big deal.</p><p></p><p></p><p>But still, as you can see, there could be another two step process to describe how <code>Compile_symbols()</code> is accomplishing its task.</p><p></p><p></p><p>And there is another data structure: a tuple hiding how a placeholder is structured (<code>pattern</code>) and what the symbol name in a pattern is. And an even smaller method now knows about the placeholder syntax (<code>Extract_placeholders()</code>).</p><p></p><p></p><p>This refactoring to me is optional in this case, however. I donâ€™t need to drop while extracting.&#x1f609;</p><p></p><p></p><h3>Extraction: depth vs breadth</h3><p></p><p></p><p>That said letâ€™s take a quick look at the different results of â€massive extractionâ€œ Robert C. Martin and I got.</p><p></p><p></p><div class="wp-block-image"><figure class="aligncenter"><figure class="wp-image-2448"><img loading="lazy" src="https://ralfw.de/media/posts/122/DraggedImage-8.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://ralfw.de/media/posts/122/responsive/DraggedImage-8-xs.png 300w, https://ralfw.de/media/posts/122/responsive/DraggedImage-8-sm.png 480w, https://ralfw.de/media/posts/122/responsive/DraggedImage-8-md.png 768w, https://ralfw.de/media/posts/122/responsive/DraggedImage-8-lg.png 1024w, https://ralfw.de/media/posts/122/responsive/DraggedImage-8-xl.png 1360w, https://ralfw.de/media/posts/122/responsive/DraggedImage-8-2xl.png 1600w" alt="" width="579" height="276"></figure></figure></div><p></p><p></p><p>Can you spot the fundamental difference? Itâ€™s not the difference in the number of functions. Thatâ€™s only a secondary effect. The primary difference I see is that understanding Robert C. Martinâ€™s code requires you to traverse the function call tree depth first (left hierarchy). Whereas my intention always is to make it understandable by traversing it breadth first.</p><p></p><p></p><p>Can you get an idea of how a function does its job by reading only the names of the functions it calls?</p><p></p><p></p><ul><li>Try it with <code>replace()</code> on the left side: <code>replace()</code> is done byâ€¦ doing <code>replaceAllSymbols()</code>? What does that mean? Whatâ€™s the difference between the two functions? Is there something missing? Interestingly, no.</li><li>Try it with <code>replaceAllSymbols()</code>: thatâ€™s accomplished doing <code>nextSymbol()</code> and <code>replaceAllInstances()</code>? How does that fit together? Is there something missing? Yes, a loop is missing.</li></ul><p></p><p></p><p>Now the right side:</p><p></p><p></p><ul><li><code>replace()</code> is accomplished by <code>Compile_symbols()</code> and then <code>Replace_symbol_names()</code>. Nothing is missing - except for the data this is working on.</li><li><code>Compile_symbols()</code> is processing data by <code>Extract_placeholders()</code> and then <code>Compile_symbol_map()</code>. Again, the only thing missing is the data this is working on.</li></ul><p></p><p></p><p>Also please note, on the right side <code>getSymbol()</code> is only called once.</p><p></p><p></p><p>On the left side processes are spread across the depth of the function call tree. Whereas on the right side they are kept together inside an integrating function.</p><p></p><p></p><p>The solution on the right can be read on different levels of abstraction. Each level is complete in that the full behavior is realized by calling the functions in that order. I use the Unix <code>|</code> symbol to suggest data flowing from one function to another:</p><p></p><p></p><ol><li><code>replace()</code></li><li><code>Compile_symbols() | Replace_symbol_names()</code></li><li><code>Extract_placeholders() | Compile_symbol_map() | Replace_symbol_names()</code></li></ol><p></p><p></p><p>I call that a <a href="https://ccd-school.de/2017/06/stratified-design-over-layered-design/" target="_blank" rel="noopener">stratified design</a>.</p><p></p><p></p><p>This is in stark contrast to Robert C. Martinâ€™s approach:</p><p></p><p></p><ol><li><code>replace()</code></li><li><code>replaceAllSymbols()</code> - there is no gain in calling just one function. How is this on a different level of abstraction than <code>replace()</code>? There is not even any logic missing.</li><li><code>nextSymbol() | replaceAllInstances()</code> - this does not work, since logic is missing; <code>nextSymbol()</code> is not on the same level of abstraction as <code>replaceAllInstances()</code>. <code>replaceAllSymbols()</code> thus violates the SLA.</li><li>Itâ€™s becoming worse going further down the function call tree.</li></ol><p></p><p></p><h2>Summary</h2><p></p><p></p><p>Extraction of functions till you drop is not necessary to clean up your code, it might even be harmful. It focuses to much on the form.</p><p></p><p></p><p>Rather the question is: Which meaningful units of code should be wrapped into functions? To me thatâ€™s decisions (and insights).</p><p></p><p></p><p>I could thus rephrase the SRP as:</p><p></p><p></p><blockquote class="wp-block-quote"><p>Each function or module should represent only one decision on its level of abstraction.</p></blockquote><p></p><p></p><p>A decision is always present if something could be done in a different way. Whether you know what this other way could possibly be or not is of not much importance, though. Thatâ€™s why in the above definition the term â€insightâ€œ is missing. Insights also are concerned with decisions. When you gain an insight you think: â€Ah, itâ€™s this way (and not another way)!â€œ</p><p></p><p></p><p>I still like the term â€insightâ€œ, though. Because it fits the situation better when studying code. Decisions are more of a thing when designing/implementing code.</p><p></p><p></p><h2>P.S. I like semi-functions</h2><p></p><p></p><p>One word about the functions which got extracted in my approach and in Robert C. Martinâ€™s. Roman Leventov calls them <a href="https://medium.com/@leventov/semi-function-a-missing-tool-to-handle-complexity-in-imperative-code-bdefe82d8cf6" target="_blank" rel="noopener">â€semi-functionsâ€œ</a> because the are only used once. They are lacking re-use - which seems to be the purpose of functions for many developers.</p><p></p><p></p><p>But I donâ€™t mind such functions. In fact I like them very much. Because to me functions are not primarily about re-use. They might have been for a long time due to memory scarcity. But those times are gone.</p><p></p><p></p><p>Trying to avoid duplication (application of DRY) is different from looking for opportunities to re-use. Re-use is about productivity: you want to avoid writing code. DRY is about consistency: you want to avoid bugs.</p><p></p><p></p><p>Both are valid reasons for extracting (or designing) functions. To me there are - not surprisingly - yet two others, though: understandability and testability.</p><p></p><p></p><p>I extract (or design) a function for the sole purpose of making the calling one easier to understand. See my code above for that. Whether the extracted function then is only called once or in several places, I donâ€™t care. Iâ€™m content with its signature hiding details and telling me a part of a story where itâ€™s used.</p><p></p><p></p><p>Or I extract (or design) a function even if itâ€™s going to be called just once for the purpose of making its contents easier to test. I donâ€™t want them to be buried somewhere in some other function.</p><p><a href="https://www.reddit.com/r/cleancode/comments/bn9cal/reflections_on_the_srp/" target="_blank" rel="noopener">[If you like let's discuss this on reddit...]</a></p><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 25.01.2021</p><ul class="post__tag"><li><a href="https://ralfw.de/tags/srp/">SRP</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://ralfw.de/managest-du-noch-oder-fuehrst-du-schon-eine-urlaubsimpression/" class="invert post__nav-link" rel="prev"><span>Previous</span> Managest du noch oder fÃ¼hrst du schon? - Eine Urlaubsimpression</a></div><div class="post__nav-next"><a href="https://ralfw.de/sleepy-hollow-architecture-no-application-should-be-without-it/" class="invert post__nav-link" rel="next"><span>Next</span> Sleepy Hollow Architecture - No application should be without it </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>One Man Think Tank @ Nomad Nation OOD - Sofia, Bulgaria - <a href="../../../../../../imprint">Imprint</a> - <a href="../../../../../../data-privacy-policy">Data Privacy Policy</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://ralfw.de/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://ralfw.de/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>